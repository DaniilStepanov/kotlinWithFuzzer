2021-03-12 04:48:06,180 [main:66] - Compilation checking started
2021-03-12 04:48:07,250 [main:45] - Trying to change 2 nodes
2021-03-12 04:48:07,252 [main:53] - replacing (x, String)
2021-03-12 04:48:07,253 [main:50] - replacing x String
2021-03-12 04:48:07,253 [main:54] - Getting value of type String
2021-03-12 04:48:07,345 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:07,348 [main:58] - GENERATED VALUE OF TYPE String = "tjdqv"
2021-03-12 04:48:07,349 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:07,464 [main:67] - randomType = Short
2021-03-12 04:48:07,570 [main:302] - generating value of type = Short true depth = 0
2021-03-12 04:48:07,743 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1793a8e6]
2021-03-12 04:48:07,816 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 04:48:07,818 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1cad68ca]
2021-03-12 04:48:07,914 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:07,918 [main:78] - Generated call from random type = (-6251).compareTo(-120).toString(1737406394)
2021-03-12 04:48:07,918 [main:106] - GETTING String from String
2021-03-12 04:48:07,970 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149], public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1b23eee]]
2021-03-12 04:48:07,970 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149]
2021-03-12 04:48:08,053 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:08,154 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:08,155 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1b23eee]
2021-03-12 04:48:08,252 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:48:08,340 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:48:08,343 [main:117] - GENERATED CALL = (x).subSequence(624678004, -1641404793).commonSuffixWith(StringBuilder(), true)
2021-03-12 04:48:08,343 [main:113] - Case = [public fun kotlin.String.trimIndent(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@26fada87]]
2021-03-12 04:48:08,343 [main:149] - GENERATING call of type public fun kotlin.String.trimIndent(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@26fada87]
2021-03-12 04:48:08,344 [main:117] - GENERATED CALL = (x).trimIndent()
2021-03-12 04:48:08,345 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.removeRange(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3af6c942]]
2021-03-12 04:48:08,345 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.removeRange(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3af6c942]
2021-03-12 04:48:08,433 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:08,505 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:08,507 [main:117] - GENERATED CALL = (x).removeRange(-1970779543, 1701126080)
2021-03-12 04:48:08,507 [main:113] - Case = [public fun kotlin.String.prependIndent(indent: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4feead88]]
2021-03-12 04:48:08,507 [main:149] - GENERATING call of type public fun kotlin.String.prependIndent(indent: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4feead88]
2021-03-12 04:48:08,509 [main:117] - GENERATED CALL = (x).prependIndent(x)
2021-03-12 04:48:08,509 [main:113] - Case = [public fun kotlin.String.replaceIndentByMargin(newIndent: kotlin.String = ..., marginPrefix: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7fec168e]]
2021-03-12 04:48:08,509 [main:149] - GENERATING call of type public fun kotlin.String.replaceIndentByMargin(newIndent: kotlin.String = ..., marginPrefix: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7fec168e]
2021-03-12 04:48:08,511 [main:117] - GENERATED CALL = (x).replaceIndentByMargin(x, x)
2021-03-12 04:48:08,511 [main:113] - Case = [public fun kotlin.String.replaceBeforeLast(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@173f34d8]]
2021-03-12 04:48:08,512 [main:149] - GENERATING call of type public fun kotlin.String.replaceBeforeLast(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@173f34d8]
2021-03-12 04:48:08,590 [main:302] - generating value of type = Char true depth = 0
2021-03-12 04:48:08,593 [main:117] - GENERATED CALL = (x).replaceBeforeLast('㭨', x, x)
2021-03-12 04:48:08,596 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceFirstChar(transform: (kotlin.Char) -> kotlin.Char): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7c3c5f1e]]
2021-03-12 04:48:08,596 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceFirstChar(transform: (kotlin.Char) -> kotlin.Char): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7c3c5f1e]
2021-03-12 04:48:08,712 [main:302] - generating value of type = Function1<Char, Char> false depth = 0
2021-03-12 04:48:08,712 [main:302] - generating value of type = Char true depth = 1
2021-03-12 04:48:08,717 [main:117] - GENERATED CALL = (x).replaceFirstChar({a: Char -> 'ݹ'})
2021-03-12 04:48:08,717 [main:113] - Case = [public fun kotlin.String.replaceFirst(oldChar: kotlin.Char, newChar: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@711cf3c]]
2021-03-12 04:48:08,718 [main:149] - GENERATING call of type public fun kotlin.String.replaceFirst(oldChar: kotlin.Char, newChar: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@711cf3c]
2021-03-12 04:48:08,797 [main:302] - generating value of type = Char true depth = 0
2021-03-12 04:48:08,876 [main:302] - generating value of type = Char true depth = 0
2021-03-12 04:48:08,947 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:48:08,949 [main:117] - GENERATED CALL = (x).replaceFirst('噄', '⊸', false)
2021-03-12 04:48:08,949 [main:113] - Case = [public inline fun kotlin.String.filterNot(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e5b0fe9]]
2021-03-12 04:48:08,949 [main:149] - GENERATING call of type public inline fun kotlin.String.filterNot(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e5b0fe9]
2021-03-12 04:48:09,016 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 04:48:09,016 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 04:48:09,018 [main:117] - GENERATED CALL = (x).filterNot({a: Char -> false})
2021-03-12 04:48:09,018 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.replaceRange(startIndex: kotlin.Int, endIndex: kotlin.Int, replacement: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3a465e1d]]
2021-03-12 04:48:09,018 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceRange(startIndex: kotlin.Int, endIndex: kotlin.Int, replacement: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3a465e1d]
2021-03-12 04:48:09,113 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:09,202 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:09,271 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:48:09,279 [main:117] - GENERATED CALL = (x).replaceRange(1317138963, 2116619673, "fuure")
2021-03-12 04:48:09,279 [main:61] - replacement of x of type String is (x).replaceFirstChar({a: Char -> 'ݹ'})
2021-03-12 04:48:09,348 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:09,348 [main:66] - Compilation checking started
2021-03-12 04:48:09,860 [main:53] - Result = true
Text:
const val x = "OK"

fun box() = (x).replaceFirstChar({a: Char -> 'ݹ'})


2021-03-12 04:48:09,861 [main:53] - replacing ("OK", String)
2021-03-12 04:48:09,861 [main:50] - replacing "OK" String
2021-03-12 04:48:09,861 [main:54] - Getting value of type String
2021-03-12 04:48:09,942 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:09,942 [main:58] - GENERATED VALUE OF TYPE String = "mhrgc"
2021-03-12 04:48:09,942 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:10,032 [main:67] - randomType = ULong
2021-03-12 04:48:10,111 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 04:48:10,168 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULong.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e4afcf]
2021-03-12 04:48:10,247 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:10,248 [main:78] - Generated call from random type = (5671023557872908838.toULong()).toString(-1893650695)
2021-03-12 04:48:10,248 [main:106] - GETTING String from String
2021-03-12 04:48:10,298 [main:113] - Case = [public inline fun kotlin.String.dropLastWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@19450d3d]]
2021-03-12 04:48:10,299 [main:149] - GENERATING call of type public inline fun kotlin.String.dropLastWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@19450d3d]
2021-03-12 04:48:10,379 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 04:48:10,380 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 04:48:10,381 [main:117] - GENERATED CALL = (x).dropLastWhile({a: Char -> true})
2021-03-12 04:48:10,382 [main:113] - Case = [public fun kotlin.String.decapitalize(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@223a6a89]]
2021-03-12 04:48:10,382 [main:149] - GENERATING call of type public fun kotlin.String.decapitalize(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@223a6a89]
2021-03-12 04:48:10,383 [main:117] - GENERATED CALL = (x).decapitalize()
2021-03-12 04:48:10,383 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149], public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1b23eee]]
2021-03-12 04:48:10,383 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149]
2021-03-12 04:48:10,466 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:10,543 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:10,544 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1b23eee]
2021-03-12 04:48:10,620 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:48:10,720 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:48:10,721 [main:117] - GENERATED CALL = (x).subSequence(1296151676, -1217855856).commonSuffixWith("yuppu", false)
2021-03-12 04:48:10,722 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.substring(startIndex: kotlin.Int, endIndex: kotlin.Int = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7bcb44e4]]
2021-03-12 04:48:10,722 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149]
2021-03-12 04:48:10,802 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:10,875 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:10,876 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.substring(startIndex: kotlin.Int, endIndex: kotlin.Int = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7bcb44e4]
2021-03-12 04:48:10,950 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,057 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,059 [main:117] - GENERATED CALL = (x).subSequence(-1835188668, 446999581).substring(2039730163, -638989326)
2021-03-12 04:48:11,060 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@875cfe4], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b64d32c]]
2021-03-12 04:48:11,060 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@875cfe4]
2021-03-12 04:48:11,135 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,136 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b64d32c]
2021-03-12 04:48:11,137 [main:117] - GENERATED CALL = (x).get(-1250528060).titlecase()
2021-03-12 04:48:11,137 [main:113] - Case = [public inline fun kotlin.String.filter(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@17483bb2]]
2021-03-12 04:48:11,137 [main:149] - GENERATING call of type public inline fun kotlin.String.filter(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@17483bb2]
2021-03-12 04:48:11,210 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 04:48:11,211 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 04:48:11,212 [main:117] - GENERATED CALL = (x).filter({a: Char -> false})
2021-03-12 04:48:11,213 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149], public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d610191]]
2021-03-12 04:48:11,213 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@672c8149]
2021-03-12 04:48:11,286 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,360 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,361 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d610191]
2021-03-12 04:48:11,451 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:48:11,528 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:48:11,529 [main:117] - GENERATED CALL = (x).subSequence(-836594657, -63959149).commonPrefixWith("ovlbx", true)
2021-03-12 04:48:11,529 [main:113] - Case = [public fun kotlin.String.takeLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@90a4093]]
2021-03-12 04:48:11,530 [main:149] - GENERATING call of type public fun kotlin.String.takeLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@90a4093]
2021-03-12 04:48:11,602 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,604 [main:117] - GENERATED CALL = (x).takeLast(-1090886434)
2021-03-12 04:48:11,604 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.removeRange(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3af6c942]]
2021-03-12 04:48:11,604 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.removeRange(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3af6c942]
2021-03-12 04:48:11,676 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,761 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:11,762 [main:117] - GENERATED CALL = (x).removeRange(-1406503334, -1161110196)
2021-03-12 04:48:11,762 [main:113] - Case = [public inline fun kotlin.String.filterIndexed(predicate: (index: kotlin.Int, kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@541dd65d]]
2021-03-12 04:48:11,762 [main:149] - GENERATING call of type public inline fun kotlin.String.filterIndexed(predicate: (index: kotlin.Int, kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@541dd65d]
2021-03-12 04:48:11,840 [main:302] - generating value of type = Function2<[@kotlin.ParameterName] Int, Char, Boolean> false depth = 0
2021-03-12 04:48:11,840 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 04:48:11,844 [main:117] - GENERATED CALL = (x).filterIndexed({a: Int, b: Char -> false})
2021-03-12 04:48:11,844 [main:61] - replacement of "OK" of type String is (x).subSequence(-836594657, -63959149).commonPrefixWith("ovlbx", true)
2021-03-12 04:48:11,928 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:11,929 [main:66] - Compilation checking started
2021-03-12 04:48:12,086 [main:49] - Result = false
Text:
const val x = (x).subSequence(-836594657, -63959149).commonPrefixWith("ovlbx", true)

fun box() = (x).replaceFirstChar({a: Char -> 'ݹ'})


2021-03-12 04:48:12,164 [main:119] - TRYING TO REPLACE CONSTANT 'ݹ'
2021-03-12 04:48:12,243 [main:33] - Trying to replace Element(CHARACTER_CONSTANT) on Element(CHARACTER_CONSTANT)
2021-03-12 04:48:12,243 [main:66] - Compilation checking started
2021-03-12 04:48:12,599 [main:41] - AFTER TRY 0 res = const val x = "OK"

fun box() = x


2021-03-12 04:48:12,871 [main:43] - Try №0
2021-03-12 04:48:25,253 [main:48] - Already checked
2021-03-12 04:48:29,135 [main:69] - Trying to insert override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }
2021-03-12 04:48:29,230 [main:66] - Compilation checking started
2021-03-12 04:48:30,320 [main:103] - Trying to change 152 nodes
2021-03-12 04:48:30,321 [main:107] - replacing (0, Int)
2021-03-12 04:48:30,321 [main:50] - replacing 0 Int
2021-03-12 04:48:30,321 [main:54] - Getting value of type Int
2021-03-12 04:48:30,482 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:30,484 [main:58] - GENERATED VALUE OF TYPE Int = -1528470305
2021-03-12 04:48:30,484 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:31,012 [main:67] - randomType = ArrayDeque<UInt>
2021-03-12 04:48:31,202 [main:302] - generating value of type = ArrayDeque<UInt> false depth = 0
2021-03-12 04:48:31,358 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(): ArrayDeque<UInt> = TODO()
2021-03-12 04:48:31,362 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(): ArrayDeque<UInt> = TODO()
2021-03-12 04:48:31,520 [main:95] - GENERATED = ArrayDeque<UInt>()
2021-03-12 04:48:31,763 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3138be6e]
2021-03-12 04:48:31,764 [main:78] - Generated call from random type = (ArrayDeque<UInt>()).size.takeLowestOneBit()
2021-03-12 04:48:31,764 [main:114] - replacement of 0 of type Int is (ArrayDeque<UInt>()).size.takeLowestOneBit()
2021-03-12 04:48:31,931 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:31,932 [main:66] - Compilation checking started
2021-03-12 04:48:32,662 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:32,665 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-12 04:48:32,667 [main:50] - replacing numberOfSuspensions Int
2021-03-12 04:48:32,667 [main:54] - Getting value of type Int
2021-03-12 04:48:32,821 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:32,823 [main:58] - GENERATED VALUE OF TYPE Int = -1910768152
2021-03-12 04:48:32,823 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:32,827 [main:67] - randomType = String
2021-03-12 04:48:32,968 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:33,004 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.indexOfLast(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@417eb9af]
2021-03-12 04:48:33,166 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 04:48:33,168 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 04:48:33,170 [main:78] - Generated call from random type = ("osbeg").indexOfLast({a: Char -> true})
2021-03-12 04:48:33,170 [main:114] - replacement of numberOfSuspensions of type Int is ("osbeg").indexOfLast({a: Char -> true})
2021-03-12 04:48:33,321 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:33,322 [main:66] - Compilation checking started
2021-03-12 04:48:33,777 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + ("osbeg").indexOfLast({a: Char -> true}) + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:33,779 [main:107] - replacing ({
            prope1.prope5 = true
        }, Function0<Unit>)
2021-03-12 04:48:33,780 [main:50] - replacing {
            prope1.prope5 = true
        } Function0<Unit>
2021-03-12 04:48:33,780 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:48:33,918 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:48:33,920 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:48:34,086 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:48:34,089 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:48:34,434 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:48:34,436 [main:95] - GENERATED = check(true)
2021-03-12 04:48:34,436 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { check(true)}
2021-03-12 04:48:34,437 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:34,592 [main:67] - randomType = Long
2021-03-12 04:48:34,721 [main:302] - generating value of type = Long true depth = 0
2021-03-12 04:48:34,773 [main:114] - replacement of {
            prope1.prope5 = true
        } of type Function0<Unit> is { check(true)}
2021-03-12 04:48:34,905 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 04:48:34,906 [main:66] - Compilation checking started
2021-03-12 04:48:35,353 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = { check(true)}
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:35,355 [main:107] - replacing ("", String)
2021-03-12 04:48:35,356 [main:50] - replacing "" String
2021-03-12 04:48:35,356 [main:54] - Getting value of type String
2021-03-12 04:48:35,490 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:35,492 [main:58] - GENERATED VALUE OF TYPE String = "kklvg"
2021-03-12 04:48:35,493 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:35,655 [main:67] - randomType = Char
2021-03-12 04:48:35,788 [main:302] - generating value of type = Char true depth = 0
2021-03-12 04:48:35,820 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3938ca86]
2021-03-12 04:48:35,820 [main:78] - Generated call from random type = ('ꏱ').uppercase()
2021-03-12 04:48:35,821 [main:114] - replacement of "" of type String is ('ꏱ').uppercase()
2021-03-12 04:48:35,952 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:35,952 [main:66] - Compilation checking started
2021-03-12 04:48:36,376 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ('ꏱ').uppercase()

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:36,379 [main:107] - replacing (x, Function1<Throwable, Unit>)
2021-03-12 04:48:36,381 [main:50] - replacing x Function1<Throwable, Unit>
2021-03-12 04:48:36,381 [main:54] - Getting value of type Function1<Throwable, Unit>
2021-03-12 04:48:36,534 [main:302] - generating value of type = Function1<Throwable, Unit> false depth = 0
2021-03-12 04:48:36,536 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:48:36,675 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:48:36,678 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:48:36,956 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:48:36,958 [main:95] - GENERATED = require(false)
2021-03-12 04:48:36,958 [main:58] - GENERATED VALUE OF TYPE Function1<Throwable, Unit> = {a: Throwable -> require(false)}
2021-03-12 04:48:36,958 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:37,677 [main:67] - randomType = MutableMap<MutableMap<Kla1, Kla5?>, Kla1>
2021-03-12 04:48:37,677 [main:114] - replacement of x of type Function1<Throwable, Unit> is {a: Throwable -> require(false)}
2021-03-12 04:48:37,815 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 04:48:37,816 [main:66] - Compilation checking started
2021-03-12 04:48:38,209 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let({a: Throwable -> require(false)})
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:38,211 [main:107] - replacing (prope2, Result<Ty0>)
2021-03-12 04:48:38,212 [main:50] - replacing prope2 Result<Ty0>
2021-03-12 04:48:38,212 [main:54] - Getting value of type Result<Ty0>
2021-03-12 04:48:38,336 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 04:48:38,487 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:48:38,491 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:48:38,766 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:48:38,766 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 04:48:39,051 [main:67] - randomType = Short?
2021-03-12 04:48:39,192 [main:302] - generating value of type = Short true depth = 0
2021-03-12 04:48:39,270 [main:111] - Cant find and generate replacement for prope2 type Result<Ty0>
2021-03-12 04:48:39,270 [main:107] - replacing (method, String)
2021-03-12 04:48:39,272 [main:50] - replacing method String
2021-03-12 04:48:39,272 [main:54] - Getting value of type String
2021-03-12 04:48:39,471 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:39,474 [main:58] - GENERATED VALUE OF TYPE String = "rncrn"
2021-03-12 04:48:39,474 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:39,480 [main:67] - randomType = String
2021-03-12 04:48:39,610 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:39,643 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.toUpperCase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@471053ab]
2021-03-12 04:48:39,645 [main:78] - Generated call from random type = ("syktt").toUpperCase()
2021-03-12 04:48:39,645 [main:114] - replacement of method of type String is ("syktt").toUpperCase()
2021-03-12 04:48:39,769 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:39,770 [main:66] - Compilation checking started
2021-03-12 04:48:40,187 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + ("syktt").toUpperCase() + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:40,190 [main:107] - replacing (prope6, Function0<Unit>)
2021-03-12 04:48:40,190 [main:50] - replacing prope6 Function0<Unit>
2021-03-12 04:48:40,190 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:48:40,317 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:48:40,319 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:48:40,460 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:48:40,465 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:48:40,896 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:48:40,897 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 04:48:40,899 [main:302] - generating value of type = Any false depth = 5
2021-03-12 04:48:40,900 [main:95] - GENERATED = require(false, { "zedmd"})
2021-03-12 04:48:40,900 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(false, { "zedmd"})}
2021-03-12 04:48:40,900 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:40,907 [main:67] - randomType = Kla4
2021-03-12 04:48:41,041 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:48:41,043 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:48:41,054 [main:78] - Generated call from random type = (Kla4()).prope6
2021-03-12 04:48:41,054 [main:114] - replacement of prope6 of type Function0<Unit> is { require(false, { "zedmd"})}
2021-03-12 04:48:41,190 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 04:48:41,190 [main:66] - Compilation checking started
2021-03-12 04:48:41,597 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.{ require(false, { "zedmd"})} = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:41,600 [main:107] - replacing (", got ", String)
2021-03-12 04:48:41,600 [main:50] - replacing ", got " String
2021-03-12 04:48:41,600 [main:54] - Getting value of type String
2021-03-12 04:48:41,733 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:41,736 [main:58] - GENERATED VALUE OF TYPE String = "zbqup"
2021-03-12 04:48:41,736 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:42,015 [main:67] - randomType = ArrayList<Kla1?>
2021-03-12 04:48:42,135 [main:302] - generating value of type = ArrayList<Kla1?> false depth = 0
2021-03-12 04:48:42,270 [main:43] - GENERATING CALL OF fun <T> arrayListOf(): ArrayList<Kla1?> = TODO()
2021-03-12 04:48:42,273 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(): ArrayList<Kla1?> = TODO()
2021-03-12 04:48:42,433 [main:95] - GENERATED = arrayListOf<Kla1?>()
2021-03-12 04:48:42,646 [main:149] - GENERATING call of type protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.ArrayList[DeserializedSimpleFunctionDescriptor@66bf99ab]
2021-03-12 04:48:42,646 [main:149] - GENERATING call of type @kotlin.Deprecated @kotlin.SinceKotlin @kotlin.DeprecatedSinceKotlin public fun <T> kotlin.Array<out T>.contentToString(): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@17b9c3aa]
2021-03-12 04:48:42,647 [main:78] - Generated call from random type = (arrayListOf<Kla1?>()).toArray().contentToString()
2021-03-12 04:48:42,647 [main:114] - replacement of ", got " of type String is "zbqup"
2021-03-12 04:48:42,784 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 04:48:42,789 [main:66] - Compilation checking started
2021-03-12 04:48:43,144 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "zbqup" + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:43,146 [main:107] - replacing ("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4, String)
2021-03-12 04:48:43,146 [main:50] - replacing "Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4 String
2021-03-12 04:48:43,146 [main:54] - Getting value of type String
2021-03-12 04:48:43,267 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:43,269 [main:58] - GENERATED VALUE OF TYPE String = "ozlch"
2021-03-12 04:48:43,269 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:43,273 [main:67] - randomType = UInt
2021-03-12 04:48:43,409 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 04:48:43,456 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@6e3c0bae]
2021-03-12 04:48:43,457 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@b04794c]
2021-03-12 04:48:43,587 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:43,589 [main:78] - Generated call from random type = (8270266.toUInt()).toShort().toString(-1776311123)
2021-03-12 04:48:43,589 [main:114] - replacement of "Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4 of type String is (8270266.toUInt()).toShort().toString(-1776311123)
2021-03-12 04:48:43,706 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:43,707 [main:66] - Compilation checking started
2021-03-12 04:48:44,094 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error((8270266.toUInt()).toShort().toString(-1776311123))
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:44,095 [main:107] - replacing (" has no state-machine ", String)
2021-03-12 04:48:44,096 [main:50] - replacing " has no state-machine " String
2021-03-12 04:48:44,096 [main:54] - Getting value of type String
2021-03-12 04:48:44,217 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:44,218 [main:58] - GENERATED VALUE OF TYPE String = "xqkxt"
2021-03-12 04:48:44,219 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:44,349 [main:67] - randomType = Char
2021-03-12 04:48:44,472 [main:302] - generating value of type = Char true depth = 0
2021-03-12 04:48:44,495 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3938ca86]
2021-03-12 04:48:44,495 [main:78] - Generated call from random type = ('╎').uppercase()
2021-03-12 04:48:44,496 [main:114] - replacement of " has no state-machine " of type String is ('╎').uppercase()
2021-03-12 04:48:44,618 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:44,618 [main:66] - Compilation checking started
2021-03-12 04:48:44,955 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + ('╎').uppercase() +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:44,957 [main:107] - replacing (prope2, Result<Any?>)
2021-03-12 04:48:44,958 [main:50] - replacing prope2 Result<Any?>
2021-03-12 04:48:44,958 [main:54] - Getting value of type Result<Any?>
2021-03-12 04:48:45,072 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 04:48:45,195 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 04:48:45,197 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 04:48:45,462 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 04:48:45,464 [main:302] - generating value of type = Any false depth = 4
2021-03-12 04:48:45,464 [main:95] - GENERATED = runCatching<Any?>({ "xpqbs"})
2021-03-12 04:48:45,464 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "xpqbs"})
2021-03-12 04:48:45,465 [main:61] - GENERATED IS CALL =true
2021-03-12 04:48:45,471 [main:67] - randomType = Kla4
2021-03-12 04:48:45,588 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:48:45,590 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:48:45,599 [main:114] - replacement of prope2 of type Result<Any?> is runCatching<Any?>({ "xpqbs"})
2021-03-12 04:48:45,720 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:48:45,720 [main:66] - Compilation checking started
2021-03-12 04:48:46,071 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
runCatching<Any?>({ "xpqbs"}).getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:46,073 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 04:48:46,073 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 04:48:46,073 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 04:48:46,187 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 04:48:46,192 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 04:48:46,331 [main:67] - randomType = Kla3?
2021-03-12 04:48:46,468 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 04:48:46,470 [main:112] - generating klass Kla3 text = class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}
2021-03-12 04:48:46,476 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 04:48:46,476 [main:107] - replacing (getOrThrow(), Any?)
2021-03-12 04:48:46,476 [main:50] - replacing getOrThrow() Any?
2021-03-12 04:48:46,477 [main:54] - Getting value of type Any?
2021-03-12 04:48:46,604 [main:58] - GENERATED VALUE OF TYPE Any? = null
2021-03-12 04:48:46,604 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:46,732 [main:67] - randomType = Kla1?
2021-03-12 04:48:46,853 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 04:48:46,855 [main:112] - generating klass Kla1 text = class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}
2021-03-12 04:48:46,873 [main:78] - Generated call from random type = (Kla1())?.prope2
2021-03-12 04:48:46,873 [main:114] - replacement of getOrThrow() of type Any? is null
2021-03-12 04:48:47,002 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(NULL)
2021-03-12 04:48:47,003 [main:66] - Compilation checking started
2021-03-12 04:48:47,332 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.null
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:47,334 [main:107] - replacing (prope1.prope6, Function0<Unit>)
2021-03-12 04:48:47,334 [main:50] - replacing prope1.prope6 Function0<Unit>
2021-03-12 04:48:47,335 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:48:47,460 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:48:47,462 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:48:47,582 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:48:47,585 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:48:47,975 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:48:47,976 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 04:48:47,978 [main:302] - generating value of type = Any false depth = 5
2021-03-12 04:48:47,979 [main:95] - GENERATED = require(false, { "iyajh"})
2021-03-12 04:48:47,979 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(false, { "iyajh"})}
2021-03-12 04:48:47,979 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:48,238 [main:67] - randomType = LinkedHashMap<UByte, Kla1>
2021-03-12 04:48:48,386 [main:302] - generating value of type = LinkedHashMap<UByte, Kla1> false depth = 0
2021-03-12 04:48:48,522 [main:43] - GENERATING CALL OF fun <K, V> LinkedHashMap(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): LinkedHashMap<UByte, Kla1> = TODO()
2021-03-12 04:48:48,525 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> LinkedHashMap(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): LinkedHashMap<UByte, Kla1> = TODO()
2021-03-12 04:48:48,915 [main:302] - generating value of type = Int true depth = 3
2021-03-12 04:48:48,917 [main:302] - generating value of type = Float true depth = 3
2021-03-12 04:48:48,919 [main:95] - GENERATED = LinkedHashMap<UByte, Kla1>(167169138, 0.34810996f)
2021-03-12 04:48:49,097 [main:114] - replacement of prope1.prope6 of type Function0<Unit> is { require(false, { "iyajh"})}
2021-03-12 04:48:49,241 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 04:48:49,242 [main:66] - Compilation checking started
2021-03-12 04:48:49,630 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
{ require(false, { "iyajh"})} = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:49,633 [main:107] - replacing (prope5, Boolean)
2021-03-12 04:48:49,634 [main:50] - replacing prope5 Boolean
2021-03-12 04:48:49,634 [main:54] - Getting value of type Boolean
2021-03-12 04:48:49,779 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:48:49,781 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 04:48:49,782 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:50,046 [main:67] - randomType = Array<UInt>
2021-03-12 04:48:50,166 [main:302] - generating value of type = Array<UInt> false depth = 0
2021-03-12 04:48:50,296 [main:43] - GENERATING CALL OF fun <T> arrayOf(elements: UInt): Array<UInt> = TODO()
2021-03-12 04:48:50,299 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayOf(elements: UInt): Array<UInt> = TODO()
2021-03-12 04:48:50,423 [main:302] - generating value of type = UInt true depth = 3
2021-03-12 04:48:50,425 [main:95] - GENERATED = arrayOf<UInt>(1639519033.toUInt())
2021-03-12 04:48:50,444 [main:149] - GENERATING call of type public operator fun <@kotlin.internal.OnlyInputTypes T> kotlin.Array<out T>.contains(element: T): kotlin.Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@48efa366]
2021-03-12 04:48:50,579 [main:302] - generating value of type = T false depth = 0
2021-03-12 04:48:50,835 [main:43] - GENERATING CALL OF fun <T> minOf(a: UByte, b: UByte, comparator: kotlin.Comparator<UByte>): T = TODO()
2021-03-12 04:48:50,838 [main:61] - WITHOUT TYPE PARAMS = fun <T> minOf(a: UByte, b: UByte, comparator: kotlin.Comparator<UByte>): T = TODO()
2021-03-12 04:48:51,083 [main:302] - generating value of type = UByte true depth = 3
2021-03-12 04:48:51,085 [main:302] - generating value of type = UByte true depth = 3
2021-03-12 04:48:51,086 [main:302] - generating value of type = Comparator<UByte> false depth = 3
2021-03-12 04:48:51,205 [main:43] - GENERATING CALL OF fun <T> compareBy(selector: (UByte)->kotlin.Comparable<*>?): Comparator<UByte> = TODO()
2021-03-12 04:48:51,208 [main:61] - WITHOUT TYPE PARAMS = fun <T> compareBy(selector: (UByte)->kotlin.Comparable<*>?): Comparator<UByte> = TODO()
2021-03-12 04:48:51,455 [main:302] - generating value of type = Function1<UByte, Comparable<*>?> false depth = 6
2021-03-12 04:48:51,456 [main:302] - generating value of type = Comparable<*> false depth = 7
2021-03-12 04:48:51,631 [main:43] - GENERATING CALL OF fun KotlinVersion(major: kotlin.Int, minor: kotlin.Int, patch: kotlin.Int): Comparable<*> = TODO()
2021-03-12 04:48:51,636 [main:61] - WITHOUT TYPE PARAMS = fun KotlinVersion(major: kotlin.Int, minor: kotlin.Int, patch: kotlin.Int): Comparable<*> = TODO()
2021-03-12 04:48:52,169 [main:302] - generating value of type = Int true depth = 10
2021-03-12 04:48:52,170 [main:302] - generating value of type = Int true depth = 10
2021-03-12 04:48:52,172 [main:302] - generating value of type = Int true depth = 10
2021-03-12 04:48:52,174 [main:95] - GENERATED = KotlinVersion(812952003, 2060671958, -1165185895)
2021-03-12 04:48:52,174 [main:95] - GENERATED = compareBy<UByte>({a: UByte -> KotlinVersion(812952003, 2060671958, -1165185895)})
2021-03-12 04:48:52,174 [main:95] - GENERATED = minOf<UByte>(24.toUByte(), 87.toUByte(), compareBy<UByte>({a: UByte -> KotlinVersion(812952003, 2060671958, -1165185895)}))
2021-03-12 04:48:52,175 [main:78] - Generated call from random type = (arrayOf<UInt>(1639519033.toUInt())).contains(minOf<UByte>(24.toUByte(), 87.toUByte(), compareBy<UByte>({a: UByte -> KotlinVersion(812952003, 2060671958, -1165185895)})))
2021-03-12 04:48:52,175 [main:114] - replacement of prope5 of type Boolean is (arrayOf<UInt>(1639519033.toUInt())).contains(minOf<UByte>(24.toUByte(), 87.toUByte(), compareBy<UByte>({a: UByte -> KotlinVersion(812952003, 2060671958, -1165185895)})))
2021-03-12 04:48:52,283 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:52,283 [main:66] - Compilation checking started
2021-03-12 04:48:52,733 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        (arrayOf<UInt>(1639519033.toUInt())).contains(minOf<UByte>(24.toUByte(), 87.toUByte(), compareBy<UByte>({a: UByte -> KotlinVersion(812952003, 2060671958, -1165185895)}))) = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:52,735 [main:107] - replacing (prope5, Boolean)
2021-03-12 04:48:52,735 [main:50] - replacing prope5 Boolean
2021-03-12 04:48:52,735 [main:54] - Getting value of type Boolean
2021-03-12 04:48:52,878 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:48:52,880 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 04:48:52,880 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:53,163 [main:67] - randomType = ULong?
2021-03-12 04:48:53,294 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 04:48:53,347 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@5160587e]
2021-03-12 04:48:53,348 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@289d9ec0]
2021-03-12 04:48:53,348 [main:78] - Generated call from random type = (1099318170910570721.toULong())?.toDouble().isInfinite()
2021-03-12 04:48:53,348 [main:114] - replacement of prope5 of type Boolean is (1099318170910570721.toULong())?.toDouble().isInfinite()
2021-03-12 04:48:53,463 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:53,463 [main:66] - Compilation checking started
2021-03-12 04:48:53,845 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.(1099318170910570721.toULong())?.toDouble().isInfinite() = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:53,846 [main:107] - replacing ("tail-call optimization hit: method ", String)
2021-03-12 04:48:53,847 [main:50] - replacing "tail-call optimization hit: method " String
2021-03-12 04:48:53,847 [main:54] - Getting value of type String
2021-03-12 04:48:53,967 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:53,969 [main:58] - GENERATED VALUE OF TYPE String = "ssydr"
2021-03-12 04:48:53,969 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:53,975 [main:67] - randomType = Kla1
2021-03-12 04:48:54,093 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 04:48:54,094 [main:112] - generating klass Kla1 text = class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}
2021-03-12 04:48:54,113 [main:149] - GENERATING call of type public fun kotlin.Any?.toString(): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@751fd568]
2021-03-12 04:48:54,113 [main:78] - Generated call from random type = (Kla1()).prope2?.toString()!!
2021-03-12 04:48:54,113 [main:114] - replacement of "tail-call optimization hit: method " of type String is "ssydr"
2021-03-12 04:48:54,223 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 04:48:54,224 [main:66] - Compilation checking started
2021-03-12 04:48:54,562 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("ssydr" + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:54,565 [main:107] - replacing ("tail-call optimization miss: method at " + it, String)
2021-03-12 04:48:54,566 [main:50] - replacing "tail-call optimization miss: method at " + it String
2021-03-12 04:48:54,566 [main:54] - Getting value of type String
2021-03-12 04:48:54,699 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:54,701 [main:58] - GENERATED VALUE OF TYPE String = "otuym"
2021-03-12 04:48:54,701 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:54,708 [main:67] - randomType = Kla4
2021-03-12 04:48:54,820 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:48:54,822 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:48:54,830 [main:114] - replacement of "tail-call optimization miss: method at " + it of type String is "otuym"
2021-03-12 04:48:54,945 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:48:54,945 [main:66] - Compilation checking started
2021-03-12 04:48:55,299 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("otuym" + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:55,301 [main:107] - replacing (prope2.getOrThrow(), Ty0)
2021-03-12 04:48:55,302 [main:50] - replacing prope2.getOrThrow() Ty0
2021-03-12 04:48:55,302 [main:54] - Getting value of type Ty0
2021-03-12 04:48:55,418 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 04:48:55,423 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 04:48:55,427 [main:67] - randomType = UInt
2021-03-12 04:48:55,537 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 04:48:55,568 [main:111] - Cant find and generate replacement for prope2.getOrThrow() type Ty0
2021-03-12 04:48:55,568 [main:107] - replacing (", got ", String)
2021-03-12 04:48:55,569 [main:50] - replacing ", got " String
2021-03-12 04:48:55,569 [main:54] - Getting value of type String
2021-03-12 04:48:55,679 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:55,681 [main:58] - GENERATED VALUE OF TYPE String = "dytjr"
2021-03-12 04:48:55,681 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:55,684 [main:67] - randomType = Int
2021-03-12 04:48:55,796 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:55,833 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@212cecfa]
2021-03-12 04:48:55,833 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1a17b4f7]
2021-03-12 04:48:55,952 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:48:55,954 [main:78] - Generated call from random type = (703145963).toByte().toString(-331040715)
2021-03-12 04:48:55,954 [main:114] - replacement of ", got " of type String is (703145963).toByte().toString(-331040715)
2021-03-12 04:48:56,076 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:48:56,076 [main:66] - Compilation checking started
2021-03-12 04:48:56,422 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + (703145963).toByte().toString(-331040715) + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:56,425 [main:107] - replacing ("O", String)
2021-03-12 04:48:56,425 [main:50] - replacing "O" String
2021-03-12 04:48:56,425 [main:54] - Getting value of type String
2021-03-12 04:48:56,552 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:48:56,554 [main:58] - GENERATED VALUE OF TYPE String = "okwat"
2021-03-12 04:48:56,554 [main:61] - GENERATED IS CALL =false
2021-03-12 04:48:56,826 [main:67] - randomType = Set<ULong>
2021-03-12 04:48:56,827 [main:114] - replacement of "O" of type String is "okwat"
2021-03-12 04:48:56,938 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 04:48:56,938 [main:66] - Compilation checking started
2021-03-12 04:48:57,274 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("okwat") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:48:57,276 [main:107] - replacing (c, Continuation<Unit>)
2021-03-12 04:48:57,276 [main:50] - replacing c Continuation<Unit>
2021-03-12 04:48:57,276 [main:54] - Getting value of type Continuation<Unit>
2021-03-12 04:48:57,394 [main:302] - generating value of type = Continuation<Unit> false depth = 0
2021-03-12 04:48:57,524 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Unit>)->kotlin.Unit): Contuation<Unit> = TODO()
2021-03-12 04:48:57,528 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Unit>)->kotlin.Unit): Contuation<Unit> = TODO()
2021-03-12 04:48:57,937 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 04:48:58,051 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:48:58,053 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:48:58,332 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 04:48:58,482 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:48:58,484 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:48:58,858 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 9
2021-03-12 04:48:58,979 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:48:58,982 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:48:59,432 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 12
2021-03-12 04:48:59,562 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:48:59,565 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:48:59,943 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:48:59,943 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:48:59,943 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:48:59,943 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:48:59,943 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Unit>)->kotlin.Unit): Contuation<Unit> = TODO()
2021-03-12 04:48:59,943 [main:58] - GENERATED VALUE OF TYPE Continuation<Unit> = 
2021-03-12 04:49:00,071 [main:67] - randomType = Float
2021-03-12 04:49:00,204 [main:302] - generating value of type = Float true depth = 0
2021-03-12 04:49:00,267 [main:111] - Cant find and generate replacement for c type Continuation<Unit>
2021-03-12 04:49:00,267 [main:107] - replacing (prope2, Result<Any?>)
2021-03-12 04:49:00,268 [main:50] - replacing prope2 Result<Any?>
2021-03-12 04:49:00,268 [main:54] - Getting value of type Result<Any?>
2021-03-12 04:49:00,387 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 04:49:00,515 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 04:49:00,517 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 04:49:00,755 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 04:49:00,757 [main:302] - generating value of type = Any false depth = 4
2021-03-12 04:49:00,757 [main:95] - GENERATED = runCatching<Any?>({ "iyjgc"})
2021-03-12 04:49:00,757 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "iyjgc"})
2021-03-12 04:49:00,757 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:01,872 [main:67] - randomType = Function2<LinkedHashMap<UInt, Function2<ArrayList<Kla3>, Kla1, UInt>>, Kla5, LinkedHashSet<Kla5>>
2021-03-12 04:49:01,872 [main:114] - replacement of prope2 of type Result<Any?> is runCatching<Any?>({ "iyjgc"})
2021-03-12 04:49:02,035 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:02,036 [main:66] - Compilation checking started
2021-03-12 04:49:02,389 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = runCatching<Any?>({ "iyjgc"}).getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:02,390 [main:107] - replacing (i, Int)
2021-03-12 04:49:02,391 [main:50] - replacing i Int
2021-03-12 04:49:02,391 [main:54] - Getting value of type Int
2021-03-12 04:49:02,504 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:02,505 [main:58] - GENERATED VALUE OF TYPE Int = -1217473886
2021-03-12 04:49:02,505 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:02,636 [main:67] - randomType = List<UInt>
2021-03-12 04:49:02,636 [main:114] - replacement of i of type Int is -1217473886
2021-03-12 04:49:02,751 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 04:49:02,751 [main:66] - Compilation checking started
2021-03-12 04:49:03,096 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + -1217473886 + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:03,098 [main:107] - replacing (prope2, Result<Ty0>)
2021-03-12 04:49:03,099 [main:50] - replacing prope2 Result<Ty0>
2021-03-12 04:49:03,099 [main:54] - Getting value of type Result<Ty0>
2021-03-12 04:49:03,206 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 04:49:03,318 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:03,321 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:03,562 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:03,564 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 04:49:03,684 [main:67] - randomType = ULong
2021-03-12 04:49:03,792 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 04:49:03,823 [main:111] - Cant find and generate replacement for prope2 type Result<Ty0>
2021-03-12 04:49:03,823 [main:107] - replacing (prope2.exceptionOrNull(), Throwable?)
2021-03-12 04:49:03,824 [main:50] - replacing prope2.exceptionOrNull() Throwable?
2021-03-12 04:49:03,824 [main:54] - Getting value of type Throwable?
2021-03-12 04:49:03,961 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 04:49:03,968 [main:58] - GENERATED VALUE OF TYPE Throwable? = AssertionError()
2021-03-12 04:49:03,968 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:03,975 [main:67] - randomType = Kla4
2021-03-12 04:49:04,142 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:49:04,144 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:49:04,154 [main:114] - replacement of prope2.exceptionOrNull() of type Throwable? is AssertionError()
2021-03-12 04:49:04,266 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:04,267 [main:66] - Compilation checking started
2021-03-12 04:49:04,626 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(AssertionError()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:04,628 [main:107] - replacing (fu0("O") + fu0("K"), String)
2021-03-12 04:49:04,628 [main:50] - replacing fu0("O") + fu0("K") String
2021-03-12 04:49:04,628 [main:54] - Getting value of type String
2021-03-12 04:49:04,765 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:04,767 [main:58] - GENERATED VALUE OF TYPE String = "sylyf"
2021-03-12 04:49:04,767 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:04,894 [main:67] - randomType = UShort
2021-03-12 04:49:05,018 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 04:49:05,060 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@33092841]
2021-03-12 04:49:05,060 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@783f30e7]
2021-03-12 04:49:05,172 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:05,174 [main:78] - Generated call from random type = (24314.toUShort()).toLong().toString(1270528953)
2021-03-12 04:49:05,174 [main:114] - replacement of fu0("O") + fu0("K") of type String is (24314.toUShort()).toLong().toString(1270528953)
2021-03-12 04:49:05,281 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:49:05,281 [main:66] - Compilation checking started
2021-03-12 04:49:05,602 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = (24314.toUShort()).toLong().toString(1270528953)

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:05,604 [main:107] - replacing (prope2, Result<Ty0>)
2021-03-12 04:49:05,604 [main:50] - replacing prope2 Result<Ty0>
2021-03-12 04:49:05,604 [main:54] - Getting value of type Result<Ty0>
2021-03-12 04:49:05,714 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 04:49:05,835 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:05,838 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:06,076 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:06,076 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 04:49:06,080 [main:67] - randomType = Int
2021-03-12 04:49:06,189 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:06,231 [main:111] - Cant find and generate replacement for prope2 type Result<Ty0>
2021-03-12 04:49:06,231 [main:107] - replacing (fu0("O") + fu0("K"), String)
2021-03-12 04:49:06,231 [main:50] - replacing fu0("O") + fu0("K") String
2021-03-12 04:49:06,231 [main:54] - Getting value of type String
2021-03-12 04:49:06,341 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:06,343 [main:58] - GENERATED VALUE OF TYPE String = "fewxg"
2021-03-12 04:49:06,343 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:06,860 [main:67] - randomType = Pair<Long, Kla2<Double>>
2021-03-12 04:49:06,970 [main:302] - generating value of type = Pair<Long, Kla2<Double>> false depth = 0
2021-03-12 04:49:07,088 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Long, second: Kla2<Double>): Pair<Long, Kla2<Double>> = TODO()
2021-03-12 04:49:07,091 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Long, second: Kla2<Double>): Pair<Long, Kla2<Double>> = TODO()
2021-03-12 04:49:07,205 [main:302] - generating value of type = Long true depth = 3
2021-03-12 04:49:07,206 [main:302] - generating value of type = Kla2<Double> false depth = 3
2021-03-12 04:49:07,208 [main:112] - generating klass Kla2 text = abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 04:49:07,730 [main:302] - generating value of type = Kla5 false depth = 5
2021-03-12 04:49:07,732 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:07,733 [main:95] - GENERATED = Pair<Long, Kla2<Double>>(-8251342765856581199, Kla5)
2021-03-12 04:49:07,748 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@783f30e7]
2021-03-12 04:49:07,857 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:07,859 [main:78] - Generated call from random type = (Pair<Long, Kla2<Double>>(-8251342765856581199, Kla5)).first.toString(-1407265064)
2021-03-12 04:49:07,859 [main:114] - replacement of fu0("O") + fu0("K") of type String is "fewxg"
2021-03-12 04:49:07,968 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:07,968 [main:66] - Compilation checking started
2021-03-12 04:49:08,301 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = "fewxg"

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:08,303 [main:107] - replacing ("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"), String)
2021-03-12 04:49:08,303 [main:50] - replacing "tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n") String
2021-03-12 04:49:08,303 [main:54] - Getting value of type String
2021-03-12 04:49:08,414 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:08,416 [main:58] - GENERATED VALUE OF TYPE String = "uiexa"
2021-03-12 04:49:08,416 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:08,662 [main:67] - randomType = Kla2<Short>
2021-03-12 04:49:08,770 [main:302] - generating value of type = Kla2<Short> false depth = 0
2021-03-12 04:49:08,772 [main:112] - generating klass Kla2 text = abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 04:49:09,146 [main:302] - generating value of type = Kla5 false depth = 2
2021-03-12 04:49:09,148 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:09,179 [main:114] - replacement of "tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n") of type String is "uiexa"
2021-03-12 04:49:09,294 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:09,295 [main:66] - Compilation checking started
2021-03-12 04:49:09,598 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("uiexa")
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:09,599 [main:107] - replacing (c, SuspendFunction0<Unit>)
2021-03-12 04:49:09,600 [main:50] - replacing c SuspendFunction0<Unit>
2021-03-12 04:49:09,600 [main:54] - Getting value of type SuspendFunction0<Unit>
2021-03-12 04:49:09,709 [main:302] - generating value of type = SuspendFunction0<Unit> false depth = 0
2021-03-12 04:49:09,711 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:49:09,824 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:49:09,826 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:49:10,076 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:49:10,078 [main:95] - GENERATED = check(true)
2021-03-12 04:49:10,078 [main:58] - GENERATED VALUE OF TYPE SuspendFunction0<Unit> = { check(true)}
2021-03-12 04:49:10,078 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:10,321 [main:67] - randomType = Kla2<Byte>
2021-03-12 04:49:10,426 [main:302] - generating value of type = Kla2<Byte> false depth = 0
2021-03-12 04:49:10,427 [main:112] - generating klass Kla2 text = abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 04:49:10,773 [main:302] - generating value of type = Kla5 false depth = 2
2021-03-12 04:49:10,774 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:10,788 [main:114] - replacement of c of type SuspendFunction0<Unit> is { check(true)}
2021-03-12 04:49:10,902 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 04:49:10,902 [main:66] - Compilation checking started
2021-03-12 04:49:11,250 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
{ check(true)}.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:11,251 [main:107] - replacing (prope4, Int)
2021-03-12 04:49:11,252 [main:50] - replacing prope4 Int
2021-03-12 04:49:11,252 [main:54] - Getting value of type Int
2021-03-12 04:49:11,371 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:11,373 [main:58] - GENERATED VALUE OF TYPE Int = 2040492464
2021-03-12 04:49:11,373 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:11,510 [main:67] - randomType = Function1<Kla0, Int>
2021-03-12 04:49:11,510 [main:114] - replacement of prope4 of type Int is 2040492464
2021-03-12 04:49:11,618 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 04:49:11,619 [main:66] - Compilation checking started
2021-03-12 04:49:11,954 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (2040492464 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:11,956 [main:107] - replacing (prope2.exceptionOrNull()?.let(x), Unit?)
2021-03-12 04:49:11,956 [main:50] - replacing prope2.exceptionOrNull()?.let(x) Unit?
2021-03-12 04:49:11,956 [main:54] - Getting value of type Unit?
2021-03-12 04:49:12,065 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 04:49:12,177 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:49:12,180 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:49:12,539 [main:302] - generating value of type = Boolean true depth = 3
2021-03-12 04:49:12,541 [main:302] - generating value of type = Function0<Any> false depth = 3
2021-03-12 04:49:12,542 [main:302] - generating value of type = Any false depth = 4
2021-03-12 04:49:12,542 [main:95] - GENERATED = check(true, { "slcya"})
2021-03-12 04:49:12,543 [main:58] - GENERATED VALUE OF TYPE Unit? = check(true, { "slcya"})
2021-03-12 04:49:12,543 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:12,664 [main:67] - randomType = UByte
2021-03-12 04:49:12,783 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 04:49:12,828 [main:114] - replacement of prope2.exceptionOrNull()?.let(x) of type Unit? is check(true, { "slcya"})
2021-03-12 04:49:12,996 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:12,996 [main:66] - Compilation checking started
2021-03-12 04:49:13,383 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
check(true, { "slcya"})
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:13,385 [main:107] - replacing ("tail-call optimization miss: method at " + it, String)
2021-03-12 04:49:13,385 [main:50] - replacing "tail-call optimization miss: method at " + it String
2021-03-12 04:49:13,385 [main:54] - Getting value of type String
2021-03-12 04:49:13,495 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:13,497 [main:58] - GENERATED VALUE OF TYPE String = "czjbw"
2021-03-12 04:49:13,497 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:13,629 [main:67] - randomType = ArrayDeque<Kla3>
2021-03-12 04:49:13,733 [main:302] - generating value of type = ArrayDeque<Kla3> false depth = 0
2021-03-12 04:49:13,843 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(): ArrayDeque<Kla3> = TODO()
2021-03-12 04:49:13,846 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(): ArrayDeque<Kla3> = TODO()
2021-03-12 04:49:13,972 [main:95] - GENERATED = ArrayDeque<Kla3>()
2021-03-12 04:49:14,166 [main:149] - GENERATING call of type public fun <T> kotlin.collections.Iterable<T>.joinToString(separator: kotlin.CharSequence = ..., prefix: kotlin.CharSequence = ..., postfix: kotlin.CharSequence = ..., limit: kotlin.Int = ..., truncated: kotlin.CharSequence = ..., transform: ((T) -> kotlin.CharSequence)? = ...): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@ca31114]
2021-03-12 04:49:14,284 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:14,404 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:14,520 [main:43] - GENERATING CALL OF fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 04:49:14,523 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 04:49:14,754 [main:302] - generating value of type = Int true depth = 3
2021-03-12 04:49:14,755 [main:95] - GENERATED = StringBuilder(518328578)
2021-03-12 04:49:14,882 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:14,998 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:15,109 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:15,220 [main:302] - generating value of type = Function1<T, CharSequence> false depth = 0
2021-03-12 04:49:15,221 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-12 04:49:15,226 [main:78] - Generated call from random type = (ArrayDeque<Kla3>()).joinToString("pvouw", StringBuilder(518328578), "rhkin", -1071782716, "hsfji", {a: T -> "cvgbu"})
2021-03-12 04:49:15,226 [main:114] - replacement of "tail-call optimization miss: method at " + it of type String is (ArrayDeque<Kla3>()).joinToString("pvouw", StringBuilder(518328578), "rhkin", -1071782716, "hsfji", {a: T -> "cvgbu"})
2021-03-12 04:49:15,331 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:49:15,331 [main:66] - Compilation checking started
2021-03-12 04:49:15,665 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error((ArrayDeque<Kla3>()).joinToString("pvouw", StringBuilder(518328578), "rhkin", -1071782716, "hsfji", {a: T -> "cvgbu"}) + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:15,667 [main:107] - replacing (isSuccess, Boolean)
2021-03-12 04:49:15,667 [main:50] - replacing isSuccess Boolean
2021-03-12 04:49:15,667 [main:54] - Getting value of type Boolean
2021-03-12 04:49:15,798 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:49:15,800 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 04:49:15,801 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:16,054 [main:67] - randomType = Sequence<UInt?>
2021-03-12 04:49:16,055 [main:114] - replacement of isSuccess of type Boolean is false
2021-03-12 04:49:16,163 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 04:49:16,164 [main:107] - replacing (prope7 != null, Boolean)
2021-03-12 04:49:16,165 [main:50] - replacing prope7 != null Boolean
2021-03-12 04:49:16,165 [main:54] - Getting value of type Boolean
2021-03-12 04:49:16,274 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:49:16,276 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 04:49:16,276 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:16,640 [main:67] - randomType = Triple<Kla1, UByte, Byte>
2021-03-12 04:49:16,745 [main:302] - generating value of type = Triple<Kla1, UByte, Byte> false depth = 0
2021-03-12 04:49:16,877 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Kla1, second: UByte, third: Byte): Triple<Kla1, UByte, Byte> = TODO()
2021-03-12 04:49:16,880 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Kla1, second: UByte, third: Byte): Triple<Kla1, UByte, Byte> = TODO()
2021-03-12 04:49:17,004 [main:302] - generating value of type = Kla1 false depth = 3
2021-03-12 04:49:17,006 [main:112] - generating klass Kla1 text = class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}
2021-03-12 04:49:17,006 [main:302] - generating value of type = UByte true depth = 3
2021-03-12 04:49:17,008 [main:302] - generating value of type = Byte true depth = 3
2021-03-12 04:49:17,010 [main:95] - GENERATED = Triple<Kla1, UByte, Byte>(Kla1(), 68.toUByte(), 85)
2021-03-12 04:49:17,023 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Triple[DeserializedSimpleFunctionDescriptor@495bf7f8]
2021-03-12 04:49:17,128 [main:302] - generating value of type = Any false depth = 0
2021-03-12 04:49:17,129 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@3eeded88]
2021-03-12 04:49:17,240 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:49:17,243 [main:78] - Generated call from random type = (Triple<Kla1, UByte, Byte>(Kla1(), 68.toUByte(), 85)).equals("adhwa").xor(false)
2021-03-12 04:49:17,243 [main:114] - replacement of prope7 != null of type Boolean is (Triple<Kla1, UByte, Byte>(Kla1(), 68.toUByte(), 85)).equals("adhwa").xor(false)
2021-03-12 04:49:17,356 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:49:17,356 [main:66] - Compilation checking started
2021-03-12 04:49:17,703 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while ((Triple<Kla1, UByte, Byte>(Kla1(), 68.toUByte(), 85)).equals("adhwa").xor(false)) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:17,704 [main:107] - replacing ("\n", String)
2021-03-12 04:49:17,704 [main:50] - replacing "\n" String
2021-03-12 04:49:17,704 [main:54] - Getting value of type String
2021-03-12 04:49:17,826 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:17,828 [main:58] - GENERATED VALUE OF TYPE String = "jxjqk"
2021-03-12 04:49:17,828 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:18,331 [main:67] - randomType = Map<List<Kla2<Boolean>>, Byte>
2021-03-12 04:49:18,331 [main:114] - replacement of "\n" of type String is "jxjqk"
2021-03-12 04:49:18,436 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 04:49:18,436 [main:66] - Compilation checking started
2021-03-12 04:49:18,749 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "jxjqk")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:18,750 [main:107] - replacing (getOrThrow(), Ty0)
2021-03-12 04:49:18,750 [main:50] - replacing getOrThrow() Ty0
2021-03-12 04:49:18,750 [main:54] - Getting value of type Ty0
2021-03-12 04:49:18,864 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 04:49:18,868 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 04:49:18,875 [main:67] - randomType = Kla4
2021-03-12 04:49:18,991 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:49:18,993 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:49:19,000 [main:111] - Cant find and generate replacement for getOrThrow() type Ty0
2021-03-12 04:49:19,000 [main:107] - replacing (i, Int)
2021-03-12 04:49:19,000 [main:50] - replacing i Int
2021-03-12 04:49:19,000 [main:54] - Getting value of type Int
2021-03-12 04:49:19,109 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:19,111 [main:58] - GENERATED VALUE OF TYPE Int = -906810218
2021-03-12 04:49:19,111 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:19,229 [main:67] - randomType = ULong
2021-03-12 04:49:19,335 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 04:49:19,365 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@5a53b234]
2021-03-12 04:49:19,473 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 04:49:19,475 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4dcea0e0]
2021-03-12 04:49:19,584 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 04:49:19,586 [main:78] - Generated call from random type = (1156880274967558426.toULong()).compareTo(99.toUByte()).rem(-21)
2021-03-12 04:49:19,586 [main:114] - replacement of i of type Int is -906810218
2021-03-12 04:49:19,691 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 04:49:19,691 [main:66] - Compilation checking started
2021-03-12 04:49:20,009 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != -906810218) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:20,010 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 04:49:20,010 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 04:49:20,010 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 04:49:20,120 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 04:49:20,124 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 04:49:20,251 [main:67] - randomType = ArrayList<UInt>
2021-03-12 04:49:20,362 [main:302] - generating value of type = ArrayList<UInt> false depth = 0
2021-03-12 04:49:20,473 [main:43] - GENERATING CALL OF fun <T> arrayListOf(): ArrayList<UInt> = TODO()
2021-03-12 04:49:20,475 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(): ArrayList<UInt> = TODO()
2021-03-12 04:49:20,589 [main:95] - GENERATED = arrayListOf<UInt>()
2021-03-12 04:49:20,732 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 04:49:20,732 [main:107] - replacing ("\n", String)
2021-03-12 04:49:20,732 [main:50] - replacing "\n" String
2021-03-12 04:49:20,732 [main:54] - Getting value of type String
2021-03-12 04:49:20,836 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:20,838 [main:58] - GENERATED VALUE OF TYPE String = "oudub"
2021-03-12 04:49:20,838 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:21,331 [main:67] - randomType = ArrayList<Array<Char>>?
2021-03-12 04:49:21,441 [main:302] - generating value of type = ArrayList<Array<Char>> false depth = 0
2021-03-12 04:49:21,551 [main:43] - GENERATING CALL OF fun <T> arrayListOf(elements: Array<Char>): ArrayList<Array<Char>> = TODO()
2021-03-12 04:49:21,554 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(elements: Array<Char>): ArrayList<Array<Char>> = TODO()
2021-03-12 04:49:21,661 [main:302] - generating value of type = Array<Char> false depth = 3
2021-03-12 04:49:21,769 [main:43] - GENERATING CALL OF fun <T> arrayOf(elements: Char): Array<Char> = TODO()
2021-03-12 04:49:21,772 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayOf(elements: Char): Array<Char> = TODO()
2021-03-12 04:49:21,881 [main:302] - generating value of type = Char true depth = 6
2021-03-12 04:49:21,883 [main:95] - GENERATED = arrayOf<Char>('቉')
2021-03-12 04:49:21,883 [main:95] - GENERATED = arrayListOf<Array<Char>>(arrayOf<Char>('቉'))
2021-03-12 04:49:22,048 [main:149] - GENERATING call of type public fun <T> kotlin.collections.Iterable<T>.joinToString(separator: kotlin.CharSequence = ..., prefix: kotlin.CharSequence = ..., postfix: kotlin.CharSequence = ..., limit: kotlin.Int = ..., truncated: kotlin.CharSequence = ..., transform: ((T) -> kotlin.CharSequence)? = ...): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@ca31114]
2021-03-12 04:49:22,152 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:22,261 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:22,369 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:22,479 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:22,584 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 04:49:22,692 [main:43] - GENERATING CALL OF fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-12 04:49:22,694 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-12 04:49:22,918 [main:302] - generating value of type = CharSequence false depth = 3
2021-03-12 04:49:22,923 [main:95] - GENERATED = StringBuilder("bueum")
2021-03-12 04:49:23,051 [main:302] - generating value of type = Function1<T, CharSequence> false depth = 0
2021-03-12 04:49:23,053 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-12 04:49:23,059 [main:78] - Generated call from random type = (arrayListOf<Array<Char>>(arrayOf<Char>('቉')))?.joinToString("fiykd", "lnofz", "dvtoi", 1420371083, StringBuilder("bueum"), {a: T -> "icbjm"})
2021-03-12 04:49:23,059 [main:114] - replacement of "\n" of type String is "oudub"
2021-03-12 04:49:23,182 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 04:49:23,182 [main:66] - Compilation checking started
2021-03-12 04:49:23,498 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "oudub")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:23,501 [main:107] - replacing (prope2, Result<Ty0>)
2021-03-12 04:49:23,501 [main:50] - replacing prope2 Result<Ty0>
2021-03-12 04:49:23,501 [main:54] - Getting value of type Result<Ty0>
2021-03-12 04:49:23,623 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 04:49:23,743 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:23,746 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:23,982 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:23,982 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 04:49:24,348 [main:67] - randomType = List<Sequence<ULong>>
2021-03-12 04:49:24,348 [main:111] - Cant find and generate replacement for prope2 type Result<Ty0>
2021-03-12 04:49:24,348 [main:107] - replacing (Kla0, Kla6)
2021-03-12 04:49:24,348 [main:50] - replacing Kla0 Kla6
2021-03-12 04:49:24,348 [main:54] - Getting value of type Kla6
2021-03-12 04:49:24,454 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 04:49:24,456 [main:112] - generating klass Kla6 text = companion object Kla6 : Kla0()
2021-03-12 04:49:24,456 [main:58] - GENERATED VALUE OF TYPE Kla6 = 
2021-03-12 04:49:24,704 [main:67] - randomType = Kla2<Kla2<UInt>>
2021-03-12 04:49:24,808 [main:302] - generating value of type = Kla2<Kla2<UInt>> false depth = 0
2021-03-12 04:49:24,810 [main:112] - generating klass Kla2 text = abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 04:49:25,211 [main:302] - generating value of type = Kla5 false depth = 2
2021-03-12 04:49:25,213 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:25,228 [main:111] - Cant find and generate replacement for Kla0 type Kla6
2021-03-12 04:49:25,228 [main:107] - replacing (prope2.getOrThrow(), Ty0)
2021-03-12 04:49:25,228 [main:50] - replacing prope2.getOrThrow() Ty0
2021-03-12 04:49:25,228 [main:54] - Getting value of type Ty0
2021-03-12 04:49:25,332 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 04:49:25,338 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 04:49:25,477 [main:67] - randomType = Kla0?
2021-03-12 04:49:25,581 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 04:49:25,582 [main:112] - generating klass Kla0 text = open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}
2021-03-12 04:49:25,686 [main:194] - Type params = []
2021-03-12 04:49:25,789 [main:302] - generating value of type = CoroutineContext false depth = 2
2021-03-12 04:49:25,921 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:49:25,924 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:49:26,165 [main:302] - generating value of type = Key<*> false depth = 5
2021-03-12 04:49:26,280 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:49:26,283 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:49:26,636 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 8
2021-03-12 04:49:26,789 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:49:26,791 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:49:27,156 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 11
2021-03-12 04:49:27,268 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:49:27,270 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:49:27,670 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:49:27,670 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 04:49:27,670 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:49:27,670 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:49:27,688 [main:111] - Cant find and generate replacement for prope2.getOrThrow() type Ty0
2021-03-12 04:49:27,688 [main:107] - replacing (fu0("K"), String)
2021-03-12 04:49:27,688 [main:50] - replacing fu0("K") String
2021-03-12 04:49:27,688 [main:54] - Getting value of type String
2021-03-12 04:49:27,804 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:27,805 [main:58] - GENERATED VALUE OF TYPE String = "fwfuc"
2021-03-12 04:49:27,806 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:27,813 [main:67] - randomType = Kla3
2021-03-12 04:49:27,918 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 04:49:27,920 [main:112] - generating klass Kla3 text = class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}
2021-03-12 04:49:27,926 [main:114] - replacement of fu0("K") of type String is "fwfuc"
2021-03-12 04:49:28,030 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:28,031 [main:66] - Compilation checking started
2021-03-12 04:49:28,338 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + "fwfuc"

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:28,339 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 04:49:28,339 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 04:49:28,339 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 04:49:28,444 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 04:49:28,449 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 04:49:28,695 [main:67] - randomType = Function1<Float, Kla1>
2021-03-12 04:49:28,695 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 04:49:28,695 [main:107] - replacing (let(x), Unit?)
2021-03-12 04:49:28,695 [main:50] - replacing let(x) Unit?
2021-03-12 04:49:28,695 [main:54] - Getting value of type Unit?
2021-03-12 04:49:28,801 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 04:49:28,806 [main:58] - GENERATED VALUE OF TYPE Unit? = println()
2021-03-12 04:49:28,807 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:28,813 [main:67] - randomType = Kla1
2021-03-12 04:49:28,921 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 04:49:28,923 [main:112] - generating klass Kla1 text = class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}
2021-03-12 04:49:28,942 [main:149] - GENERATING call of type public open fun resumeWith(prope2: kotlin.Result<kotlin.Any?>): kotlin.Unit defined in Kla1[SimpleFunctionDescriptorImpl@380a7d1e]
2021-03-12 04:49:29,051 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 04:49:29,163 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 04:49:29,165 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 04:49:29,416 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 04:49:29,418 [main:95] - GENERATED = runCatching<Any?>({ null})
2021-03-12 04:49:29,419 [main:78] - Generated call from random type = (Kla1()).resumeWith(runCatching<Any?>({ null}))
2021-03-12 04:49:29,419 [main:114] - replacement of let(x) of type Unit? is println()
2021-03-12 04:49:29,538 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:29,539 [main:66] - Compilation checking started
2021-03-12 04:49:29,835 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.println()
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:29,837 [main:107] - replacing ("tail-call optimization miss: method at " + it + " has state-machine ", String)
2021-03-12 04:49:29,837 [main:50] - replacing "tail-call optimization miss: method at " + it + " has state-machine " String
2021-03-12 04:49:29,837 [main:54] - Getting value of type String
2021-03-12 04:49:29,962 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:29,963 [main:58] - GENERATED VALUE OF TYPE String = "hsvwl"
2021-03-12 04:49:29,964 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:29,970 [main:67] - randomType = Kla4
2021-03-12 04:49:30,075 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:49:30,077 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:49:30,084 [main:114] - replacement of "tail-call optimization miss: method at " + it + " has state-machine " of type String is "hsvwl"
2021-03-12 04:49:30,186 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:30,186 [main:66] - Compilation checking started
2021-03-12 04:49:30,495 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("hsvwl" +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:30,496 [main:107] - replacing (this, Kla1)
2021-03-12 04:49:30,496 [main:50] - replacing this Kla1
2021-03-12 04:49:30,496 [main:54] - Getting value of type Kla1
2021-03-12 04:49:30,648 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 04:49:30,649 [main:112] - generating klass Kla1 text = class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}
2021-03-12 04:49:30,649 [main:58] - GENERATED VALUE OF TYPE Kla1 = Kla1()
2021-03-12 04:49:30,649 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:30,772 [main:67] - randomType = Function1<UInt, Int>
2021-03-12 04:49:30,772 [main:114] - replacement of this of type Kla1 is Kla1()
2021-03-12 04:49:30,874 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:30,875 [main:66] - Compilation checking started
2021-03-12 04:49:31,171 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
Kla1().prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:31,172 [main:107] - replacing (prope1, Kla4)
2021-03-12 04:49:31,172 [main:50] - replacing prope1 Kla4
2021-03-12 04:49:31,173 [main:54] - Getting value of type Kla4
2021-03-12 04:49:31,277 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:49:31,279 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:49:31,279 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4()
2021-03-12 04:49:31,279 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:31,286 [main:67] - randomType = Kla0
2021-03-12 04:49:31,389 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 04:49:31,391 [main:112] - generating klass Kla0 text = open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}
2021-03-12 04:49:31,494 [main:194] - Type params = []
2021-03-12 04:49:31,596 [main:302] - generating value of type = CoroutineContext false depth = 2
2021-03-12 04:49:31,713 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:49:31,715 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:49:31,984 [main:302] - generating value of type = Key<*> false depth = 5
2021-03-12 04:49:32,114 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:49:32,117 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:49:32,513 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 04:49:32,513 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 04:49:32,533 [main:114] - replacement of prope1 of type Kla4 is Kla4()
2021-03-12 04:49:32,672 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:32,672 [main:66] - Compilation checking started
2021-03-12 04:49:32,983 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
Kla4().prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:32,985 [main:107] - replacing ("tail-call optimization miss: method at " + it, String)
2021-03-12 04:49:32,985 [main:50] - replacing "tail-call optimization miss: method at " + it String
2021-03-12 04:49:32,985 [main:54] - Getting value of type String
2021-03-12 04:49:33,100 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:33,102 [main:58] - GENERATED VALUE OF TYPE String = "hczim"
2021-03-12 04:49:33,102 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:33,722 [main:67] - randomType = Kla2<ArrayList<UByte?>>
2021-03-12 04:49:33,841 [main:302] - generating value of type = Kla2<ArrayList<UByte?>> false depth = 0
2021-03-12 04:49:33,843 [main:112] - generating klass Kla2 text = abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 04:49:34,497 [main:302] - generating value of type = Kla5 false depth = 2
2021-03-12 04:49:34,499 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:34,522 [main:114] - replacement of "tail-call optimization miss: method at " + it of type String is "hczim"
2021-03-12 04:49:34,653 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:34,653 [main:66] - Compilation checking started
2021-03-12 04:49:34,957 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("hczim" + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:34,958 [main:107] - replacing (prope2, Result<Ty0>)
2021-03-12 04:49:34,958 [main:50] - replacing prope2 Result<Ty0>
2021-03-12 04:49:34,958 [main:54] - Getting value of type Result<Ty0>
2021-03-12 04:49:35,078 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 04:49:35,198 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:35,201 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:35,466 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 04:49:35,466 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 04:49:35,619 [main:67] - randomType = Kla5
2021-03-12 04:49:35,736 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 04:49:35,737 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:35,766 [main:111] - Cant find and generate replacement for prope2 type Result<Ty0>
2021-03-12 04:49:35,766 [main:107] - replacing ("tail-call optimization miss: method at ", String)
2021-03-12 04:49:35,766 [main:50] - replacing "tail-call optimization miss: method at " String
2021-03-12 04:49:35,766 [main:54] - Getting value of type String
2021-03-12 04:49:35,897 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:35,899 [main:58] - GENERATED VALUE OF TYPE String = "zyzdw"
2021-03-12 04:49:35,899 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:36,165 [main:67] - randomType = LinkedHashMap<Int, Long>
2021-03-12 04:49:36,281 [main:302] - generating value of type = LinkedHashMap<Int, Long> false depth = 0
2021-03-12 04:49:36,408 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(pairs: Pair<Int, Long>): LkedHashMap<Int, Long> = TODO()
2021-03-12 04:49:36,410 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(pairs: Pair<Int, Long>): LkedHashMap<Int, Long> = TODO()
2021-03-12 04:49:36,533 [main:302] - generating value of type = Pair<Int, Long> false depth = 3
2021-03-12 04:49:36,662 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Int, second: Long): Pair<Int, Long> = TODO()
2021-03-12 04:49:36,664 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Int, second: Long): Pair<Int, Long> = TODO()
2021-03-12 04:49:36,795 [main:302] - generating value of type = Int true depth = 6
2021-03-12 04:49:36,797 [main:302] - generating value of type = Long true depth = 6
2021-03-12 04:49:36,798 [main:95] - GENERATED = Pair<Int, Long>(1797544581, -1851248554946089035)
2021-03-12 04:49:36,799 [main:95] - GENERATED = linkedMapOf<Int, Long>(Pair<Int, Long>(1797544581, -1851248554946089035))
2021-03-12 04:49:36,948 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1cad68ca]
2021-03-12 04:49:37,091 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:37,094 [main:78] - Generated call from random type = (linkedMapOf<Int, Long>(Pair<Int, Long>(1797544581, -1851248554946089035))).size.toString(1827844092)
2021-03-12 04:49:37,094 [main:114] - replacement of "tail-call optimization miss: method at " of type String is (linkedMapOf<Int, Long>(Pair<Int, Long>(1797544581, -1851248554946089035))).size.toString(1827844092)
2021-03-12 04:49:37,239 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:49:37,240 [main:66] - Compilation checking started
2021-03-12 04:49:37,593 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error((linkedMapOf<Int, Long>(Pair<Int, Long>(1797544581, -1851248554946089035))).size.toString(1827844092) + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:37,595 [main:107] - replacing ({ c.resume(Unit) }, Function0<Unit>)
2021-03-12 04:49:37,595 [main:50] - replacing { c.resume(Unit) } Function0<Unit>
2021-03-12 04:49:37,595 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:49:37,730 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:49:37,731 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:49:37,855 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:49:37,857 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 04:49:38,268 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:49:38,270 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 04:49:38,272 [main:302] - generating value of type = Any false depth = 5
2021-03-12 04:49:38,272 [main:95] - GENERATED = require(true, { "upqer"})
2021-03-12 04:49:38,272 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true, { "upqer"})}
2021-03-12 04:49:38,272 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:38,406 [main:67] - randomType = Kla5
2021-03-12 04:49:38,539 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 04:49:38,540 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:38,566 [main:114] - replacement of { c.resume(Unit) } of type Function0<Unit> is { require(true, { "upqer"})}
2021-03-12 04:49:38,687 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 04:49:38,688 [main:66] - Compilation checking started
2021-03-12 04:49:39,008 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { require(true, { "upqer"})}
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:39,009 [main:107] - replacing ("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4, String)
2021-03-12 04:49:39,010 [main:50] - replacing "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4 String
2021-03-12 04:49:39,010 [main:54] - Getting value of type String
2021-03-12 04:49:39,137 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:39,139 [main:58] - GENERATED VALUE OF TYPE String = "cohjx"
2021-03-12 04:49:39,139 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:39,146 [main:67] - randomType = Kla3
2021-03-12 04:49:39,263 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 04:49:39,264 [main:112] - generating klass Kla3 text = class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}
2021-03-12 04:49:39,271 [main:114] - replacement of "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4 of type String is "cohjx"
2021-03-12 04:49:39,390 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:39,391 [main:66] - Compilation checking started
2021-03-12 04:49:39,700 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("cohjx")
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:39,701 [main:107] - replacing ("tail-call optimization miss: method at ", String)
2021-03-12 04:49:39,701 [main:50] - replacing "tail-call optimization miss: method at " String
2021-03-12 04:49:39,701 [main:54] - Getting value of type String
2021-03-12 04:49:39,820 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:39,822 [main:58] - GENERATED VALUE OF TYPE String = "xsstu"
2021-03-12 04:49:39,822 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:40,630 [main:67] - randomType = Function1<Float, ArrayList<List<UShort>>?>
2021-03-12 04:49:40,630 [main:114] - replacement of "tail-call optimization miss: method at " of type String is "xsstu"
2021-03-12 04:49:40,747 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 04:49:40,747 [main:66] - Compilation checking started
2021-03-12 04:49:41,058 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("xsstu" + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:41,060 [main:107] - replacing (prope6, Function0<Unit>)
2021-03-12 04:49:41,060 [main:50] - replacing prope6 Function0<Unit>
2021-03-12 04:49:41,060 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:49:41,178 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:49:41,180 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:49:41,299 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 04:49:41,302 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 04:49:41,573 [main:302] - generating value of type = Any false depth = 4
2021-03-12 04:49:41,573 [main:95] - GENERATED = println("hmtzy")
2021-03-12 04:49:41,573 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println("hmtzy")}
2021-03-12 04:49:41,574 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:41,577 [main:67] - randomType = Boolean
2021-03-12 04:49:41,697 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:49:41,712 [main:114] - replacement of prope6 of type Function0<Unit> is { println("hmtzy")}
2021-03-12 04:49:41,830 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 04:49:41,831 [main:66] - Compilation checking started
2021-03-12 04:49:42,142 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        { println("hmtzy")} = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:42,144 [main:107] - replacing (prope2, String)
2021-03-12 04:49:42,144 [main:50] - replacing prope2 String
2021-03-12 04:49:42,144 [main:54] - Getting value of type String
2021-03-12 04:49:42,269 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:42,270 [main:58] - GENERATED VALUE OF TYPE String = "cxrbp"
2021-03-12 04:49:42,271 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:42,662 [main:67] - randomType = Kla2<Byte>
2021-03-12 04:49:42,800 [main:302] - generating value of type = Kla2<Byte> false depth = 0
2021-03-12 04:49:42,801 [main:112] - generating klass Kla2 text = abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 04:49:43,187 [main:302] - generating value of type = Kla5 false depth = 2
2021-03-12 04:49:43,189 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:43,206 [main:114] - replacement of prope2 of type String is "cxrbp"
2021-03-12 04:49:43,323 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:43,324 [main:66] - Compilation checking started
2021-03-12 04:49:43,637 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return "cxrbp"
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:43,639 [main:107] - replacing (1, Int)
2021-03-12 04:49:43,639 [main:50] - replacing 1 Int
2021-03-12 04:49:43,639 [main:54] - Getting value of type Int
2021-03-12 04:49:43,756 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:43,758 [main:58] - GENERATED VALUE OF TYPE Int = -1364457442
2021-03-12 04:49:43,758 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:44,179 [main:67] - randomType = Collection<Double?>
2021-03-12 04:49:44,179 [main:114] - replacement of 1 of type Int is -1364457442
2021-03-12 04:49:44,297 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-12 04:49:44,298 [main:66] - Compilation checking started
2021-03-12 04:49:44,613 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in -1364457442..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:44,615 [main:107] - replacing ("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got ", String)
2021-03-12 04:49:44,615 [main:50] - replacing "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " String
2021-03-12 04:49:44,615 [main:54] - Getting value of type String
2021-03-12 04:49:44,736 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:44,738 [main:58] - GENERATED VALUE OF TYPE String = "tmeop"
2021-03-12 04:49:44,738 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:44,870 [main:67] - randomType = Char
2021-03-12 04:49:44,995 [main:302] - generating value of type = Char true depth = 0
2021-03-12 04:49:45,025 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3938ca86]
2021-03-12 04:49:45,025 [main:78] - Generated call from random type = ('').uppercase()
2021-03-12 04:49:45,025 [main:114] - replacement of "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " of type String is ('').uppercase()
2021-03-12 04:49:45,142 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:49:45,142 [main:66] - Compilation checking started
2021-03-12 04:49:45,452 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error(('').uppercase() + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:45,454 [main:107] - replacing (prope4, Int)
2021-03-12 04:49:45,454 [main:50] - replacing prope4 Int
2021-03-12 04:49:45,454 [main:54] - Getting value of type Int
2021-03-12 04:49:45,574 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:45,576 [main:58] - GENERATED VALUE OF TYPE Int = -1572529436
2021-03-12 04:49:45,576 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:45,705 [main:67] - randomType = Kla5
2021-03-12 04:49:45,827 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 04:49:45,829 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:45,854 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla5[DeserializedSimpleFunctionDescriptor@63a80ed2]
2021-03-12 04:49:45,971 [main:302] - generating value of type = Any false depth = 0
2021-03-12 04:49:45,971 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4f07fb43]
2021-03-12 04:49:46,092 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:49:46,095 [main:78] - Generated call from random type = (Kla5).equals("gdmxc").compareTo(true)
2021-03-12 04:49:46,095 [main:114] - replacement of prope4 of type Int is (Kla5).equals("gdmxc").compareTo(true)
2021-03-12 04:49:46,214 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:49:46,215 [main:66] - Compilation checking started
2021-03-12 04:49:46,527 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + (Kla5).equals("gdmxc").compareTo(true))
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:46,529 [main:107] - replacing ({}, Function0<Unit>)
2021-03-12 04:49:46,529 [main:50] - replacing {} Function0<Unit>
2021-03-12 04:49:46,529 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:49:46,649 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:49:46,651 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:49:46,782 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:49:46,785 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:49:47,057 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:49:47,059 [main:95] - GENERATED = require(true)
2021-03-12 04:49:47,059 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true)}
2021-03-12 04:49:47,059 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:47,188 [main:67] - randomType = UShort
2021-03-12 04:49:47,315 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 04:49:47,353 [main:114] - replacement of {} of type Function0<Unit> is { require(true)}
2021-03-12 04:49:47,471 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 04:49:47,471 [main:66] - Compilation checking started
2021-03-12 04:49:47,824 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = { require(true)}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:47,826 [main:107] - replacing (Kla3(), Kla3)
2021-03-12 04:49:47,826 [main:50] - replacing Kla3() Kla3
2021-03-12 04:49:47,826 [main:54] - Getting value of type Kla3
2021-03-12 04:49:47,945 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 04:49:47,947 [main:112] - generating klass Kla3 text = class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}
2021-03-12 04:49:47,947 [main:58] - GENERATED VALUE OF TYPE Kla3 = Kla3()
2021-03-12 04:49:47,947 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:48,344 [main:67] - randomType = List<HashMap<Double, Kla0>>
2021-03-12 04:49:48,344 [main:114] - replacement of Kla3() of type Kla3 is Kla3()
2021-03-12 04:49:48,462 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:48,464 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 04:49:48,464 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 04:49:48,464 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 04:49:48,592 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 04:49:48,599 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 04:49:48,605 [main:67] - randomType = Boolean
2021-03-12 04:49:48,755 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 04:49:48,769 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 04:49:48,769 [main:107] - replacing (prope6, Function0<Unit>)
2021-03-12 04:49:48,769 [main:50] - replacing prope6 Function0<Unit>
2021-03-12 04:49:48,769 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:49:48,885 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:49:48,887 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:49:49,009 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:49:49,012 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 04:49:49,296 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 04:49:49,297 [main:95] - GENERATED = require(false)
2021-03-12 04:49:49,300 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(false)}
2021-03-12 04:49:49,300 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:49,304 [main:67] - randomType = String
2021-03-12 04:49:49,418 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:49,444 [main:114] - replacement of prope6 of type Function0<Unit> is { require(false)}
2021-03-12 04:49:49,572 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 04:49:49,573 [main:66] - Compilation checking started
2021-03-12 04:49:49,895 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        { require(false)} = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:49,897 [main:107] - replacing ("tail-call optimization hit: method " + method + " has no state-machine ", String)
2021-03-12 04:49:49,897 [main:50] - replacing "tail-call optimization hit: method " + method + " has no state-machine " String
2021-03-12 04:49:49,897 [main:54] - Getting value of type String
2021-03-12 04:49:50,013 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:50,015 [main:58] - GENERATED VALUE OF TYPE String = "znbtx"
2021-03-12 04:49:50,015 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:50,153 [main:67] - randomType = UShort
2021-03-12 04:49:50,272 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 04:49:50,309 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@41b7302f]
2021-03-12 04:49:50,423 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 04:49:50,425 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1cad68ca]
2021-03-12 04:49:50,544 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:50,546 [main:78] - Generated call from random type = (277.toUShort()).compareTo(128.toUByte()).toString(464024361)
2021-03-12 04:49:50,546 [main:114] - replacement of "tail-call optimization hit: method " + method + " has no state-machine " of type String is (277.toUShort()).compareTo(128.toUByte()).toString(464024361)
2021-03-12 04:49:50,661 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 04:49:50,661 [main:66] - Compilation checking started
2021-03-12 04:49:50,971 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error((277.toUShort()).compareTo(128.toUByte()).toString(464024361) +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:50,974 [main:107] - replacing (prope1.prope6, Function0<Unit>)
2021-03-12 04:49:50,974 [main:50] - replacing prope1.prope6 Function0<Unit>
2021-03-12 04:49:50,974 [main:54] - Getting value of type Function0<Unit>
2021-03-12 04:49:51,109 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 04:49:51,111 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 04:49:51,229 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 04:49:51,232 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 04:49:51,484 [main:302] - generating value of type = Any false depth = 4
2021-03-12 04:49:51,484 [main:95] - GENERATED = print("dvdcb")
2021-03-12 04:49:51,484 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { print("dvdcb")}
2021-03-12 04:49:51,484 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:51,623 [main:67] - randomType = HashSet<Kla4>
2021-03-12 04:49:51,739 [main:302] - generating value of type = HashSet<Kla4> false depth = 0
2021-03-12 04:49:51,849 [main:43] - GENERATING CALL OF fun <T> hashSetOf(elements: Kla4): HashSet<Kla4> = TODO()
2021-03-12 04:49:51,851 [main:61] - WITHOUT TYPE PARAMS = fun <T> hashSetOf(elements: Kla4): HashSet<Kla4> = TODO()
2021-03-12 04:49:51,978 [main:302] - generating value of type = Kla4 false depth = 3
2021-03-12 04:49:51,980 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:49:51,980 [main:95] - GENERATED = hashSetOf<Kla4>(Kla4())
2021-03-12 04:49:52,158 [main:114] - replacement of prope1.prope6 of type Function0<Unit> is { print("dvdcb")}
2021-03-12 04:49:52,280 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 04:49:52,281 [main:66] - Compilation checking started
2021-03-12 04:49:52,587 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
{ print("dvdcb")} = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:52,589 [main:107] - replacing (prope1, Kla4)
2021-03-12 04:49:52,589 [main:50] - replacing prope1 Kla4
2021-03-12 04:49:52,589 [main:54] - Getting value of type Kla4
2021-03-12 04:49:52,704 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:49:52,705 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:49:52,706 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4()
2021-03-12 04:49:52,706 [main:61] - GENERATED IS CALL =true
2021-03-12 04:49:52,712 [main:67] - randomType = Kla4
2021-03-12 04:49:52,827 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 04:49:52,829 [main:112] - generating klass Kla4 text = class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 04:49:52,839 [main:114] - replacement of prope1 of type Kla4 is Kla4()
2021-03-12 04:49:52,955 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 04:49:52,955 [main:66] - Compilation checking started
2021-03-12 04:49:53,278 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = fu0("O") + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
Kla4().prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:53,279 [main:107] - replacing (prope2.getOrThrow(), Ty0)
2021-03-12 04:49:53,280 [main:50] - replacing prope2.getOrThrow() Ty0
2021-03-12 04:49:53,280 [main:54] - Getting value of type Ty0
2021-03-12 04:49:53,396 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 04:49:53,401 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 04:49:53,405 [main:67] - randomType = Int
2021-03-12 04:49:53,521 [main:302] - generating value of type = Int true depth = 0
2021-03-12 04:49:53,566 [main:111] - Cant find and generate replacement for prope2.getOrThrow() type Ty0
2021-03-12 04:49:53,566 [main:107] - replacing (fu0("O"), String)
2021-03-12 04:49:53,566 [main:50] - replacing fu0("O") String
2021-03-12 04:49:53,566 [main:54] - Getting value of type String
2021-03-12 04:49:53,700 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:53,703 [main:58] - GENERATED VALUE OF TYPE String = "zyoyw"
2021-03-12 04:49:53,704 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:53,867 [main:67] - randomType = Kla5
2021-03-12 04:49:53,991 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 04:49:53,993 [main:112] - generating klass Kla5 text = object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}
2021-03-12 04:49:54,017 [main:114] - replacement of fu0("O") of type String is "zyoyw"
2021-03-12 04:49:54,130 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 04:49:54,131 [main:66] - Compilation checking started
2021-03-12 04:49:54,425 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
const val x = "OK"

fun box() = x

inline suspend fun fu0(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->
    prope0.fu8(x)
    x.resume(v)
    COROUTINE_SUSPENDED
}

inline suspend fun fu1(): String = "zyoyw" + fu0("K")

suspend fun fu2() = fu1()

fun fu3(c: suspend () -> Unit) {
    const val x = "OK"
c.startCoroutine(Kla0)
}

fun box871(): String {
    const val x = "OK"
var prope2 = ""

    fu3 {
        prope2 = fu2()
    }

    prope0.fu10("mainSuspend")

    return prope2
}

fun <Ty0> fu4(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
x(prope2.getOrThrow())
    }
}

fun fu5(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla0(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla6 : Kla0()
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
prope2.getOrThrow()
    }
}

class Kla1 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        const val x = "OK"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla2<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        const val x = "OK"
if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu6(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu6(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla3 {
    private val prope3 = arrayListOf<StackTraceElement?>()

    suspend fun fu8() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu8(it)
    }

    fun fu8(c: Continuation<*>) {
        const val x = "OK"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope3.clear()
        var prope7: CoroutineStackFrame? = c
        while (prope7 != null) {
            prope3.add(prope7.getStackTraceElement())
            prope7 = prope7.callerFrame
        }
    }

    fun fu9(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope3.joinToString(separator = "\n")) }
    }

    fun fu10(method: String) {
        const val x = "OK"
prope3.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope3.joinToString(separator = "\n"))
    }
}

val prope0 = Kla3()

class Kla4 {
    private var prope4 = (ArrayDeque<UInt>()).size.takeLowestOneBit()
    var prope5 = false

    var prope6: () -> Unit = {}

    fun fu11() {
        const val x = "OK"
prope4 = 0
        prope5 = false
        prope6 = {}
    }

    suspend fun fu1() = suspendCoroutine<Unit> { c ->
        prope4++
        prope6 = { c.resume(Unit) }
    }

    fun fu12(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        const val x = "OK"
for (i in 1..numberOfSuspensions) {
            if (prope4 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope4)
            prope6()
        }
        if (prope4 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope4)
        if (prope5) error("Wrong state-machine generated: it is finished early")
        prope6()
        if (checkFinished && !prope5) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla4()

object Kla5: Kla2<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        const val x = "OK"
prope1.prope6 = {
            prope1.prope5 = true
        }
    }

    override fun fu6(exception: Throwable) {
        throw exception
    }
}


2021-03-12 04:49:54,427 [main:107] - replacing (" has no state-machine ", String)
2021-03-12 04:49:54,427 [main:50] - replacing " has no state-machine " String
2021-03-12 04:49:54,427 [main:54] - Getting value of type String
2021-03-12 04:49:54,544 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:54,546 [main:58] - GENERATED VALUE OF TYPE String = "gbeda"
2021-03-12 04:49:54,546 [main:61] - GENERATED IS CALL =false
2021-03-12 04:49:54,550 [main:67] - randomType = String
2021-03-12 04:49:54,693 [main:302] - generating value of type = String true depth = 0
2021-03-12 04:49:54,719 [main:149] - GENERATING call of type public fun kotlin.String.replaceAfterLast(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1c331437]
2021-03-12 04:49:54,835 [main:302] - generating value of type = Char true depth = 0
