2021-03-11 21:08:32,728 [main:66] - Compilation checking started
2021-03-11 21:08:35,580 [main:45] - Trying to change 183 nodes
2021-03-11 21:08:35,595 [main:53] - replacing (0x4454445444544454, Long)
2021-03-11 21:08:35,596 [main:50] - replacing 0x4454445444544454 Long
2021-03-11 21:08:35,596 [main:54] - Getting value of type Long
2021-03-11 21:08:35,800 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:35,803 [main:58] - GENERATED VALUE OF TYPE Long = -4624642411494488430
2021-03-11 21:08:35,804 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:36,415 [main:67] - randomType = Double
2021-03-11 21:08:36,572 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:36,694 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:08:36,695 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:08:36,696 [main:78] - Generated call from random type = (0.3801095614814559).toInt().toLong()
2021-03-11 21:08:36,696 [main:106] - GETTING Long from Long?
2021-03-11 21:08:36,793 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]]
2021-03-11 21:08:36,793 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:08:36,793 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]
2021-03-11 21:08:36,794 [main:117] - GENERATED CALL = (l6).and(larg2).shr(iarg2)
2021-03-11 21:08:36,796 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]]
2021-03-11 21:08:36,796 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:36,796 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]
2021-03-11 21:08:36,797 [main:117] - GENERATED CALL = (l6).toDouble().toRawBits()
2021-03-11 21:08:36,797 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9], public final val last: kotlin.Long defined in kotlin.ranges.LongRange[DeserializedPropertyDescriptor@430aedd2]]
2021-03-11 21:08:36,797 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9]
2021-03-11 21:08:36,958 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:36,960 [main:117] - GENERATED CALL = (l6).rangeTo(108).last
2021-03-11 21:08:36,960 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]]
2021-03-11 21:08:36,961 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:36,961 [main:149] - GENERATING call of type public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]
2021-03-11 21:08:36,962 [main:117] - GENERATED CALL = (l6).toLong().inv()
2021-03-11 21:08:36,962 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]]
2021-03-11 21:08:36,962 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:08:36,962 [main:149] - GENERATING call of type public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]
2021-03-11 21:08:36,963 [main:117] - GENERATED CALL = (l6).and(larg1).inv()
2021-03-11 21:08:36,963 [main:113] - Case = [public final operator fun times(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@6b94ced3]]
2021-03-11 21:08:36,964 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@6b94ced3]
2021-03-11 21:08:37,109 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:37,111 [main:117] - GENERATED CALL = (l6).times(9)
2021-03-11 21:08:37,111 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]]
2021-03-11 21:08:37,111 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:08:37,112 [main:117] - GENERATED CALL = (l6).and(larg2)
2021-03-11 21:08:37,112 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]]
2021-03-11 21:08:37,112 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:37,112 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]
2021-03-11 21:08:37,113 [main:117] - GENERATED CALL = (l6).toDouble().toBits()
2021-03-11 21:08:37,113 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:08:37,113 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:08:37,114 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:08:37,114 [main:117] - GENERATED CALL = (l6).and(larg2).dec()
2021-03-11 21:08:37,114 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]]
2021-03-11 21:08:37,114 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:08:37,115 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]
2021-03-11 21:08:37,115 [main:117] - GENERATED CALL = (l6).toInt().times(larg1)
2021-03-11 21:08:37,115 [main:61] - replacement of 0x4454445444544454 of type Long is (l6).and(larg2).shr(iarg2)
2021-03-11 21:08:37,312 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:37,313 [main:66] - Compilation checking started
2021-03-11 21:08:37,809 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != (l6).and(larg2).shr(iarg2)) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}
2021-03-11 21:08:37,813 [main:53] - replacing (0x65DC65DC, Int)
2021-03-11 21:08:37,814 [main:50] - replacing 0x65DC65DC Int
2021-03-11 21:08:37,815 [main:54] - Getting value of type Int
2021-03-11 21:08:37,972 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:37,973 [main:58] - GENERATED VALUE OF TYPE Int = -1652145188
2021-03-11 21:08:37,973 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:37,975 [main:67] - randomType = Short
2021-03-11 21:08:38,154 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:08:38,227 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:08:38,228 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:08:38,229 [main:78] - Generated call from random type = (-10970).toInt().toInt()
2021-03-11 21:08:38,229 [main:61] - replacement of 0x65DC65DC of type Int is (-10970).toInt().toInt()
2021-03-11 21:08:38,414 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:38,415 [main:66] - Compilation checking started
2021-03-11 21:08:39,065 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}
2021-03-11 21:08:39,071 [main:53] - replacing (larg2, Long)
2021-03-11 21:08:39,073 [main:50] - replacing larg2 Long
2021-03-11 21:08:39,073 [main:54] - Getting value of type Long
2021-03-11 21:08:39,226 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:39,227 [main:58] - GENERATED VALUE OF TYPE Long = 3600116625060648517
2021-03-11 21:08:39,228 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:39,816 [main:67] - randomType = LinkedHashMap<String, ArrayList<UByte>>
2021-03-11 21:08:39,976 [main:302] - generating value of type = LinkedHashMap<String, ArrayList<UByte>> false depth = 0
2021-03-11 21:08:40,114 [main:43] - GENERATING CALL OF fun <K, V> LinkedHashMap(initialCapacity: kotlin.Int): LinkedHashMap<String, ArrayList<UByte>> = TODO()
2021-03-11 21:08:40,119 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> LinkedHashMap(initialCapacity: kotlin.Int): LinkedHashMap<String, ArrayList<UByte>> = TODO()
2021-03-11 21:08:40,396 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:08:40,397 [main:95] - GENERATED = LinkedHashMap<String, ArrayList<UByte>>(92964170)
2021-03-11 21:08:40,680 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:40,681 [main:78] - Generated call from random type = (LinkedHashMap<String, ArrayList<UByte>>(92964170)).size.div(larg1)
2021-03-11 21:08:40,681 [main:106] - GETTING Long from Long
2021-03-11 21:08:40,740 [main:113] - Case = [public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]]
2021-03-11 21:08:40,740 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]
2021-03-11 21:08:40,741 [main:117] - GENERATED CALL = (larg2).unaryPlus()
2021-03-11 21:08:40,741 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]]
2021-03-11 21:08:40,741 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:40,741 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]
2021-03-11 21:08:40,742 [main:117] - GENERATED CALL = (larg2).toLong().coerceAtMost(larg2)
2021-03-11 21:08:40,742 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Long.absoluteValue: kotlin.Long defined in kotlin.math[DeserializedPropertyDescriptor@212d84f6]]
2021-03-11 21:08:40,742 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:40,743 [main:117] - GENERATED CALL = (larg2).toLong().absoluteValue
2021-03-11 21:08:40,743 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]]
2021-03-11 21:08:40,743 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]
2021-03-11 21:08:40,744 [main:117] - GENERATED CALL = (larg2).rotateRight(iarg1)
2021-03-11 21:08:40,744 [main:113] - Case = [public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]]
2021-03-11 21:08:40,744 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]
2021-03-11 21:08:40,745 [main:117] - GENERATED CALL = (larg2).unaryMinus()
2021-03-11 21:08:40,745 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]]
2021-03-11 21:08:40,745 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:08:40,879 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:40,880 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]
2021-03-11 21:08:40,881 [main:117] - GENERATED CALL = (larg2).div(0.11114194376014819).toRawBits()
2021-03-11 21:08:40,881 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]]
2021-03-11 21:08:40,881 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:08:41,014 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:41,015 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:41,016 [main:117] - GENERATED CALL = (larg2).compareTo(99).div(larg1)
2021-03-11 21:08:41,016 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@356a99a2]]
2021-03-11 21:08:41,016 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:08:41,017 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@356a99a2]
2021-03-11 21:08:41,017 [main:117] - GENERATED CALL = (larg2).toByte().div(larg2)
2021-03-11 21:08:41,017 [main:113] - Case = [public final operator fun times(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@6b94ced3]]
2021-03-11 21:08:41,017 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@6b94ced3]
2021-03-11 21:08:41,127 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:41,129 [main:117] - GENERATED CALL = (larg2).times(-5)
2021-03-11 21:08:41,129 [main:113] - Case = [public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]]
2021-03-11 21:08:41,129 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]
2021-03-11 21:08:41,260 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:41,262 [main:117] - GENERATED CALL = (larg2).coerceAtMost(177262976855497809)
2021-03-11 21:08:41,262 [main:61] - replacement of larg2 of type Long is (larg2).div(0.11114194376014819).toRawBits()
2021-03-11 21:08:41,403 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:41,404 [main:66] - Compilation checking started
2021-03-11 21:08:41,929 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:41,938 [main:53] - replacing (b4 != 0x23.toByte(), Boolean)
2021-03-11 21:08:41,940 [main:50] - replacing b4 != 0x23.toByte() Boolean
2021-03-11 21:08:41,940 [main:54] - Getting value of type Boolean
2021-03-11 21:08:42,087 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:08:42,088 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:08:42,088 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:42,222 [main:67] - randomType = ULong
2021-03-11 21:08:42,332 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:08:42,387 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@2a85fe01]
2021-03-11 21:08:42,387 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]
2021-03-11 21:08:42,388 [main:78] - Generated call from random type = (1352801316459248471.toULong()).toFloat().isInfinite()
2021-03-11 21:08:42,391 [main:106] - GETTING Boolean from Long
2021-03-11 21:08:42,458 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@67ca72ba]]
2021-03-11 21:08:42,458 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:08:42,583 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:42,585 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@67ca72ba]
2021-03-11 21:08:42,773 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:42,774 [main:117] - GENERATED CALL = (larg2).equals("tkefu").equals("mlmdm")
2021-03-11 21:08:42,775 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]]
2021-03-11 21:08:42,775 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:42,775 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]
2021-03-11 21:08:42,775 [main:117] - GENERATED CALL = (larg2).toChar().isISOControl()
2021-03-11 21:08:42,776 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]]
2021-03-11 21:08:42,776 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:42,776 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]
2021-03-11 21:08:42,777 [main:117] - GENERATED CALL = (larg2).toChar().isUpperCase()
2021-03-11 21:08:42,777 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]]
2021-03-11 21:08:42,777 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:42,777 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]
2021-03-11 21:08:42,778 [main:117] - GENERATED CALL = (larg2).toChar().isTitleCase()
2021-03-11 21:08:42,778 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]]
2021-03-11 21:08:42,778 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:42,778 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]
2021-03-11 21:08:42,779 [main:117] - GENERATED CALL = (larg2).toChar().isLowSurrogate()
2021-03-11 21:08:42,779 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]]
2021-03-11 21:08:42,779 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:08:42,780 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]
2021-03-11 21:08:42,931 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:42,933 [main:117] - GENERATED CALL = (larg2).toFloat().equals("mubyg")
2021-03-11 21:08:42,933 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:08:42,933 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:08:43,044 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:43,045 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:08:43,153 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:43,154 [main:117] - GENERATED CALL = (larg2).div(0.6789964844926537).equals("dsbme")
2021-03-11 21:08:43,154 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]]
2021-03-11 21:08:43,154 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:43,155 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]
2021-03-11 21:08:43,155 [main:117] - GENERATED CALL = (larg2).toChar().isDefined()
2021-03-11 21:08:43,155 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c00b3f8]]
2021-03-11 21:08:43,156 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:43,156 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c00b3f8]
2021-03-11 21:08:43,289 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:08:43,398 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:08:43,400 [main:117] - GENERATED CALL = (larg2).toChar().equals('똹', false)
2021-03-11 21:08:43,400 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]]
2021-03-11 21:08:43,400 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:08:43,400 [main:149] - GENERATING call of type public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]
2021-03-11 21:08:43,401 [main:117] - GENERATED CALL = (larg2).toFloat().isFinite()
2021-03-11 21:08:43,401 [main:61] - replacement of b4 != 0x23.toByte() of type Boolean is (larg2).toChar().isUpperCase()
2021-03-11 21:08:43,508 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:43,509 [main:66] - Compilation checking started
2021-03-11 21:08:44,009 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:44,012 [main:53] - replacing (iarg1 ushr 16, Int)
2021-03-11 21:08:44,013 [main:50] - replacing iarg1 ushr 16 Int
2021-03-11 21:08:44,013 [main:54] - Getting value of type Int
2021-03-11 21:08:44,125 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:44,125 [main:58] - GENERATED VALUE OF TYPE Int = -804652838
2021-03-11 21:08:44,126 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:44,248 [main:67] - randomType = UInt
2021-03-11 21:08:44,354 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:08:44,404 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@362aa7cd]
2021-03-11 21:08:44,404 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@2f62c5fb]
2021-03-11 21:08:44,405 [main:78] - Generated call from random type = (623445619.toUInt()).toFloat().toInt()
2021-03-11 21:08:44,405 [main:61] - replacement of iarg1 ushr 16 of type Int is (623445619.toUInt()).toFloat().toInt()
2021-03-11 21:08:44,508 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:44,509 [main:66] - Compilation checking started
2021-03-11 21:08:45,003 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:45,011 [main:53] - replacing (s2 != 0xFDDE.toShort(), Boolean)
2021-03-11 21:08:45,012 [main:50] - replacing s2 != 0xFDDE.toShort() Boolean
2021-03-11 21:08:45,013 [main:54] - Getting value of type Boolean
2021-03-11 21:08:45,170 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:08:45,171 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:08:45,172 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:45,174 [main:67] - randomType = Byte
2021-03-11 21:08:45,285 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:45,342 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:45,342 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:08:45,343 [main:78] - Generated call from random type = (32).toDouble().isInfinite()
2021-03-11 21:08:45,344 [main:106] - GETTING Boolean from Long?
2021-03-11 21:08:45,402 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]]
2021-03-11 21:08:45,403 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:08:45,515 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:45,516 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]
2021-03-11 21:08:45,627 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:08:45,628 [main:117] - GENERATED CALL = (l2).equals("scfeb").or(true)
2021-03-11 21:08:45,628 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]]
2021-03-11 21:08:45,628 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:45,629 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]
2021-03-11 21:08:45,629 [main:117] - GENERATED CALL = (l2).toChar().isLowSurrogate()
2021-03-11 21:08:45,629 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]]
2021-03-11 21:08:45,629 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:08:45,629 [main:149] - GENERATING call of type public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]
2021-03-11 21:08:45,630 [main:117] - GENERATED CALL = (l2).toFloat().isFinite()
2021-03-11 21:08:45,630 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:08:45,630 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:08:45,750 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:45,751 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:08:45,752 [main:117] - GENERATED CALL = (l2).div(0.7251054546830547).isInfinite()
2021-03-11 21:08:45,752 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]]
2021-03-11 21:08:45,752 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:45,752 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]
2021-03-11 21:08:45,753 [main:117] - GENERATED CALL = (l2).toChar().isLetter()
2021-03-11 21:08:45,753 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:08:45,753 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:45,753 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:08:45,861 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:45,862 [main:117] - GENERATED CALL = (l2).toDouble().equals("lnwwl")
2021-03-11 21:08:45,862 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]]
2021-03-11 21:08:45,862 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:45,862 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]
2021-03-11 21:08:45,863 [main:117] - GENERATED CALL = (l2).toChar().isISOControl()
2021-03-11 21:08:45,863 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:08:45,863 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:45,863 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:08:45,864 [main:117] - GENERATED CALL = (l2).toDouble().isNaN()
2021-03-11 21:08:45,864 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:08:45,864 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:45,864 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:08:45,864 [main:117] - GENERATED CALL = (l2).toChar().isLowerCase()
2021-03-11 21:08:45,865 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]]
2021-03-11 21:08:45,865 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:08:45,865 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]
2021-03-11 21:08:45,962 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:45,962 [main:117] - GENERATED CALL = (l2).toFloat().equals("zxzjo")
2021-03-11 21:08:45,963 [main:61] - replacement of s2 != 0xFDDE.toShort() of type Boolean is (l2).equals("scfeb").or(true)
2021-03-11 21:08:46,060 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:46,060 [main:66] - Compilation checking started
2021-03-11 21:08:46,495 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:46,497 [main:53] - replacing (0xDC560000.toInt(), Int)
2021-03-11 21:08:46,498 [main:50] - replacing 0xDC560000.toInt() Int
2021-03-11 21:08:46,498 [main:54] - Getting value of type Int
2021-03-11 21:08:46,603 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:46,604 [main:58] - GENERATED VALUE OF TYPE Int = 1833922659
2021-03-11 21:08:46,604 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:46,819 [main:67] - randomType = Float?
2021-03-11 21:08:46,915 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:08:46,950 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@719ac69]
2021-03-11 21:08:46,950 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6d337a74]
2021-03-11 21:08:47,100 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:47,103 [main:78] - Generated call from random type = (0.5818931f)?.toShort().times(101)
2021-03-11 21:08:47,104 [main:61] - replacement of 0xDC560000.toInt() of type Int is (0.5818931f)?.toShort().times(101)
2021-03-11 21:08:47,208 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:47,208 [main:66] - Compilation checking started
2021-03-11 21:08:47,655 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:47,660 [main:53] - replacing (sarg1, Short)
2021-03-11 21:08:47,661 [main:50] - replacing sarg1 Short
2021-03-11 21:08:47,661 [main:54] - Getting value of type Short
2021-03-11 21:08:47,766 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:08:47,767 [main:58] - GENERATED VALUE OF TYPE Short = -25333
2021-03-11 21:08:47,767 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:47,883 [main:67] - randomType = Char
2021-03-11 21:08:47,999 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:08:48,035 [main:149] - GENERATING call of type public final fun toShort(): kotlin.Short defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13744188]
2021-03-11 21:08:48,035 [main:149] - GENERATING call of type public fun kotlin.Short.coerceIn(minimumValue: kotlin.Short, maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5f8f67d1]
2021-03-11 21:08:48,036 [main:78] - Generated call from random type = ('').toShort().coerceIn(sarg1, sarg2)
2021-03-11 21:08:48,037 [main:106] - GETTING Short from Int?
2021-03-11 21:08:48,100 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@1f9f550e]]
2021-03-11 21:08:48,100 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:48,101 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@1f9f550e]
2021-03-11 21:08:48,101 [main:117] - GENERATED CALL = (i5).toDouble().toShort()
2021-03-11 21:08:48,101 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public fun kotlin.Short.coerceAtMost(maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ec993d6]]
2021-03-11 21:08:48,101 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:48,102 [main:149] - GENERATING call of type public fun kotlin.Short.coerceAtMost(maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ec993d6]
2021-03-11 21:08:48,102 [main:117] - GENERATED CALL = (i5).toShort().coerceAtMost(sarg2)
2021-03-11 21:08:48,102 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.or(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@486aa623]]
2021-03-11 21:08:48,102 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:48,103 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.or(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@486aa623]
2021-03-11 21:08:48,103 [main:117] - GENERATED CALL = (i5).toShort().or(sarg1)
2021-03-11 21:08:48,103 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.inv(): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ff195]]
2021-03-11 21:08:48,103 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:48,104 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.inv(): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ff195]
2021-03-11 21:08:48,104 [main:117] - GENERATED CALL = (i5).toShort().inv()
2021-03-11 21:08:48,104 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Short.rotateLeft(bitCount: kotlin.Int): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@4d2cdda2]]
2021-03-11 21:08:48,104 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:48,104 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Short.rotateLeft(bitCount: kotlin.Int): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@4d2cdda2]
2021-03-11 21:08:48,212 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:48,213 [main:117] - GENERATED CALL = (i5).toShort().rotateLeft(-1543040971)
2021-03-11 21:08:48,214 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeLowestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@5318b279]]
2021-03-11 21:08:48,214 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:48,214 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeLowestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@5318b279]
2021-03-11 21:08:48,215 [main:117] - GENERATED CALL = (i5).toShort().takeLowestOneBit()
2021-03-11 21:08:48,215 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@1f9f550e]]
2021-03-11 21:08:48,215 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:08:48,320 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:48,321 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@1f9f550e]
2021-03-11 21:08:48,322 [main:117] - GENERATED CALL = (i5).div(0.24915960836398532).toShort()
2021-03-11 21:08:48,322 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun toShort(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5e9dc66]]
2021-03-11 21:08:48,322 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:48,322 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5e9dc66]
2021-03-11 21:08:48,323 [main:117] - GENERATED CALL = (i5).toShort().toShort()
2021-03-11 21:08:48,323 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Short.rotateRight(bitCount: kotlin.Int): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@69dc1291]]
2021-03-11 21:08:48,323 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:48,323 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Short.rotateRight(bitCount: kotlin.Int): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@69dc1291]
2021-03-11 21:08:48,423 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:48,425 [main:117] - GENERATED CALL = (i5).toShort().rotateRight(1306653913)
2021-03-11 21:08:48,425 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public final fun toShort(): kotlin.Short defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13744188]]
2021-03-11 21:08:48,425 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:48,425 [main:149] - GENERATING call of type public final fun toShort(): kotlin.Short defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13744188]
2021-03-11 21:08:48,426 [main:117] - GENERATED CALL = (i5).toChar().toShort()
2021-03-11 21:08:48,426 [main:61] - replacement of sarg1 of type Short is (i5).toChar().toShort()
2021-03-11 21:08:48,522 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:48,523 [main:66] - Compilation checking started
2021-03-11 21:08:48,983 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:48,990 [main:53] - replacing (l7, Long?)
2021-03-11 21:08:48,991 [main:50] - replacing l7 Long?
2021-03-11 21:08:48,991 [main:54] - Getting value of type Long?
2021-03-11 21:08:49,102 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:49,103 [main:58] - GENERATED VALUE OF TYPE Long? = 5762724753042541984
2021-03-11 21:08:49,104 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:49,214 [main:67] - randomType = UShort
2021-03-11 21:08:49,314 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:08:49,358 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@4c8a46f9]
2021-03-11 21:08:49,359 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Double.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@917de8d]
2021-03-11 21:08:49,359 [main:78] - Generated call from random type = (32236.toUShort()).toDouble().roundToLong()
2021-03-11 21:08:49,361 [main:106] - GETTING Long? from Long?
2021-03-11 21:08:49,416 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]]
2021-03-11 21:08:49,416 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:49,417 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]
2021-03-11 21:08:49,417 [main:117] - GENERATED CALL = (l3)?.toDouble().toRawBits()
2021-03-11 21:08:49,417 [main:113] - Case = [public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]]
2021-03-11 21:08:49,417 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]
2021-03-11 21:08:49,512 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:49,513 [main:117] - GENERATED CALL = (l3)?.or(-3140539220178680661)
2021-03-11 21:08:49,513 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]]
2021-03-11 21:08:49,513 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:08:49,514 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]
2021-03-11 21:08:49,630 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:49,631 [main:117] - GENERATED CALL = (l3)?.and(larg1).plus(44)
2021-03-11 21:08:49,631 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]]
2021-03-11 21:08:49,631 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:08:49,728 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:49,729 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]
2021-03-11 21:08:49,730 [main:117] - GENERATED CALL = (l3)?.and(3984868132457632202).unaryMinus()
2021-03-11 21:08:49,730 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]]
2021-03-11 21:08:49,730 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:08:49,830 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:49,831 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]
2021-03-11 21:08:49,831 [main:117] - GENERATED CALL = (l3)?.and(-6598479241835767419).takeLowestOneBit()
2021-03-11 21:08:49,831 [main:113] - Case = [public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]]
2021-03-11 21:08:49,831 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]
2021-03-11 21:08:49,832 [main:117] - GENERATED CALL = (l3)?.xor(larg2)
2021-03-11 21:08:49,832 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]]
2021-03-11 21:08:49,832 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:49,832 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]
2021-03-11 21:08:49,930 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:49,932 [main:117] - GENERATED CALL = (l3)?.toLong().shl(-605531905)
2021-03-11 21:08:49,932 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]]
2021-03-11 21:08:49,932 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:08:49,932 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]
2021-03-11 21:08:49,933 [main:117] - GENERATED CALL = (l3)?.toInt().times(larg1)
2021-03-11 21:08:49,933 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]]
2021-03-11 21:08:49,933 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:49,933 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]
2021-03-11 21:08:49,933 [main:117] - GENERATED CALL = (l3)?.toDouble().toBits()
2021-03-11 21:08:49,933 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]]
2021-03-11 21:08:49,933 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:49,934 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]
2021-03-11 21:08:49,934 [main:117] - GENERATED CALL = (l3)?.toLong().unaryMinus()
2021-03-11 21:08:49,934 [main:61] - replacement of l7 of type Long? is (l3)?.and(larg1).plus(44)
2021-03-11 21:08:50,028 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:50,029 [main:66] - Compilation checking started
2021-03-11 21:08:50,550 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:50,555 [main:53] - replacing (s1 != 0x4454.toShort(), Boolean)
2021-03-11 21:08:50,557 [main:50] - replacing s1 != 0x4454.toShort() Boolean
2021-03-11 21:08:50,557 [main:54] - Getting value of type Boolean
2021-03-11 21:08:50,677 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:08:50,678 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:08:50,678 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:50,825 [main:67] - randomType = Double
2021-03-11 21:08:50,927 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:50,972 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@3c4584e1]
2021-03-11 21:08:50,973 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@576eefea]
2021-03-11 21:08:50,973 [main:78] - Generated call from random type = (0.8877563515137844).toChar().isSurrogate()
2021-03-11 21:08:50,975 [main:106] - GETTING Boolean from Int?
2021-03-11 21:08:51,030 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]]
2021-03-11 21:08:51,030 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:08:51,125 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:51,126 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]
2021-03-11 21:08:51,236 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:08:51,237 [main:117] - GENERATED CALL = (i1).equals("pmsrs").or(false)
2021-03-11 21:08:51,237 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]]
2021-03-11 21:08:51,237 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:08:51,328 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:51,329 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]
2021-03-11 21:08:51,329 [main:117] - GENERATED CALL = (i1).rangeTo(-6).contains(i4)
2021-03-11 21:08:51,329 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]]
2021-03-11 21:08:51,330 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:51,330 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]
2021-03-11 21:08:51,427 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:51,427 [main:117] - GENERATED CALL = (i1).toShort().equals("unuvb")
2021-03-11 21:08:51,427 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]]
2021-03-11 21:08:51,428 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:51,428 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]
2021-03-11 21:08:51,428 [main:117] - GENERATED CALL = (i1).toChar().isLetterOrDigit()
2021-03-11 21:08:51,428 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:08:51,428 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:08:51,537 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:51,538 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:08:51,539 [main:117] - GENERATED CALL = (i1).div(0.3905489816388419).isNaN()
2021-03-11 21:08:51,539 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:08:51,539 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:51,539 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:08:51,540 [main:117] - GENERATED CALL = (i1).toChar().isWhitespace()
2021-03-11 21:08:51,540 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:08:51,540 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:51,540 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:08:51,540 [main:117] - GENERATED CALL = (i1).toChar().isLowerCase()
2021-03-11 21:08:51,540 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c]]
2021-03-11 21:08:51,541 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:51,558 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c]
2021-03-11 21:08:51,650 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:51,651 [main:117] - GENERATED CALL = (i1).toByte().equals("azzqm")
2021-03-11 21:08:51,651 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:08:51,651 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:08:51,753 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:51,754 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:08:51,846 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:51,846 [main:117] - GENERATED CALL = (i1).div(0.03129447254301976).equals("gaayy")
2021-03-11 21:08:51,846 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1c6b7dcc]]
2021-03-11 21:08:51,846 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:08:51,937 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:51,938 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1c6b7dcc]
2021-03-11 21:08:51,938 [main:117] - GENERATED CALL = (i1).equals("xjasj").not()
2021-03-11 21:08:51,938 [main:61] - replacement of s1 != 0x4454.toShort() of type Boolean is (i1).rangeTo(-6).contains(i4)
2021-03-11 21:08:52,062 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:52,063 [main:66] - Compilation checking started
2021-03-11 21:08:52,517 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:52,520 [main:53] - replacing (0xDC56DC56L shl 32, Long)
2021-03-11 21:08:52,522 [main:50] - replacing 0xDC56DC56L shl 32 Long
2021-03-11 21:08:52,522 [main:54] - Getting value of type Long
2021-03-11 21:08:52,629 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:52,630 [main:58] - GENERATED VALUE OF TYPE Long = -551418344686930843
2021-03-11 21:08:52,630 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:52,733 [main:67] - randomType = Double
2021-03-11 21:08:52,829 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:08:52,882 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]
2021-03-11 21:08:52,882 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@403d5694]
2021-03-11 21:08:52,883 [main:78] - Generated call from random type = (0.8598474753234696).toByte().toLong()
2021-03-11 21:08:52,884 [main:106] - GETTING Long from Int
2021-03-11 21:08:52,958 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]]
2021-03-11 21:08:52,958 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:53,062 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:53,063 [main:149] - GENERATING call of type public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]
2021-03-11 21:08:53,168 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:53,170 [main:117] - GENERATED CALL = (iarg2).div(-2887636010981169380).coerceIn(larg1, -7460784314743452359)
2021-03-11 21:08:53,170 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:08:53,170 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:53,170 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:08:53,170 [main:117] - GENERATED CALL = (iarg2).div(larg1).dec()
2021-03-11 21:08:53,171 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]]
2021-03-11 21:08:53,171 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:53,171 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]
2021-03-11 21:08:53,171 [main:117] - GENERATED CALL = (iarg2).toLong().or(larg1)
2021-03-11 21:08:53,171 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:08:53,171 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:53,171 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:08:53,263 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:53,264 [main:117] - GENERATED CALL = (iarg2).toLong().rem(72)
2021-03-11 21:08:53,264 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]]
2021-03-11 21:08:53,264 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:08:53,265 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:53,265 [main:117] - GENERATED CALL = (iarg2).toInt().div(larg1)
2021-03-11 21:08:53,265 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Long.rotateLeft(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@53e43e3a]]
2021-03-11 21:08:53,265 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:53,265 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Long.rotateLeft(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@53e43e3a]
2021-03-11 21:08:53,265 [main:117] - GENERATED CALL = (iarg2).toLong().rotateLeft(iarg1)
2021-03-11 21:08:53,266 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]]
2021-03-11 21:08:53,266 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:53,266 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]
2021-03-11 21:08:53,266 [main:117] - GENERATED CALL = (iarg2).div(larg1).unaryMinus()
2021-03-11 21:08:53,266 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:08:53,266 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:53,266 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:08:53,359 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:53,360 [main:117] - GENERATED CALL = (iarg2).div(larg1).rem(27)
2021-03-11 21:08:53,360 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@356a99a2]]
2021-03-11 21:08:53,360 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:53,361 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@356a99a2]
2021-03-11 21:08:53,361 [main:117] - GENERATED CALL = (iarg2).toByte().div(larg1)
2021-03-11 21:08:53,361 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]]
2021-03-11 21:08:53,361 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:08:53,361 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:08:53,361 [main:117] - GENERATED CALL = (iarg2).compareTo(iarg1).toLong()
2021-03-11 21:08:53,362 [main:61] - replacement of 0xDC56DC56L shl 32 of type Long is (iarg2).toByte().div(larg1)
2021-03-11 21:08:53,452 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:53,452 [main:66] - Compilation checking started
2021-03-11 21:08:53,866 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = ((iarg2).toByte().div(larg1)) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:53,870 [main:53] - replacing ("fail: Int.shl", String)
2021-03-11 21:08:53,871 [main:50] - replacing "fail: Int.shl" String
2021-03-11 21:08:53,871 [main:54] - Getting value of type String
2021-03-11 21:08:54,009 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:08:54,010 [main:58] - GENERATED VALUE OF TYPE String = "czjdc"
2021-03-11 21:08:54,011 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:54,638 [main:67] - randomType = Function2<Boolean?, Float, UByte?>
2021-03-11 21:08:54,640 [main:106] - GETTING String from Int?
2021-03-11 21:08:54,721 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:08:54,722 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:08:54,722 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:08:54,722 [main:117] - GENERATED CALL = (i6).compareTo(iarg2).toString(iarg1)
2021-03-11 21:08:54,722 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:08:54,722 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:54,723 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:08:54,723 [main:117] - GENERATED CALL = (i6).toByte().toString(iarg1)
2021-03-11 21:08:54,723 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:08:54,723 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:08:54,819 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:54,820 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:08:54,821 [main:117] - GENERATED CALL = (i6).and(1094604970).toString(iarg1)
2021-03-11 21:08:54,821 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:08:54,821 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:54,821 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:08:54,919 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:54,920 [main:117] - GENERATED CALL = (i6).toLong().toString(-1037947620)
2021-03-11 21:08:54,920 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:08:54,920 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:54,920 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:08:54,921 [main:117] - GENERATED CALL = (i6).toChar().uppercase()
2021-03-11 21:08:54,921 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:08:54,921 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:54,921 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:08:54,921 [main:117] - GENERATED CALL = (i6).toShort().toString(iarg1)
2021-03-11 21:08:54,921 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:08:54,921 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:54,921 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:08:54,922 [main:117] - GENERATED CALL = (i6).toChar().lowercase()
2021-03-11 21:08:54,922 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:08:54,922 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:54,922 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:08:54,922 [main:117] - GENERATED CALL = (i6).toChar().titlecase()
2021-03-11 21:08:54,922 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:08:54,922 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:08:54,922 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:08:54,923 [main:117] - GENERATED CALL = (i6).toInt().toString(iarg1)
2021-03-11 21:08:54,923 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:08:54,923 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:08:55,022 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:08:55,023 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:08:55,023 [main:117] - GENERATED CALL = (i6).div(3726911771419315778).toString(iarg1)
2021-03-11 21:08:55,023 [main:61] - replacement of "fail: Int.shl" of type String is (i6).toShort().toString(iarg1)
2021-03-11 21:08:55,118 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:55,118 [main:66] - Compilation checking started
2021-03-11 21:08:55,446 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i6).toShort().toString(iarg1)
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:55,452 [main:53] - replacing (b2 != 0xFD.toByte(), Boolean)
2021-03-11 21:08:55,454 [main:50] - replacing b2 != 0xFD.toByte() Boolean
2021-03-11 21:08:55,454 [main:54] - Getting value of type Boolean
2021-03-11 21:08:55,556 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:08:55,557 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:08:55,557 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:56,359 [main:67] - randomType = Function2<Int?, Char?, Pair<Char, Double>>
2021-03-11 21:08:56,360 [main:106] - GETTING Boolean from Int?
2021-03-11 21:08:56,425 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:08:56,426 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:56,426 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:08:56,523 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:56,524 [main:117] - GENERATED CALL = (i7).toDouble().equals("cdzig")
2021-03-11 21:08:56,524 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]]
2021-03-11 21:08:56,524 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:08:56,524 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]
2021-03-11 21:08:56,524 [main:117] - GENERATED CALL = (i7).toFloat().isInfinite()
2021-03-11 21:08:56,525 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:08:56,525 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:08:56,615 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:08:56,616 [main:117] - GENERATED CALL = (i7).equals("hyfao")
2021-03-11 21:08:56,616 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@576eefea]]
2021-03-11 21:08:56,616 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:56,616 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@576eefea]
2021-03-11 21:08:56,617 [main:117] - GENERATED CALL = (i7).toChar().isSurrogate()
2021-03-11 21:08:56,617 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]]
2021-03-11 21:08:56,617 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:56,617 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]
2021-03-11 21:08:56,617 [main:117] - GENERATED CALL = (i7).toChar().isDigit()
2021-03-11 21:08:56,617 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:08:56,617 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:08:56,617 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:08:56,617 [main:117] - GENERATED CALL = (i7).toDouble().isInfinite()
2021-03-11 21:08:56,618 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]]
2021-03-11 21:08:56,618 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:56,618 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]
2021-03-11 21:08:56,708 [main:117] - GENERATED CALL = (i7).toShort().equals(null)
2021-03-11 21:08:56,708 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]]
2021-03-11 21:08:56,708 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:08:56,709 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]
2021-03-11 21:08:56,818 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:56,819 [main:117] - GENERATED CALL = (i7).rangeTo(barg2).contains(-2091322430)
2021-03-11 21:08:56,820 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:08:56,820 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:56,820 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:08:56,820 [main:117] - GENERATED CALL = (i7).toChar().isLowerCase()
2021-03-11 21:08:56,821 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]]
2021-03-11 21:08:56,821 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:08:56,821 [main:149] - GENERATING call of type public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]
2021-03-11 21:08:56,821 [main:117] - GENERATED CALL = (i7).toFloat().isFinite()
2021-03-11 21:08:56,821 [main:61] - replacement of b2 != 0xFD.toByte() of type Boolean is (i7).equals("hyfao")
2021-03-11 21:08:56,925 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:56,926 [main:66] - Compilation checking started
2021-03-11 21:08:57,311 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:57,315 [main:53] - replacing (barg2, Byte)
2021-03-11 21:08:57,316 [main:50] - replacing barg2 Byte
2021-03-11 21:08:57,316 [main:54] - Getting value of type Byte
2021-03-11 21:08:57,411 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:57,412 [main:58] - GENERATED VALUE OF TYPE Byte = 78
2021-03-11 21:08:57,412 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:57,720 [main:67] - randomType = Sequence<ULong>
2021-03-11 21:08:57,722 [main:106] - GETTING Byte from Int?
2021-03-11 21:08:57,767 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]]
2021-03-11 21:08:57,767 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:08:57,767 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]
2021-03-11 21:08:57,767 [main:117] - GENERATED CALL = (i2).toFloat().toByte()
2021-03-11 21:08:57,767 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@74213f3a]]
2021-03-11 21:08:57,767 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:08:57,767 [main:149] - GENERATING call of type public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@74213f3a]
2021-03-11 21:08:57,768 [main:117] - GENERATED CALL = (i2).toChar().toByte()
2021-03-11 21:08:57,768 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]]
2021-03-11 21:08:57,768 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:57,768 [main:149] - GENERATING call of type public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]
2021-03-11 21:08:57,857 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:57,858 [main:117] - GENERATED CALL = (i2).toByte().coerceAtMost(-62)
2021-03-11 21:08:57,858 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]]
2021-03-11 21:08:57,858 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:08:57,858 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:57,859 [main:117] - GENERATED CALL = (i2).compareTo(iarg2).toByte()
2021-03-11 21:08:57,859 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateLeft(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@1cf22470]]
2021-03-11 21:08:57,859 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:57,859 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateLeft(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@1cf22470]
2021-03-11 21:08:57,956 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:08:57,957 [main:117] - GENERATED CALL = (i2).toByte().rotateLeft(-353104998)
2021-03-11 21:08:57,957 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]]
2021-03-11 21:08:57,957 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:57,957 [main:117] - GENERATED CALL = (i2).toByte()
2021-03-11 21:08:57,957 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]]
2021-03-11 21:08:57,957 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:57,957 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]
2021-03-11 21:08:57,958 [main:117] - GENERATED CALL = (i2).toByte().takeHighestOneBit()
2021-03-11 21:08:57,958 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun inc(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3f893413]]
2021-03-11 21:08:57,958 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:57,958 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3f893413]
2021-03-11 21:08:57,958 [main:117] - GENERATED CALL = (i2).toByte().inc()
2021-03-11 21:08:57,958 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.or(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@55f7b16b]]
2021-03-11 21:08:57,958 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:08:57,958 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.or(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@55f7b16b]
2021-03-11 21:08:57,959 [main:117] - GENERATED CALL = (i2).toByte().or(barg1)
2021-03-11 21:08:57,959 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]]
2021-03-11 21:08:57,959 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:08:57,959 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:08:57,959 [main:117] - GENERATED CALL = (i2).toShort().toByte()
2021-03-11 21:08:57,959 [main:61] - replacement of barg2 of type Byte is (i2).toShort().toByte()
2021-03-11 21:08:58,050 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:58,050 [main:66] - Compilation checking started
2021-03-11 21:08:58,400 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:58,405 [main:53] - replacing ("fail: Long.xor", String)
2021-03-11 21:08:58,406 [main:50] - replacing "fail: Long.xor" String
2021-03-11 21:08:58,406 [main:54] - Getting value of type String
2021-03-11 21:08:58,506 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:08:58,507 [main:58] - GENERATED VALUE OF TYPE String = "vyecx"
2021-03-11 21:08:58,507 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:58,710 [main:67] - randomType = Char?
2021-03-11 21:08:58,804 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:08:58,838 [main:149] - GENERATING call of type public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]
2021-03-11 21:08:58,839 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:08:58,839 [main:78] - Generated call from random type = ('⼛')?.toLong().toString(iarg1)
2021-03-11 21:08:58,840 [main:106] - GETTING String from Long
2021-03-11 21:08:58,894 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:08:58,894 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:08:58,894 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:08:58,895 [main:117] - GENERATED CALL = (larg1).toInt().toString(iarg2)
2021-03-11 21:08:58,895 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:08:58,895 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:08:58,895 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:08:58,895 [main:117] - GENERATED CALL = (larg1).toByte().toString(iarg1)
2021-03-11 21:08:58,895 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:08:58,895 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:08:58,985 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:08:58,986 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:08:58,986 [main:117] - GENERATED CALL = (larg1).compareTo(-22).toString(iarg1)
2021-03-11 21:08:58,986 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:08:58,986 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:08:58,986 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:08:58,987 [main:117] - GENERATED CALL = (larg1).toLong().toString(iarg2)
2021-03-11 21:08:58,987 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:08:58,987 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:58,987 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:08:58,987 [main:117] - GENERATED CALL = (larg1).toChar().titlecase()
2021-03-11 21:08:58,987 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:08:58,987 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:08:58,987 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:08:58,988 [main:117] - GENERATED CALL = (larg1).toShort().toString(iarg1)
2021-03-11 21:08:58,988 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:08:58,988 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:08:58,988 [main:117] - GENERATED CALL = (larg1).toString(iarg2)
2021-03-11 21:08:58,988 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:08:58,988 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:58,988 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:08:58,988 [main:117] - GENERATED CALL = (larg1).toChar().lowercase()
2021-03-11 21:08:58,988 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:08:58,989 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:58,989 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:08:59,099 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:08:59,100 [main:117] - GENERATED CALL = (larg1).toChar().plus("vhsut")
2021-03-11 21:08:59,100 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:08:59,101 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:08:59,101 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:08:59,101 [main:117] - GENERATED CALL = (larg1).toChar().uppercase()
2021-03-11 21:08:59,101 [main:61] - replacement of "fail: Long.xor" of type String is (larg1).toLong().toString(iarg2)
2021-03-11 21:08:59,214 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:08:59,214 [main:66] - Compilation checking started
2021-03-11 21:08:59,566 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:08:59,570 [main:53] - replacing (s3, Short?)
2021-03-11 21:08:59,571 [main:50] - replacing s3 Short?
2021-03-11 21:08:59,571 [main:54] - Getting value of type Short?
2021-03-11 21:08:59,664 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:08:59,664 [main:58] - GENERATED VALUE OF TYPE Short? = -3605
2021-03-11 21:08:59,665 [main:61] - GENERATED IS CALL =false
2021-03-11 21:08:59,767 [main:67] - randomType = ULong
2021-03-11 21:08:59,875 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:08:59,912 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toUInt(): kotlin.UInt defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@3f560ef]
2021-03-11 21:08:59,912 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@12919a6f]
2021-03-11 21:08:59,913 [main:78] - Generated call from random type = (6111397445261622474.toULong()).toUInt().toShort()
2021-03-11 21:08:59,913 [main:61] - replacement of s3 of type Short? is (6111397445261622474.toULong()).toUInt().toShort()
2021-03-11 21:09:00,003 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:00,003 [main:66] - Compilation checking started
2021-03-11 21:09:00,349 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:00,352 [main:53] - replacing ("fail: Long.and", String)
2021-03-11 21:09:00,352 [main:50] - replacing "fail: Long.and" String
2021-03-11 21:09:00,352 [main:54] - Getting value of type String
2021-03-11 21:09:00,445 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:00,446 [main:58] - GENERATED VALUE OF TYPE String = "qdtir"
2021-03-11 21:09:00,446 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:00,989 [main:67] - randomType = Function1<Map<Sequence<UInt>, Short>?, String>
2021-03-11 21:09:00,990 [main:106] - GETTING String from Int
2021-03-11 21:09:01,049 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:01,049 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:01,144 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:01,145 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:01,146 [main:117] - GENERATED CALL = (iarg1).compareTo(-1050454631).toString(iarg1)
2021-03-11 21:09:01,146 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:01,146 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:01,146 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:01,146 [main:117] - GENERATED CALL = (iarg1).toInt().toString(iarg1)
2021-03-11 21:09:01,146 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:09:01,146 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:01,146 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:09:01,147 [main:117] - GENERATED CALL = (iarg1).toByte().toString(iarg1)
2021-03-11 21:09:01,147 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:09:01,147 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:01,147 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:09:01,147 [main:117] - GENERATED CALL = (iarg1).toChar().lowercase()
2021-03-11 21:09:01,147 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:09:01,147 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:01,147 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:01,240 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:01,241 [main:117] - GENERATED CALL = (iarg1).toLong().toString(1782417773)
2021-03-11 21:09:01,241 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:09:01,241 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:01,241 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:09:01,242 [main:117] - GENERATED CALL = (iarg1).toShort().toString(iarg2)
2021-03-11 21:09:01,242 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:09:01,242 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:01,242 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:09:01,332 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:01,333 [main:117] - GENERATED CALL = (iarg1).toChar().plus("lphcn")
2021-03-11 21:09:01,333 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:09:01,333 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:01,334 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:09:01,334 [main:117] - GENERATED CALL = (iarg1).toChar().uppercase()
2021-03-11 21:09:01,334 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:09:01,334 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:01,334 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:01,334 [main:117] - GENERATED CALL = (iarg1).div(larg1).toString(iarg1)
2021-03-11 21:09:01,334 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:01,334 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:01,335 [main:117] - GENERATED CALL = (iarg1).toString(iarg2)
2021-03-11 21:09:01,335 [main:61] - replacement of "fail: Long.and" of type String is (iarg1).div(larg1).toString(iarg1)
2021-03-11 21:09:01,433 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:01,434 [main:66] - Compilation checking started
2021-03-11 21:09:01,814 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:01,817 [main:53] - replacing (0xDC56DC56.toInt(), Int)
2021-03-11 21:09:01,818 [main:50] - replacing 0xDC56DC56.toInt() Int
2021-03-11 21:09:01,818 [main:54] - Getting value of type Int
2021-03-11 21:09:01,914 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:01,915 [main:58] - GENERATED VALUE OF TYPE Int = -624972606
2021-03-11 21:09:01,915 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:02,224 [main:67] - randomType = Triple<Byte, UShort, UByte>
2021-03-11 21:09:02,318 [main:302] - generating value of type = Triple<Byte, UShort, UByte> false depth = 0
2021-03-11 21:09:02,431 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Byte, second: UShort, third: UByte): Triple<Byte, UShort, UByte> = TODO()
2021-03-11 21:09:02,433 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Byte, second: UShort, third: UByte): Triple<Byte, UShort, UByte> = TODO()
2021-03-11 21:09:02,537 [main:302] - generating value of type = Byte true depth = 3
2021-03-11 21:09:02,538 [main:302] - generating value of type = UShort true depth = 3
2021-03-11 21:09:02,539 [main:302] - generating value of type = UByte true depth = 3
2021-03-11 21:09:02,540 [main:95] - GENERATED = Triple<Byte, UShort, UByte>(19, 24427.toUShort(), 118.toUByte())
2021-03-11 21:09:02,564 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@38b34d32]
2021-03-11 21:09:02,564 [main:78] - Generated call from random type = (Triple<Byte, UShort, UByte>(19, 24427.toUShort(), 118.toUByte())).first.unaryMinus()
2021-03-11 21:09:02,565 [main:106] - GETTING Int from Int
2021-03-11 21:09:02,612 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:09:02,612 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:02,613 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:09:02,613 [main:117] - GENERATED CALL = (iarg1).compareTo(iarg1).inc()
2021-03-11 21:09:02,613 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@448d8489]]
2021-03-11 21:09:02,613 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:02,613 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@448d8489]
2021-03-11 21:09:02,613 [main:117] - GENERATED CALL = (iarg1).toInt().rotateLeft(iarg1)
2021-03-11 21:09:02,614 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5751ecf4]]
2021-03-11 21:09:02,614 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5751ecf4]
2021-03-11 21:09:02,614 [main:117] - GENERATED CALL = (iarg1).takeHighestOneBit()
2021-03-11 21:09:02,614 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]]
2021-03-11 21:09:02,614 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:02,614 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]
2021-03-11 21:09:02,614 [main:117] - GENERATED CALL = (iarg1).toInt().coerceIn(iarg1, iarg1)
2021-03-11 21:09:02,614 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public val kotlin.Long.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@1360523c]]
2021-03-11 21:09:02,614 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:02,615 [main:117] - GENERATED CALL = (iarg1).toLong().sign
2021-03-11 21:09:02,615 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public open fun toInt(): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@2f62c5fb]]
2021-03-11 21:09:02,615 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:02,615 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@2f62c5fb]
2021-03-11 21:09:02,615 [main:117] - GENERATED CALL = (iarg1).toFloat().toInt()
2021-03-11 21:09:02,615 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]]
2021-03-11 21:09:02,615 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:02,709 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:02,710 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]
2021-03-11 21:09:02,711 [main:117] - GENERATED CALL = (iarg1).compareTo(1876241682).ushr(iarg1)
2021-03-11 21:09:02,711 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@1ff4108]]
2021-03-11 21:09:02,711 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:02,711 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@1ff4108]
2021-03-11 21:09:02,711 [main:117] - GENERATED CALL = (iarg1).toLong().countOneBits()
2021-03-11 21:09:02,711 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]]
2021-03-11 21:09:02,711 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]
2021-03-11 21:09:02,712 [main:117] - GENERATED CALL = (iarg1).countLeadingZeroBits()
2021-03-11 21:09:02,712 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]]
2021-03-11 21:09:02,712 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:02,712 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]
2021-03-11 21:09:02,801 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:02,802 [main:117] - GENERATED CALL = (iarg1).toDouble().compareTo(-29)
2021-03-11 21:09:02,802 [main:61] - replacement of 0xDC56DC56.toInt() of type Int is (iarg1).toFloat().toInt()
2021-03-11 21:09:02,891 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:02,891 [main:66] - Compilation checking started
2021-03-11 21:09:03,169 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = (iarg1).toFloat().toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:03,171 [main:53] - replacing (iarg1, Int)
2021-03-11 21:09:03,171 [main:50] - replacing iarg1 Int
2021-03-11 21:09:03,171 [main:54] - Getting value of type Int
2021-03-11 21:09:03,274 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:03,275 [main:58] - GENERATED VALUE OF TYPE Int = -2103183133
2021-03-11 21:09:03,275 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:03,375 [main:67] - randomType = Char?
2021-03-11 21:09:03,464 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:09:03,485 [main:149] - GENERATING call of type public final fun toShort(): kotlin.Short defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13744188]
2021-03-11 21:09:03,485 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:09:03,574 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:03,575 [main:78] - Generated call from random type = ('㻀')?.toShort().compareTo(91)
2021-03-11 21:09:03,575 [main:106] - GETTING Int from Int?
2021-03-11 21:09:03,607 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]]
2021-03-11 21:09:03,608 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:03,696 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:03,697 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]
2021-03-11 21:09:03,697 [main:117] - GENERATED CALL = (i1).compareTo(-1236343311).ushr(iarg2)
2021-03-11 21:09:03,697 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]]
2021-03-11 21:09:03,697 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:03,698 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]
2021-03-11 21:09:03,698 [main:117] - GENERATED CALL = (i1).and(iarg2).inv()
2021-03-11 21:09:03,698 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]]
2021-03-11 21:09:03,698 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:03,698 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]
2021-03-11 21:09:03,698 [main:117] - GENERATED CALL = (i1).and(iarg2).rotateRight(iarg2)
2021-03-11 21:09:03,698 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@15466b6c]]
2021-03-11 21:09:03,698 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:03,698 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@15466b6c]
2021-03-11 21:09:03,788 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:03,789 [main:117] - GENERATED CALL = (i1).and(iarg2).coerceAtMost(-83307752)
2021-03-11 21:09:03,789 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4a848b8e]]
2021-03-11 21:09:03,789 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:03,790 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4a848b8e]
2021-03-11 21:09:03,879 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:03,880 [main:117] - GENERATED CALL = (i1).compareTo(iarg2).compareTo(-14)
2021-03-11 21:09:03,880 [main:113] - Case = [public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@28383eeb]]
2021-03-11 21:09:03,880 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@28383eeb]
2021-03-11 21:09:03,988 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:03,989 [main:117] - GENERATED CALL = (i1).plus(0)
2021-03-11 21:09:03,989 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@444f3fa7]]
2021-03-11 21:09:03,989 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:03,990 [main:117] - GENERATED CALL = (i1).and(iarg2).sign
2021-03-11 21:09:03,990 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]]
2021-03-11 21:09:03,990 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:03,990 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]
2021-03-11 21:09:04,101 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:04,102 [main:117] - GENERATED CALL = (i1).toByte().minus(43)
2021-03-11 21:09:04,103 [main:113] - Case = [public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]]
2021-03-11 21:09:04,103 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:09:04,103 [main:117] - GENERATED CALL = (i1).toInt()
2021-03-11 21:09:04,103 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:09:04,103 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:04,103 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:09:04,104 [main:117] - GENERATED CALL = (i1).toInt().inc()
2021-03-11 21:09:04,104 [main:61] - replacement of iarg1 of type Int is (i1).and(iarg2).coerceAtMost(-83307752)
2021-03-11 21:09:04,196 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:04,197 [main:66] - Compilation checking started
2021-03-11 21:09:04,447 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (i1).and(iarg2).coerceAtMost(-83307752) and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:04,450 [main:53] - replacing (l3, Long?)
2021-03-11 21:09:04,451 [main:50] - replacing l3 Long?
2021-03-11 21:09:04,451 [main:54] - Getting value of type Long?
2021-03-11 21:09:04,543 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:04,544 [main:58] - GENERATED VALUE OF TYPE Long? = 3074053667456030817
2021-03-11 21:09:04,544 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:04,546 [main:67] - randomType = ULong
2021-03-11 21:09:04,637 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:09:04,667 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@5589a864]
2021-03-11 21:09:04,771 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:09:04,772 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]
2021-03-11 21:09:04,773 [main:78] - Generated call from random type = (1116509618163309358.toULong()).compareTo(34.toUByte()).minus(larg2)
2021-03-11 21:09:04,773 [main:106] - GETTING Long? from Long
2021-03-11 21:09:04,824 [main:113] - Case = [public final operator fun div(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2971cea9]]
2021-03-11 21:09:04,824 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2971cea9]
2021-03-11 21:09:04,920 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:04,921 [main:117] - GENERATED CALL = (larg2)?.div(74)
2021-03-11 21:09:04,921 [main:113] - Case = [public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]]
2021-03-11 21:09:04,921 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]
2021-03-11 21:09:04,921 [main:117] - GENERATED CALL = (larg2)?.or(larg2)
2021-03-11 21:09:04,921 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]]
2021-03-11 21:09:04,921 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]
2021-03-11 21:09:04,921 [main:117] - GENERATED CALL = (larg2)?.rotateRight(iarg1)
2021-03-11 21:09:04,922 [main:113] - Case = [public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]]
2021-03-11 21:09:04,922 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]
2021-03-11 21:09:04,922 [main:117] - GENERATED CALL = (larg2)?.coerceAtLeast(larg1)
2021-03-11 21:09:04,922 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]]
2021-03-11 21:09:04,922 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:04,922 [main:149] - GENERATING call of type public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]
2021-03-11 21:09:05,016 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:05,017 [main:117] - GENERATED CALL = (larg2)?.toLong().coerceIn(larg2, -4912262984102011949)
2021-03-11 21:09:05,017 [main:113] - Case = [public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]]
2021-03-11 21:09:05,017 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]
2021-03-11 21:09:05,018 [main:117] - GENERATED CALL = (larg2)?.xor(larg1)
2021-03-11 21:09:05,018 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]]
2021-03-11 21:09:05,018 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:05,018 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]
2021-03-11 21:09:05,018 [main:117] - GENERATED CALL = (larg2)?.toShort().toLong()
2021-03-11 21:09:05,018 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]]
2021-03-11 21:09:05,018 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:05,112 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:05,113 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:05,114 [main:117] - GENERATED CALL = (larg2)?.compareTo(99).div(larg1)
2021-03-11 21:09:05,114 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a58fe0c]]
2021-03-11 21:09:05,114 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:05,114 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a58fe0c]
2021-03-11 21:09:05,114 [main:117] - GENERATED CALL = (larg2)?.toShort().times(larg1)
2021-03-11 21:09:05,115 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeHighestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@57ac128c]]
2021-03-11 21:09:05,115 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:05,115 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeHighestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@57ac128c]
2021-03-11 21:09:05,115 [main:117] - GENERATED CALL = (larg2)?.toLong().takeHighestOneBit()
2021-03-11 21:09:05,115 [main:61] - replacement of l3 of type Long? is (larg2)?.toShort().toLong()
2021-03-11 21:09:05,205 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:05,205 [main:66] - Compilation checking started
2021-03-11 21:09:05,510 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if ((larg2)?.toShort().toLong() != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:05,516 [main:53] - replacing (b1, Byte?)
2021-03-11 21:09:05,517 [main:50] - replacing b1 Byte?
2021-03-11 21:09:05,517 [main:54] - Getting value of type Byte?
2021-03-11 21:09:05,632 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:05,633 [main:58] - GENERATED VALUE OF TYPE Byte? = -113
2021-03-11 21:09:05,633 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:05,742 [main:67] - randomType = Boolean?
2021-03-11 21:09:05,832 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:05,845 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:09:05,936 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:05,937 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:05,937 [main:78] - Generated call from random type = (false)?.compareTo(false).toByte()
2021-03-11 21:09:05,937 [main:61] - replacement of b1 of type Byte? is (false)?.compareTo(false).toByte()
2021-03-11 21:09:06,038 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:06,039 [main:66] - Compilation checking started
2021-03-11 21:09:06,465 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:06,466 [main:53] - replacing (b1, Byte?)
2021-03-11 21:09:06,466 [main:50] - replacing b1 Byte?
2021-03-11 21:09:06,466 [main:54] - Getting value of type Byte?
2021-03-11 21:09:06,563 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:06,564 [main:58] - GENERATED VALUE OF TYPE Byte? = -52
2021-03-11 21:09:06,564 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:06,566 [main:67] - randomType = Char
2021-03-11 21:09:06,668 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:09:06,691 [main:149] - GENERATING call of type public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@74213f3a]
2021-03-11 21:09:06,691 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateRight(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@7447e4aa]
2021-03-11 21:09:06,782 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:06,783 [main:78] - Generated call from random type = ('罐').toByte().rotateRight(864527925)
2021-03-11 21:09:06,783 [main:61] - replacement of b1 of type Byte? is -52
2021-03-11 21:09:06,875 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-11 21:09:06,879 [main:53] - replacing (barg2, Byte)
2021-03-11 21:09:06,880 [main:50] - replacing barg2 Byte
2021-03-11 21:09:06,880 [main:54] - Getting value of type Byte
2021-03-11 21:09:06,970 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:06,971 [main:58] - GENERATED VALUE OF TYPE Byte = -72
2021-03-11 21:09:06,971 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:07,072 [main:67] - randomType = UInt?
2021-03-11 21:09:07,168 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:09:07,211 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@40e8bb4d]
2021-03-11 21:09:07,212 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.and(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@7102b336]
2021-03-11 21:09:07,305 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:07,306 [main:78] - Generated call from random type = (600505551.toUInt())?.toByte().and(61)
2021-03-11 21:09:07,308 [main:106] - GETTING Byte from Long
2021-03-11 21:09:07,347 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateLeft(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@1cf22470]]
2021-03-11 21:09:07,347 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:07,347 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateLeft(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@1cf22470]
2021-03-11 21:09:07,462 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:07,463 [main:117] - GENERATED CALL = (larg1).toByte().rotateLeft(366572297)
2021-03-11 21:09:07,463 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]]
2021-03-11 21:09:07,463 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:07,464 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]
2021-03-11 21:09:07,464 [main:117] - GENERATED CALL = (larg1).toByte().takeHighestOneBit()
2021-03-11 21:09:07,464 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]]
2021-03-11 21:09:07,464 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:07,464 [main:149] - GENERATING call of type public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]
2021-03-11 21:09:07,564 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:07,565 [main:117] - GENERATED CALL = (larg1).toByte().coerceAtMost(53)
2021-03-11 21:09:07,565 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]]
2021-03-11 21:09:07,565 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:07,565 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]
2021-03-11 21:09:07,565 [main:117] - GENERATED CALL = (larg1).toDouble().toByte()
2021-03-11 21:09:07,565 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.xor(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@3a9e4a66]]
2021-03-11 21:09:07,565 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:07,566 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.xor(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@3a9e4a66]
2021-03-11 21:09:07,566 [main:117] - GENERATED CALL = (larg1).toByte().xor(barg1)
2021-03-11 21:09:07,566 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@74213f3a]]
2021-03-11 21:09:07,566 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:09:07,566 [main:149] - GENERATING call of type public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@74213f3a]
2021-03-11 21:09:07,566 [main:117] - GENERATED CALL = (larg1).toChar().toByte()
2021-03-11 21:09:07,566 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]]
2021-03-11 21:09:07,566 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:07,566 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:07,567 [main:117] - GENERATED CALL = (larg1).toInt().toByte()
2021-03-11 21:09:07,567 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]]
2021-03-11 21:09:07,567 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:07,567 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]
2021-03-11 21:09:07,567 [main:117] - GENERATED CALL = (larg1).toFloat().toByte()
2021-03-11 21:09:07,567 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.and(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@7102b336]]
2021-03-11 21:09:07,567 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:07,567 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.and(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@7102b336]
2021-03-11 21:09:07,665 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:07,666 [main:117] - GENERATED CALL = (larg1).toByte().and(-18)
2021-03-11 21:09:07,666 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateRight(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@7447e4aa]]
2021-03-11 21:09:07,666 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:07,666 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateRight(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@7447e4aa]
2021-03-11 21:09:07,756 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:07,757 [main:117] - GENERATED CALL = (larg1).toByte().rotateRight(1035817499)
2021-03-11 21:09:07,758 [main:61] - replacement of barg2 of type Byte is (larg1).toFloat().toByte()
2021-03-11 21:09:07,846 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:07,846 [main:66] - Compilation checking started
2021-03-11 21:09:08,205 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:08,209 [main:53] - replacing ("fail: Int.shl", String)
2021-03-11 21:09:08,210 [main:50] - replacing "fail: Int.shl" String
2021-03-11 21:09:08,210 [main:54] - Getting value of type String
2021-03-11 21:09:08,309 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:08,309 [main:58] - GENERATED VALUE OF TYPE String = "iezhy"
2021-03-11 21:09:08,310 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:08,638 [main:67] - randomType = Collection<List<String?>>
2021-03-11 21:09:08,639 [main:106] - GETTING String from Int?
2021-03-11 21:09:08,691 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:09:08,691 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:08,780 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:08,781 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:08,782 [main:117] - GENERATED CALL = (i3).div(5224524394610312178).toString(iarg1)
2021-03-11 21:09:08,782 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:08,782 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:08,782 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:08,782 [main:117] - GENERATED CALL = (i3).and(iarg2).toString(iarg1)
2021-03-11 21:09:08,782 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:09:08,782 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:08,782 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:09:08,783 [main:117] - GENERATED CALL = (i3).toChar().lowercase()
2021-03-11 21:09:08,783 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:09:08,783 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:08,783 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:08,877 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:08,878 [main:117] - GENERATED CALL = (i3).toLong().toString(265223760)
2021-03-11 21:09:08,878 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:09:08,878 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:08,878 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:09:08,878 [main:117] - GENERATED CALL = (i3).toChar().uppercase()
2021-03-11 21:09:08,879 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:09:08,879 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:08,879 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:09:08,879 [main:117] - GENERATED CALL = (i3).toChar().titlecase()
2021-03-11 21:09:08,879 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:09:08,879 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:08,879 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:09:08,970 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:08,971 [main:117] - GENERATED CALL = (i3).toChar().plus("dnhvf")
2021-03-11 21:09:08,972 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:08,972 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:08,972 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:09,069 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:09,070 [main:117] - GENERATED CALL = (i3).compareTo(iarg1).toString(786792735)
2021-03-11 21:09:09,070 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:09:09,070 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:09,071 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:09:09,071 [main:117] - GENERATED CALL = (i3).toByte().toString(iarg2)
2021-03-11 21:09:09,071 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:09,071 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:09,071 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:09,071 [main:117] - GENERATED CALL = (i3).toInt().toString(iarg2)
2021-03-11 21:09:09,071 [main:61] - replacement of "fail: Int.shl" of type String is (i3).toChar().lowercase()
2021-03-11 21:09:09,197 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:09,198 [main:66] - Compilation checking started
2021-03-11 21:09:09,547 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:09,551 [main:53] - replacing (larg1 xor larg2, Long)
2021-03-11 21:09:09,552 [main:50] - replacing larg1 xor larg2 Long
2021-03-11 21:09:09,552 [main:54] - Getting value of type Long
2021-03-11 21:09:09,663 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:09,665 [main:58] - GENERATED VALUE OF TYPE Long = 4970063044206866764
2021-03-11 21:09:09,665 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:09,667 [main:67] - randomType = Short
2021-03-11 21:09:09,775 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:09,809 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@222b24dd]
2021-03-11 21:09:09,810 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]
2021-03-11 21:09:09,810 [main:78] - Generated call from random type = (30146).div(larg1).xor(larg2)
2021-03-11 21:09:09,811 [main:106] - GETTING Long from Int
2021-03-11 21:09:09,852 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]]
2021-03-11 21:09:09,852 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:09,853 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]
2021-03-11 21:09:09,853 [main:117] - GENERATED CALL = (iarg2).div(larg2).unaryPlus()
2021-03-11 21:09:09,853 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]]
2021-03-11 21:09:09,853 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:09,853 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]
2021-03-11 21:09:09,853 [main:117] - GENERATED CALL = (iarg2).toShort().toLong()
2021-03-11 21:09:09,853 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]]
2021-03-11 21:09:09,853 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:09,853 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:09,854 [main:117] - GENERATED CALL = (iarg2).toLong().and(larg2)
2021-03-11 21:09:09,854 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]]
2021-03-11 21:09:09,854 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:09,854 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]
2021-03-11 21:09:09,854 [main:117] - GENERATED CALL = (iarg2).toInt().minus(larg2)
2021-03-11 21:09:09,854 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]]
2021-03-11 21:09:09,854 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:09,946 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:09,947 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]
2021-03-11 21:09:09,947 [main:117] - GENERATED CALL = (iarg2).div(1071843014242244003).shl(iarg2)
2021-03-11 21:09:09,947 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Long.absoluteValue: kotlin.Long defined in kotlin.math[DeserializedPropertyDescriptor@212d84f6]]
2021-03-11 21:09:09,947 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:09,948 [main:117] - GENERATED CALL = (iarg2).toLong().absoluteValue
2021-03-11 21:09:09,948 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]]
2021-03-11 21:09:09,948 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:09,948 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]
2021-03-11 21:09:10,060 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:10,061 [main:117] - GENERATED CALL = (iarg2).toLong().coerceAtLeast(-5513103047502908926)
2021-03-11 21:09:10,061 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Long.rotateLeft(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@53e43e3a]]
2021-03-11 21:09:10,061 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:10,061 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Long.rotateLeft(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@53e43e3a]
2021-03-11 21:09:10,061 [main:117] - GENERATED CALL = (iarg2).toLong().rotateLeft(iarg2)
2021-03-11 21:09:10,061 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a58fe0c]]
2021-03-11 21:09:10,062 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:10,062 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a58fe0c]
2021-03-11 21:09:10,153 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:10,154 [main:117] - GENERATED CALL = (iarg2).toShort().times(-3504722803321226677)
2021-03-11 21:09:10,154 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]]
2021-03-11 21:09:10,154 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:10,154 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]
2021-03-11 21:09:10,155 [main:117] - GENERATED CALL = (iarg2).toInt().times(larg1)
2021-03-11 21:09:10,155 [main:61] - replacement of larg1 xor larg2 of type Long is (iarg2).toShort().times(-3504722803321226677)
2021-03-11 21:09:10,243 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:10,243 [main:66] - Compilation checking started
2021-03-11 21:09:10,605 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = barg1.inv()

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:10,608 [main:53] - replacing (barg1.inv(), Byte)
2021-03-11 21:09:10,609 [main:50] - replacing barg1.inv() Byte
2021-03-11 21:09:10,609 [main:54] - Getting value of type Byte
2021-03-11 21:09:10,698 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:10,699 [main:58] - GENERATED VALUE OF TYPE Byte = 118
2021-03-11 21:09:10,699 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:10,700 [main:67] - randomType = Double
2021-03-11 21:09:10,790 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:10,818 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]
2021-03-11 21:09:10,818 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeLowestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@6f869c9e]
2021-03-11 21:09:10,818 [main:78] - Generated call from random type = (0.09838225445085058).toByte().takeLowestOneBit()
2021-03-11 21:09:10,819 [main:106] - GETTING Byte from Short?
2021-03-11 21:09:10,849 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039], public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]]
2021-03-11 21:09:10,849 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:09:10,956 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:10,957 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:10,957 [main:117] - GENERATED CALL = (s4).compareTo(53).toByte()
2021-03-11 21:09:10,957 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], public final operator fun dec(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@725fc764]]
2021-03-11 21:09:10,957 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:09:10,957 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@725fc764]
2021-03-11 21:09:10,958 [main:117] - GENERATED CALL = (s4).toByte().dec()
2021-03-11 21:09:10,958 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]]
2021-03-11 21:09:10,958 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:10,958 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]
2021-03-11 21:09:10,958 [main:117] - GENERATED CALL = (s4).toDouble().toByte()
2021-03-11 21:09:10,958 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], public open fun toByte(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6b84f2be]]
2021-03-11 21:09:10,958 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:09:10,958 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6b84f2be]
2021-03-11 21:09:10,958 [main:117] - GENERATED CALL = (s4).toByte().toByte()
2021-03-11 21:09:10,958 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]]
2021-03-11 21:09:10,958 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:09:10,959 [main:149] - GENERATING call of type public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]
2021-03-11 21:09:11,062 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:11,064 [main:117] - GENERATED CALL = (s4).toByte().coerceAtMost(27)
2021-03-11 21:09:11,064 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]]
2021-03-11 21:09:11,064 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:09:11,064 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]
2021-03-11 21:09:11,064 [main:117] - GENERATED CALL = (s4).toByte().takeHighestOneBit()
2021-03-11 21:09:11,064 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.and(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@7102b336]]
2021-03-11 21:09:11,064 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:09:11,065 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.and(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@7102b336]
2021-03-11 21:09:11,065 [main:117] - GENERATED CALL = (s4).toByte().and(barg1)
2021-03-11 21:09:11,065 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]]
2021-03-11 21:09:11,065 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:11,065 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]
2021-03-11 21:09:11,066 [main:117] - GENERATED CALL = (s4).toFloat().toByte()
2021-03-11 21:09:11,066 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.xor(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@3a9e4a66]]
2021-03-11 21:09:11,066 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:09:11,066 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.xor(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@3a9e4a66]
2021-03-11 21:09:11,066 [main:117] - GENERATED CALL = (s4).toByte().xor(barg1)
2021-03-11 21:09:11,066 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@74213f3a]]
2021-03-11 21:09:11,066 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:09:11,067 [main:149] - GENERATING call of type public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@74213f3a]
2021-03-11 21:09:11,067 [main:117] - GENERATED CALL = (s4).toChar().toByte()
2021-03-11 21:09:11,067 [main:61] - replacement of barg1.inv() of type Byte is (s4).toByte().xor(barg1)
2021-03-11 21:09:11,160 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:11,160 [main:66] - Compilation checking started
2021-03-11 21:09:11,493 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:11,496 [main:53] - replacing (sarg2, Short)
2021-03-11 21:09:11,497 [main:50] - replacing sarg2 Short
2021-03-11 21:09:11,497 [main:54] - Getting value of type Short
2021-03-11 21:09:11,590 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:11,591 [main:58] - GENERATED VALUE OF TYPE Short = -19585
2021-03-11 21:09:11,591 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:11,788 [main:67] - randomType = ArrayList<Short>
2021-03-11 21:09:11,891 [main:302] - generating value of type = ArrayList<Short> false depth = 0
2021-03-11 21:09:11,988 [main:43] - GENERATING CALL OF fun <T> arrayListOf(elements: Short): ArrayList<Short> = TODO()
2021-03-11 21:09:11,990 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(elements: Short): ArrayList<Short> = TODO()
2021-03-11 21:09:12,094 [main:302] - generating value of type = Short true depth = 3
2021-03-11 21:09:12,095 [main:95] - GENERATED = arrayListOf<Short>(-13344)
2021-03-11 21:09:12,281 [main:149] - GENERATING call of type public open fun subList(fromIndex: kotlin.Int, toIndex: kotlin.Int): kotlin.collections.MutableList<kotlin.Short> defined in kotlin.collections.ArrayList[DeserializedSimpleFunctionDescriptor@1d7f197e]
2021-03-11 21:09:12,282 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun <T> kotlin.collections.MutableList<T>.removeLast(): T defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@2d899d50]
2021-03-11 21:09:12,283 [main:78] - Generated call from random type = (arrayListOf<Short>(-13344)).subList(iarg2, iarg1).removeLast()!!
2021-03-11 21:09:12,283 [main:106] - GETTING Short from Short?
2021-03-11 21:09:12,324 [main:113] - Case = [public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeLowestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@5318b279]]
2021-03-11 21:09:12,324 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4]
2021-03-11 21:09:12,325 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeLowestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@5318b279]
2021-03-11 21:09:12,325 [main:117] - GENERATED CALL = (s2).dec().takeLowestOneBit()
2021-03-11 21:09:12,325 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@1f9f550e]]
2021-03-11 21:09:12,325 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:12,326 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@1f9f550e]
2021-03-11 21:09:12,326 [main:117] - GENERATED CALL = (s2).toDouble().toShort()
2021-03-11 21:09:12,326 [main:113] - Case = [public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeHighestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@7a6d5fdf]]
2021-03-11 21:09:12,326 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4]
2021-03-11 21:09:12,326 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeHighestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@7a6d5fdf]
2021-03-11 21:09:12,327 [main:117] - GENERATED CALL = (s2).dec().takeHighestOneBit()
2021-03-11 21:09:12,327 [main:113] - Case = [public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.and(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ac441]]
2021-03-11 21:09:12,327 [main:149] - GENERATING call of type public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487]
2021-03-11 21:09:12,327 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.and(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ac441]
2021-03-11 21:09:12,328 [main:117] - GENERATED CALL = (s2).toShort().and(sarg1)
2021-03-11 21:09:12,328 [main:113] - Case = [public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.inv(): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ff195]]
2021-03-11 21:09:12,328 [main:149] - GENERATING call of type public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487]
2021-03-11 21:09:12,328 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.inv(): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ff195]
2021-03-11 21:09:12,328 [main:117] - GENERATED CALL = (s2).toShort().inv()
2021-03-11 21:09:12,329 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d]]
2021-03-11 21:09:12,329 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:09:12,329 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d]
2021-03-11 21:09:12,329 [main:117] - GENERATED CALL = (s2).toByte().toShort()
2021-03-11 21:09:12,329 [main:113] - Case = [public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.inv(): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ff195]]
2021-03-11 21:09:12,329 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4]
2021-03-11 21:09:12,329 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.inv(): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@228ff195]
2021-03-11 21:09:12,329 [main:117] - GENERATED CALL = (s2).dec().inv()
2021-03-11 21:09:12,330 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039], public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]]
2021-03-11 21:09:12,330 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:09:12,419 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:12,420 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:12,420 [main:117] - GENERATED CALL = (s2).compareTo(-37).toShort()
2021-03-11 21:09:12,421 [main:113] - Case = [public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4], public fun kotlin.Short.coerceAtMost(maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ec993d6]]
2021-03-11 21:09:12,421 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4]
2021-03-11 21:09:12,421 [main:149] - GENERATING call of type public fun kotlin.Short.coerceAtMost(maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ec993d6]
2021-03-11 21:09:12,421 [main:117] - GENERATED CALL = (s2).dec().coerceAtMost(sarg1)
2021-03-11 21:09:12,421 [main:113] - Case = [public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.or(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@486aa623]]
2021-03-11 21:09:12,421 [main:149] - GENERATING call of type public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487]
2021-03-11 21:09:12,421 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.or(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@486aa623]
2021-03-11 21:09:12,422 [main:117] - GENERATED CALL = (s2).toShort().or(sarg2)
2021-03-11 21:09:12,422 [main:61] - replacement of sarg2 of type Short is s2
2021-03-11 21:09:12,512 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:09:12,512 [main:66] - Compilation checking started
2021-03-11 21:09:12,801 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  s2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:12,803 [main:53] - replacing ((0xDC56DC56L shl 32), Long)
2021-03-11 21:09:12,804 [main:50] - replacing (0xDC56DC56L shl 32) Long
2021-03-11 21:09:12,804 [main:54] - Getting value of type Long
2021-03-11 21:09:12,897 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:12,898 [main:58] - GENERATED VALUE OF TYPE Long = -5206260048200299852
2021-03-11 21:09:12,899 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:12,900 [main:67] - randomType = Byte
2021-03-11 21:09:12,992 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:13,023 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:13,023 [main:149] - GENERATING call of type public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]
2021-03-11 21:09:13,023 [main:78] - Generated call from random type = (-86).toLong().inv()
2021-03-11 21:09:13,023 [main:61] - replacement of (0xDC56DC56L shl 32) of type Long is (-86).toLong().inv()
2021-03-11 21:09:13,113 [main:33] - Trying to replace Element(PARENTHESIZED) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:13,113 [main:66] - Compilation checking started
2021-03-11 21:09:13,450 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:13,453 [main:53] - replacing (32, Int)
2021-03-11 21:09:13,454 [main:50] - replacing 32 Int
2021-03-11 21:09:13,454 [main:54] - Getting value of type Int
2021-03-11 21:09:13,544 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:13,545 [main:58] - GENERATED VALUE OF TYPE Int = 1497773696
2021-03-11 21:09:13,545 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:13,546 [main:67] - randomType = Boolean
2021-03-11 21:09:13,639 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:13,651 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:09:13,752 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:13,753 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]
2021-03-11 21:09:13,753 [main:78] - Generated call from random type = (true).compareTo(false).coerceAtLeast(iarg2)
2021-03-11 21:09:13,754 [main:106] - GETTING Int from Long?
2021-03-11 21:09:13,792 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:09:13,792 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:13,881 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:13,882 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:09:13,883 [main:117] - GENERATED CALL = (l4).compareTo(71).inc()
2021-03-11 21:09:13,883 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@506e1d0f]]
2021-03-11 21:09:13,883 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:13,883 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@506e1d0f]
2021-03-11 21:09:13,883 [main:117] - GENERATED CALL = (l4).and(larg1).countLeadingZeroBits()
2021-03-11 21:09:13,883 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]]
2021-03-11 21:09:13,883 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:13,883 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]
2021-03-11 21:09:13,883 [main:117] - GENERATED CALL = (l4).toLong().countTrailingZeroBits()
2021-03-11 21:09:13,884 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]]
2021-03-11 21:09:13,884 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:13,884 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]
2021-03-11 21:09:13,972 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:13,973 [main:117] - GENERATED CALL = (l4).toShort().plus(49)
2021-03-11 21:09:13,973 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:09:13,973 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:13,973 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:09:13,973 [main:117] - GENERATED CALL = (l4).toInt().inc()
2021-03-11 21:09:13,973 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]]
2021-03-11 21:09:13,973 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:13,974 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]
2021-03-11 21:09:14,062 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:14,063 [main:117] - GENERATED CALL = (l4).toShort().div(-22)
2021-03-11 21:09:14,063 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@444f3fa7]]
2021-03-11 21:09:14,064 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:14,064 [main:117] - GENERATED CALL = (l4).toInt().sign
2021-03-11 21:09:14,064 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]]
2021-03-11 21:09:14,064 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:14,064 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]
2021-03-11 21:09:14,153 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:14,154 [main:117] - GENERATED CALL = (l4).toByte().compareTo(-125)
2021-03-11 21:09:14,154 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin public val kotlin.Long.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@1360523c]]
2021-03-11 21:09:14,154 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:14,154 [main:117] - GENERATED CALL = (l4).and(larg2).sign
2021-03-11 21:09:14,154 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]]
2021-03-11 21:09:14,154 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:14,243 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:14,244 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]
2021-03-11 21:09:14,244 [main:117] - GENERATED CALL = (l4).compareTo(96).rotateRight(iarg1)
2021-03-11 21:09:14,244 [main:61] - replacement of 32 of type Int is (l4).compareTo(71).inc()
2021-03-11 21:09:14,333 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:14,333 [main:66] - Compilation checking started
2021-03-11 21:09:14,593 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl (l4).compareTo(71).inc()) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:14,597 [main:53] - replacing (0x23A923A923A923A9, Long)
2021-03-11 21:09:14,598 [main:50] - replacing 0x23A923A923A923A9 Long
2021-03-11 21:09:14,598 [main:54] - Getting value of type Long
2021-03-11 21:09:14,718 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:14,719 [main:58] - GENERATED VALUE OF TYPE Long = 5550085058206880133
2021-03-11 21:09:14,719 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:14,722 [main:67] - randomType = Long?
2021-03-11 21:09:14,812 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:14,843 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:14,843 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@356a99a2]
2021-03-11 21:09:14,932 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:14,933 [main:78] - Generated call from random type = (-8428243708102288383)?.toByte().div(8171944693501822255)
2021-03-11 21:09:14,934 [main:106] - GETTING Long from Int
2021-03-11 21:09:14,963 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]]
2021-03-11 21:09:14,963 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:14,963 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]
2021-03-11 21:09:14,964 [main:117] - GENERATED CALL = (iarg2).toShort().toLong()
2021-03-11 21:09:14,964 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]]
2021-03-11 21:09:14,964 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:14,964 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]
2021-03-11 21:09:15,052 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:15,054 [main:117] - GENERATED CALL = (iarg2).compareTo(iarg2).plus(2824713675100766083)
2021-03-11 21:09:15,054 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:09:15,054 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:15,054 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:09:15,054 [main:117] - GENERATED CALL = (iarg2).div(larg2).dec()
2021-03-11 21:09:15,054 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]]
2021-03-11 21:09:15,054 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:15,054 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@748722bb]
2021-03-11 21:09:15,055 [main:117] - GENERATED CALL = (iarg2).compareTo(iarg2).times(larg2)
2021-03-11 21:09:15,055 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public open fun toLong(): kotlin.Long defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@41b9c30]]
2021-03-11 21:09:15,055 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:15,144 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:15,145 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@41b9c30]
2021-03-11 21:09:15,145 [main:117] - GENERATED CALL = (iarg2).div(0.9058917220457064).toLong()
2021-03-11 21:09:15,145 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Long.rotateLeft(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@53e43e3a]]
2021-03-11 21:09:15,145 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:15,145 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Long.rotateLeft(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@53e43e3a]
2021-03-11 21:09:15,234 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:15,235 [main:117] - GENERATED CALL = (iarg2).div(larg2).rotateLeft(-1752540108)
2021-03-11 21:09:15,235 [main:113] - Case = [@kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]]
2021-03-11 21:09:15,235 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]
2021-03-11 21:09:15,324 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:15,325 [main:117] - GENERATED CALL = (iarg2).rem(7909235621939343860)
2021-03-11 21:09:15,325 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:09:15,325 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:15,325 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:09:15,434 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:15,435 [main:117] - GENERATED CALL = (iarg2).div(larg2).rem(124)
2021-03-11 21:09:15,435 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun inc(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@48cf21d7]]
2021-03-11 21:09:15,435 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:15,435 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@48cf21d7]
2021-03-11 21:09:15,436 [main:117] - GENERATED CALL = (iarg2).toLong().inc()
2021-03-11 21:09:15,436 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]]
2021-03-11 21:09:15,436 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:15,436 [main:149] - GENERATING call of type public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]
2021-03-11 21:09:15,532 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:15,533 [main:117] - GENERATED CALL = (iarg2).div(larg2).coerceIn(2827583820180028293, larg2)
2021-03-11 21:09:15,533 [main:61] - replacement of 0x23A923A923A923A9 of type Long is (iarg2).div(larg2).dec()
2021-03-11 21:09:15,622 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:15,622 [main:66] - Compilation checking started
2021-03-11 21:09:15,937 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:15,939 [main:53] - replacing (0xDC56DC56L, Long)
2021-03-11 21:09:15,940 [main:50] - replacing 0xDC56DC56L Long
2021-03-11 21:09:15,940 [main:54] - Getting value of type Long
2021-03-11 21:09:16,035 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:16,035 [main:58] - GENERATED VALUE OF TYPE Long = -8496297990359222123
2021-03-11 21:09:16,036 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:16,380 [main:67] - randomType = Function1<ULong, ArrayList<UShort>>
2021-03-11 21:09:16,381 [main:106] - GETTING Long from Int?
2021-03-11 21:09:16,422 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a58fe0c]]
2021-03-11 21:09:16,422 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:16,422 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a58fe0c]
2021-03-11 21:09:16,422 [main:117] - GENERATED CALL = (i2).toShort().times(larg1)
2021-03-11 21:09:16,422 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]]
2021-03-11 21:09:16,422 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:16,423 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]
2021-03-11 21:09:16,423 [main:117] - GENERATED CALL = (i2).toLong().unaryPlus()
2021-03-11 21:09:16,423 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:09:16,423 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:16,423 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:09:16,423 [main:117] - GENERATED CALL = (i2).toLong().dec()
2021-03-11 21:09:16,423 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7f624377]]
2021-03-11 21:09:16,423 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:16,423 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7f624377]
2021-03-11 21:09:16,424 [main:117] - GENERATED CALL = (i2).toShort().rem(larg1)
2021-03-11 21:09:16,424 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]]
2021-03-11 21:09:16,424 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:16,424 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:16,424 [main:117] - GENERATED CALL = (i2).toLong().and(larg1)
2021-03-11 21:09:16,424 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]]
2021-03-11 21:09:16,424 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:16,424 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:16,425 [main:117] - GENERATED CALL = (i2).and(iarg1).div(larg1)
2021-03-11 21:09:16,425 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]]
2021-03-11 21:09:16,425 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:16,425 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]
2021-03-11 21:09:16,513 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:16,514 [main:117] - GENERATED CALL = (i2).div(larg1).coerceAtMost(-4966812451850157115)
2021-03-11 21:09:16,514 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]]
2021-03-11 21:09:16,514 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:16,604 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:16,605 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]
2021-03-11 21:09:16,605 [main:117] - GENERATED CALL = (i2).div(0.6748438474459212).toRawBits()
2021-03-11 21:09:16,605 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], @kotlin.SinceKotlin public fun kotlin.Double.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@917de8d]]
2021-03-11 21:09:16,605 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:16,694 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:16,695 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Double.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@917de8d]
2021-03-11 21:09:16,696 [main:117] - GENERATED CALL = (i2).div(0.9851284206971104).roundToLong()
2021-03-11 21:09:16,696 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Long): kotlin.ranges.LongRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4ad630d3], public open val start: kotlin.Long defined in kotlin.ranges.LongRange[DeserializedPropertyDescriptor@1b36803]]
2021-03-11 21:09:16,696 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Long): kotlin.ranges.LongRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4ad630d3]
2021-03-11 21:09:16,785 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:16,787 [main:117] - GENERATED CALL = (i2).rangeTo(3488907631696627703).start
2021-03-11 21:09:16,787 [main:61] - replacement of 0xDC56DC56L of type Long is (i2).toLong().and(larg1)
2021-03-11 21:09:16,874 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:16,875 [main:66] - Compilation checking started
2021-03-11 21:09:17,149 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = ((i2).toLong().and(larg1) shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:17,152 [main:53] - replacing ((0xB98AB98AL shl 32) + 0xB98AB98A, Long)
2021-03-11 21:09:17,153 [main:50] - replacing (0xB98AB98AL shl 32) + 0xB98AB98A Long
2021-03-11 21:09:17,153 [main:54] - Getting value of type Long
2021-03-11 21:09:17,250 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:17,250 [main:58] - GENERATED VALUE OF TYPE Long = -1701410977929433207
2021-03-11 21:09:17,251 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:17,253 [main:67] - randomType = Int
2021-03-11 21:09:17,362 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:17,393 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:17,393 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]
2021-03-11 21:09:17,393 [main:78] - Generated call from random type = (459135228).toLong().shl(iarg1)
2021-03-11 21:09:17,394 [main:106] - GETTING Long from Int
2021-03-11 21:09:17,424 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin public fun kotlin.Double.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@917de8d]]
2021-03-11 21:09:17,424 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:17,424 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Double.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@917de8d]
2021-03-11 21:09:17,424 [main:117] - GENERATED CALL = (iarg1).toDouble().roundToLong()
2021-03-11 21:09:17,424 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4722f673]]
2021-03-11 21:09:17,424 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:17,425 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4722f673]
2021-03-11 21:09:17,425 [main:117] - GENERATED CALL = (iarg1).toByte().plus(larg2)
2021-03-11 21:09:17,425 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]]
2021-03-11 21:09:17,425 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:17,425 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]
2021-03-11 21:09:17,425 [main:117] - GENERATED CALL = (iarg1).div(larg2).unaryPlus()
2021-03-11 21:09:17,425 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]]
2021-03-11 21:09:17,425 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:17,425 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]
2021-03-11 21:09:17,514 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:17,515 [main:117] - GENERATED CALL = (iarg1).toInt().rem(-2358542762364614115)
2021-03-11 21:09:17,515 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]]
2021-03-11 21:09:17,515 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:17,515 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]
2021-03-11 21:09:17,515 [main:117] - GENERATED CALL = (iarg1).toDouble().toRawBits()
2021-03-11 21:09:17,515 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]]
2021-03-11 21:09:17,515 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:17,516 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]
2021-03-11 21:09:17,606 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:17,607 [main:117] - GENERATED CALL = (iarg1).toLong().xor(-6506392272932289111)
2021-03-11 21:09:17,608 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun toLong(): kotlin.Long defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@41b9c30]]
2021-03-11 21:09:17,608 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:17,608 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@41b9c30]
2021-03-11 21:09:17,608 [main:117] - GENERATED CALL = (iarg1).toDouble().toLong()
2021-03-11 21:09:17,608 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]]
2021-03-11 21:09:17,608 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:17,699 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:17,700 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]
2021-03-11 21:09:17,700 [main:117] - GENERATED CALL = (iarg1).div(3190643354909051124).coerceAtMost(larg1)
2021-03-11 21:09:17,700 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Float.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@37dd50c2]]
2021-03-11 21:09:17,700 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:17,700 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Float.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@37dd50c2]
2021-03-11 21:09:17,701 [main:117] - GENERATED CALL = (iarg1).toFloat().roundToLong()
2021-03-11 21:09:17,701 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]]
2021-03-11 21:09:17,701 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:17,701 [main:149] - GENERATING call of type public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]
2021-03-11 21:09:17,701 [main:117] - GENERATED CALL = (iarg1).toChar().toLong()
2021-03-11 21:09:17,701 [main:61] - replacement of (0xB98AB98AL shl 32) + 0xB98AB98A of type Long is (iarg1).toDouble().toLong()
2021-03-11 21:09:17,792 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:17,792 [main:66] - Compilation checking started
2021-03-11 21:09:18,131 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:18,131 [main:53] - replacing (larg1, Long)
2021-03-11 21:09:18,131 [main:50] - replacing larg1 Long
2021-03-11 21:09:18,132 [main:54] - Getting value of type Long
2021-03-11 21:09:18,225 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:18,226 [main:58] - GENERATED VALUE OF TYPE Long = 3808065833924956246
2021-03-11 21:09:18,226 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:18,769 [main:67] - randomType = Function2<Set<Byte>, Triple<Char, HashSet<Function1<Boolean, UInt>>, Boolean>, Int>
2021-03-11 21:09:18,769 [main:61] - replacement of larg1 of type Long is 3808065833924956246
2021-03-11 21:09:18,862 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:09:18,864 [main:53] - replacing (i3, Int?)
2021-03-11 21:09:18,865 [main:50] - replacing i3 Int?
2021-03-11 21:09:18,865 [main:54] - Getting value of type Int?
2021-03-11 21:09:18,956 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:18,957 [main:58] - GENERATED VALUE OF TYPE Int? = 244082752
2021-03-11 21:09:18,957 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:19,256 [main:67] - randomType = Function1<UShort, ArrayDeque<Char>>
2021-03-11 21:09:19,257 [main:106] - GETTING Int? from Int?
2021-03-11 21:09:19,302 [main:113] - Case = [public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]]
2021-03-11 21:09:19,303 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]
2021-03-11 21:09:19,303 [main:117] - GENERATED CALL = (i2)?.unaryPlus()
2021-03-11 21:09:19,303 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]]
2021-03-11 21:09:19,303 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:19,303 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:09:19,413 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:19,414 [main:117] - GENERATED CALL = (i2)?.toShort().compareTo(-7)
2021-03-11 21:09:19,414 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]]
2021-03-11 21:09:19,414 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:19,414 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]
2021-03-11 21:09:19,415 [main:117] - GENERATED CALL = (i2)?.and(iarg1).countTrailingZeroBits()
2021-03-11 21:09:19,415 [main:113] - Case = [public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]]
2021-03-11 21:09:19,415 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]
2021-03-11 21:09:19,415 [main:117] - GENERATED CALL = (i2)?.inv()
2021-03-11 21:09:19,415 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]]
2021-03-11 21:09:19,415 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:19,415 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]
2021-03-11 21:09:19,520 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:19,521 [main:117] - GENERATED CALL = (i2)?.and(iarg1).minus(118)
2021-03-11 21:09:19,521 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@adba42a]]
2021-03-11 21:09:19,521 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:19,521 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@adba42a]
2021-03-11 21:09:19,522 [main:117] - GENERATED CALL = (i2)?.toFloat().toRawBits()
2021-03-11 21:09:19,522 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:09:19,522 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:19,522 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:09:19,522 [main:117] - GENERATED CALL = (i2)?.toInt().inc()
2021-03-11 21:09:19,522 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:09:19,522 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:19,523 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:09:19,611 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:19,612 [main:117] - GENERATED CALL = (i2)?.compareTo(iarg1).shr(-685543895)
2021-03-11 21:09:19,612 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]]
2021-03-11 21:09:19,612 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:19,612 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:09:19,612 [main:117] - GENERATED CALL = (i2)?.toInt().shl(iarg1)
2021-03-11 21:09:19,612 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]]
2021-03-11 21:09:19,612 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:19,700 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:19,701 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]
2021-03-11 21:09:19,701 [main:117] - GENERATED CALL = (i2)?.div(0.5340017921451794).toInt()
2021-03-11 21:09:19,701 [main:61] - replacement of i3 of type Int? is (i2)?.toInt().inc()
2021-03-11 21:09:19,790 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:19,790 [main:66] - Compilation checking started
2021-03-11 21:09:20,034 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if ((i2)?.toInt().inc() != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:20,037 [main:53] - replacing (barg1, Byte)
2021-03-11 21:09:20,038 [main:50] - replacing barg1 Byte
2021-03-11 21:09:20,038 [main:54] - Getting value of type Byte
2021-03-11 21:09:20,127 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:20,128 [main:58] - GENERATED VALUE OF TYPE Byte = -78
2021-03-11 21:09:20,128 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:20,130 [main:67] - randomType = Int
2021-03-11 21:09:20,218 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:20,257 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:20,361 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:20,362 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]
2021-03-11 21:09:20,362 [main:78] - Generated call from random type = (-1668203291).div(0.08675039327629874).toByte()
2021-03-11 21:09:20,362 [main:61] - replacement of barg1 of type Byte is (-1668203291).div(0.08675039327629874).toByte()
2021-03-11 21:09:20,452 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:20,452 [main:66] - Compilation checking started
2021-03-11 21:09:20,788 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:20,789 [main:53] - replacing (b1, Byte?)
2021-03-11 21:09:20,789 [main:50] - replacing b1 Byte?
2021-03-11 21:09:20,789 [main:54] - Getting value of type Byte?
2021-03-11 21:09:20,885 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:20,886 [main:58] - GENERATED VALUE OF TYPE Byte? = 111
2021-03-11 21:09:20,886 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:20,887 [main:67] - randomType = ULong
2021-03-11 21:09:20,975 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:09:21,006 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@781c63d1]
2021-03-11 21:09:21,007 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@6c6c6806]
2021-03-11 21:09:21,007 [main:78] - Generated call from random type = (8405219459308999855.toULong()).toUShort().toByte()
2021-03-11 21:09:21,007 [main:61] - replacement of b1 of type Byte? is 111
2021-03-11 21:09:21,095 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:09:21,098 [main:53] - replacing ("fail: Long.or", String)
2021-03-11 21:09:21,099 [main:50] - replacing "fail: Long.or" String
2021-03-11 21:09:21,099 [main:54] - Getting value of type String
2021-03-11 21:09:21,189 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:21,190 [main:58] - GENERATED VALUE OF TYPE String = "abodr"
2021-03-11 21:09:21,190 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:21,287 [main:67] - randomType = String?
2021-03-11 21:09:21,393 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:21,420 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Any?): kotlin.String defined in kotlin.String[DeserializedSimpleFunctionDescriptor@38afaf10]
2021-03-11 21:09:21,517 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:21,518 [main:149] - GENERATING call of type public fun kotlin.String.replaceBefore(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@38f36e58]
2021-03-11 21:09:21,607 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:09:21,695 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:21,784 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:21,785 [main:78] - Generated call from random type = ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
2021-03-11 21:09:21,785 [main:61] - replacement of "fail: Long.or" of type String is ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
2021-03-11 21:09:21,873 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:21,874 [main:66] - Compilation checking started
2021-03-11 21:09:22,228 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:22,230 [main:53] - replacing (0xFFFFFFFFL shl 32, Long)
2021-03-11 21:09:22,231 [main:50] - replacing 0xFFFFFFFFL shl 32 Long
2021-03-11 21:09:22,231 [main:54] - Getting value of type Long
2021-03-11 21:09:22,323 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:22,324 [main:58] - GENERATED VALUE OF TYPE Long = 653271236391270981
2021-03-11 21:09:22,324 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:22,438 [main:67] - randomType = Boolean?
2021-03-11 21:09:22,532 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:22,546 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:09:22,637 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:22,638 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]
2021-03-11 21:09:22,638 [main:78] - Generated call from random type = (false)?.compareTo(true).plus(larg2)
2021-03-11 21:09:22,639 [main:106] - GETTING Long from Int
2021-03-11 21:09:22,669 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]]
2021-03-11 21:09:22,669 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:22,669 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:09:22,669 [main:117] - GENERATED CALL = (iarg2).toInt().toLong()
2021-03-11 21:09:22,669 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]]
2021-03-11 21:09:22,669 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:22,670 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]
2021-03-11 21:09:22,670 [main:117] - GENERATED CALL = (iarg2).toLong().takeLowestOneBit()
2021-03-11 21:09:22,670 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Long.absoluteValue: kotlin.Long defined in kotlin.math[DeserializedPropertyDescriptor@212d84f6]]
2021-03-11 21:09:22,670 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:22,670 [main:117] - GENERATED CALL = (iarg2).div(larg2).absoluteValue
2021-03-11 21:09:22,670 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]]
2021-03-11 21:09:22,670 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:22,760 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:22,761 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]
2021-03-11 21:09:22,850 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:22,852 [main:117] - GENERATED CALL = (iarg2).div(-5174878445901976815).coerceAtMost(-832422958057275605)
2021-03-11 21:09:22,852 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:09:22,852 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:22,852 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:09:22,942 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:22,943 [main:117] - GENERATED CALL = (iarg2).toLong().rem(-15)
2021-03-11 21:09:22,943 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]]
2021-03-11 21:09:22,943 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:22,943 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]
2021-03-11 21:09:22,944 [main:117] - GENERATED CALL = (iarg2).compareTo(iarg2).rem(larg1)
2021-03-11 21:09:22,944 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]]
2021-03-11 21:09:22,944 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:22,944 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]
2021-03-11 21:09:23,033 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:23,034 [main:117] - GENERATED CALL = (iarg2).div(larg1).plus(107)
2021-03-11 21:09:23,034 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]]
2021-03-11 21:09:23,034 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:23,126 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:23,127 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]
2021-03-11 21:09:23,127 [main:117] - GENERATED CALL = (iarg2).div(0.6174269738851461).toBits()
2021-03-11 21:09:23,127 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]]
2021-03-11 21:09:23,127 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:23,127 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]
2021-03-11 21:09:23,217 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:23,218 [main:117] - GENERATED CALL = (iarg2).div(larg2).or(-570565548750064406)
2021-03-11 21:09:23,218 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]]
2021-03-11 21:09:23,218 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:23,218 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toRawBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@794e1391]
2021-03-11 21:09:23,219 [main:117] - GENERATED CALL = (iarg2).toDouble().toRawBits()
2021-03-11 21:09:23,219 [main:61] - replacement of 0xFFFFFFFFL shl 32 of type Long is (iarg2).toInt().toLong()
2021-03-11 21:09:23,309 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:23,309 [main:66] - Compilation checking started
2021-03-11 21:09:23,652 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:23,654 [main:53] - replacing (0xFDDEFDDE.toInt(), Int)
2021-03-11 21:09:23,655 [main:50] - replacing 0xFDDEFDDE.toInt() Int
2021-03-11 21:09:23,655 [main:54] - Getting value of type Int
2021-03-11 21:09:23,748 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:23,749 [main:58] - GENERATED VALUE OF TYPE Int = -429114530
2021-03-11 21:09:23,749 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:23,750 [main:67] - randomType = Byte
2021-03-11 21:09:23,840 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:23,874 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:23,874 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@51f1ee47]
2021-03-11 21:09:23,875 [main:78] - Generated call from random type = (-9).toLong().toInt()
2021-03-11 21:09:23,875 [main:61] - replacement of 0xFDDEFDDE.toInt() of type Int is (-9).toLong().toInt()
2021-03-11 21:09:23,964 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:23,964 [main:66] - Compilation checking started
2021-03-11 21:09:24,284 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:24,288 [main:53] - replacing (l3 != (iarg1).toDouble().toLong(), Boolean)
2021-03-11 21:09:24,289 [main:50] - replacing l3 != (iarg1).toDouble().toLong() Boolean
2021-03-11 21:09:24,290 [main:54] - Getting value of type Boolean
2021-03-11 21:09:24,386 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:24,387 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:09:24,387 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:24,519 [main:67] - randomType = UInt?
2021-03-11 21:09:24,625 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:09:24,659 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@1d28066e]
2021-03-11 21:09:24,750 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:24,750 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@31585973]
2021-03-11 21:09:24,841 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:24,842 [main:78] - Generated call from random type = (1876797627.toUInt())?.equals("ztqlh").xor(false)
2021-03-11 21:09:24,843 [main:106] - GETTING Boolean from Long?
2021-03-11 21:09:24,874 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:09:24,874 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:09:24,964 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:24,965 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:09:24,965 [main:117] - GENERATED CALL = (l2).div(0.4060867928278159).isInfinite()
2021-03-11 21:09:24,965 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]]
2021-03-11 21:09:24,965 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:09:24,966 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]
2021-03-11 21:09:24,966 [main:117] - GENERATED CALL = (l2).toChar().isLetter()
2021-03-11 21:09:24,966 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]]
2021-03-11 21:09:24,966 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:09:24,966 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]
2021-03-11 21:09:24,966 [main:117] - GENERATED CALL = (l2).toChar().isHighSurrogate()
2021-03-11 21:09:24,966 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:09:24,966 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:09:24,966 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:09:24,966 [main:117] - GENERATED CALL = (l2).toChar().isWhitespace()
2021-03-11 21:09:24,966 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]]
2021-03-11 21:09:24,966 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:09:24,967 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]
2021-03-11 21:09:24,967 [main:117] - GENERATED CALL = (l2).toChar().isDigit()
2021-03-11 21:09:24,967 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:09:24,967 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:24,967 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:09:24,967 [main:117] - GENERATED CALL = (l2).toDouble().isInfinite()
2021-03-11 21:09:24,967 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:09:24,967 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:09:25,057 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:25,059 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:09:25,148 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:25,149 [main:117] - GENERATED CALL = (l2).div(0.6913783076291015).equals("mqhen")
2021-03-11 21:09:25,149 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@31585973]]
2021-03-11 21:09:25,149 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:09:25,239 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:25,240 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@31585973]
2021-03-11 21:09:25,330 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:25,331 [main:117] - GENERATED CALL = (l2).equals("dmeah").xor(false)
2021-03-11 21:09:25,331 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]]
2021-03-11 21:09:25,331 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:25,331 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]
2021-03-11 21:09:25,331 [main:117] - GENERATED CALL = (l2).toFloat().isInfinite()
2021-03-11 21:09:25,331 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]]
2021-03-11 21:09:25,331 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:25,331 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]
2021-03-11 21:09:25,332 [main:117] - GENERATED CALL = (l2).toFloat().isNaN()
2021-03-11 21:09:25,332 [main:61] - replacement of l3 != (iarg1).toDouble().toLong() of type Boolean is (l2).toFloat().isInfinite()
2021-03-11 21:09:25,424 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:25,424 [main:66] - Compilation checking started
2021-03-11 21:09:25,709 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if ((l2).toFloat().isInfinite()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:25,712 [main:53] - replacing (sarg1 or  sarg2, Short)
2021-03-11 21:09:25,712 [main:50] - replacing sarg1 or  sarg2 Short
2021-03-11 21:09:25,712 [main:54] - Getting value of type Short
2021-03-11 21:09:25,803 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:25,804 [main:58] - GENERATED VALUE OF TYPE Short = 25365
2021-03-11 21:09:25,804 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:26,008 [main:67] - randomType = ArrayList<Long?>?
2021-03-11 21:09:26,098 [main:302] - generating value of type = ArrayList<Long?> false depth = 0
2021-03-11 21:09:26,192 [main:43] - GENERATING CALL OF fun <T> arrayListOf(): ArrayList<Long?> = TODO()
2021-03-11 21:09:26,194 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(): ArrayList<Long?> = TODO()
2021-03-11 21:09:26,287 [main:95] - GENERATED = arrayListOf<Long?>()
2021-03-11 21:09:26,414 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Long? defined in kotlin.collections.ArrayList[DeserializedSimpleFunctionDescriptor@1807c426]
2021-03-11 21:09:26,504 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:26,505 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:26,505 [main:78] - Generated call from random type = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
2021-03-11 21:09:26,505 [main:61] - replacement of sarg1 or  sarg2 of type Short is (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
2021-03-11 21:09:26,595 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(POSTFIX_EXPRESSION)
2021-03-11 21:09:26,595 [main:66] - Compilation checking started
2021-03-11 21:09:27,107 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:27,110 [main:53] - replacing (0xDC56DC56, Long)
2021-03-11 21:09:27,112 [main:50] - replacing 0xDC56DC56 Long
2021-03-11 21:09:27,112 [main:54] - Getting value of type Long
2021-03-11 21:09:27,233 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:27,234 [main:58] - GENERATED VALUE OF TYPE Long = -1963182466775105221
2021-03-11 21:09:27,234 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:27,237 [main:67] - randomType = String
2021-03-11 21:09:27,364 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:27,409 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@347afa00]
2021-03-11 21:09:27,579 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:27,582 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:27,582 [main:78] - Generated call from random type = ("vdhqh").compareTo("ipylk").div(larg1)
2021-03-11 21:09:27,584 [main:106] - GETTING Long from Int?
2021-03-11 21:09:27,660 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:09:27,660 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:27,661 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:09:27,661 [main:117] - GENERATED CALL = (i4).toLong().dec()
2021-03-11 21:09:27,661 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]]
2021-03-11 21:09:27,661 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:27,661 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]
2021-03-11 21:09:27,661 [main:117] - GENERATED CALL = (i4).toDouble().toBits()
2021-03-11 21:09:27,661 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]]
2021-03-11 21:09:27,661 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:27,662 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]
2021-03-11 21:09:27,662 [main:117] - GENERATED CALL = (i4).toLong().unaryPlus()
2021-03-11 21:09:27,662 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun div(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2971cea9]]
2021-03-11 21:09:27,662 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:27,662 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2971cea9]
2021-03-11 21:09:27,790 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:27,792 [main:117] - GENERATED CALL = (i4).div(larg1).div(-54)
2021-03-11 21:09:27,793 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]]
2021-03-11 21:09:27,793 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:27,929 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:27,931 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:09:27,931 [main:117] - GENERATED CALL = (i4).compareTo(1141086186).toLong()
2021-03-11 21:09:27,931 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@131b016c]]
2021-03-11 21:09:27,931 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:27,931 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@131b016c]
2021-03-11 21:09:28,047 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:28,050 [main:117] - GENERATED CALL = (i4).toByte().rem(-5315353242868042219)
2021-03-11 21:09:28,050 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@7b338d8e]]
2021-03-11 21:09:28,050 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:28,050 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@7b338d8e]
2021-03-11 21:09:28,051 [main:117] - GENERATED CALL = (i4).toByte().times(larg1)
2021-03-11 21:09:28,051 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]]
2021-03-11 21:09:28,051 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:28,051 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]
2021-03-11 21:09:28,171 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:28,172 [main:117] - GENERATED CALL = (i4).div(larg1).plus(-126)
2021-03-11 21:09:28,173 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]]
2021-03-11 21:09:28,173 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:28,173 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]
2021-03-11 21:09:28,284 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:28,286 [main:117] - GENERATED CALL = (i4).toInt().rem(6092633364030328885)
2021-03-11 21:09:28,286 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]]
2021-03-11 21:09:28,286 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:28,405 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:28,407 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@364e3a12]
2021-03-11 21:09:28,408 [main:117] - GENERATED CALL = (i4).div(-2394227313577622119).unaryPlus()
2021-03-11 21:09:28,408 [main:61] - replacement of 0xDC56DC56 of type Long is (i4).toDouble().toBits()
2021-03-11 21:09:28,559 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:28,560 [main:66] - Compilation checking started
2021-03-11 21:09:29,017 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + (i4).toDouble().toBits() // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:29,018 [main:53] - replacing (b4 != 0x23.toByte(), Boolean)
2021-03-11 21:09:29,018 [main:50] - replacing b4 != 0x23.toByte() Boolean
2021-03-11 21:09:29,018 [main:54] - Getting value of type Boolean
2021-03-11 21:09:29,124 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:29,125 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:09:29,125 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:29,128 [main:67] - randomType = Int
2021-03-11 21:09:29,235 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:29,279 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:09:29,378 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:29,378 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@31585973]
2021-03-11 21:09:29,475 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:29,476 [main:78] - Generated call from random type = (1823167307).equals("qnaul").xor(true)
2021-03-11 21:09:29,476 [main:61] - replacement of b4 != 0x23.toByte() of type Boolean is true
2021-03-11 21:09:29,572 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-11 21:09:29,575 [main:53] - replacing (0xFDDEFDDEL, Long)
2021-03-11 21:09:29,576 [main:50] - replacing 0xFDDEFDDEL Long
2021-03-11 21:09:29,576 [main:54] - Getting value of type Long
2021-03-11 21:09:29,672 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:29,673 [main:58] - GENERATED VALUE OF TYPE Long = -4713244135186065310
2021-03-11 21:09:29,674 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:29,676 [main:67] - randomType = Char
2021-03-11 21:09:29,772 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:09:29,791 [main:149] - GENERATING call of type public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]
2021-03-11 21:09:29,792 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@598ffbc8]
2021-03-11 21:09:29,792 [main:78] - Generated call from random type = ('캮').toLong().ushr(iarg2)
2021-03-11 21:09:29,792 [main:61] - replacement of 0xFDDEFDDEL of type Long is ('캮').toLong().ushr(iarg2)
2021-03-11 21:09:29,904 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:29,905 [main:66] - Compilation checking started
2021-03-11 21:09:30,356 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + (i4).toDouble().toBits() // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:30,357 [main:53] - replacing (s2 != 0xFDDE.toShort(), Boolean)
2021-03-11 21:09:30,357 [main:50] - replacing s2 != 0xFDDE.toShort() Boolean
2021-03-11 21:09:30,357 [main:54] - Getting value of type Boolean
2021-03-11 21:09:30,470 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:30,472 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:09:30,472 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:30,576 [main:67] - randomType = UShort
2021-03-11 21:09:30,671 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:09:30,699 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@77b87951]
2021-03-11 21:09:30,700 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:09:30,700 [main:78] - Generated call from random type = (8384.toUShort()).toDouble().isFinite()
2021-03-11 21:09:30,700 [main:61] - replacement of s2 != 0xFDDE.toShort() of type Boolean is (8384.toUShort()).toDouble().isFinite()
2021-03-11 21:09:30,795 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:30,798 [main:53] - replacing ("fail: Short.inv", String)
2021-03-11 21:09:30,799 [main:50] - replacing "fail: Short.inv" String
2021-03-11 21:09:30,799 [main:54] - Getting value of type String
2021-03-11 21:09:30,895 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:30,896 [main:58] - GENERATED VALUE OF TYPE String = "qqtsi"
2021-03-11 21:09:30,896 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:31,456 [main:67] - randomType = Function2<Short, UShort, List<ArrayList<HashSet<Double>>>>
2021-03-11 21:09:31,457 [main:106] - GETTING String from Int?
2021-03-11 21:09:31,489 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:09:31,489 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:31,489 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:09:31,490 [main:117] - GENERATED CALL = (i3).toChar().titlecase()
2021-03-11 21:09:31,490 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:09:31,490 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:31,490 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:31,490 [main:117] - GENERATED CALL = (i3).div(larg2).toString(iarg1)
2021-03-11 21:09:31,490 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:09:31,490 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:31,490 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:09:31,586 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:31,587 [main:117] - GENERATED CALL = (i3).toChar().plus("xulfj")
2021-03-11 21:09:31,587 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:31,587 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:31,588 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:31,588 [main:117] - GENERATED CALL = (i3).toInt().toString(iarg1)
2021-03-11 21:09:31,588 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:09:31,588 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:31,588 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:09:31,685 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:31,686 [main:117] - GENERATED CALL = (i3).toShort().toString(-1954861738)
2021-03-11 21:09:31,686 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:09:31,686 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:31,687 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:09:31,787 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:31,788 [main:117] - GENERATED CALL = (i3).toByte().toString(617430961)
2021-03-11 21:09:31,788 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:31,788 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:31,788 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:31,788 [main:117] - GENERATED CALL = (i3).compareTo(iarg2).toString(iarg2)
2021-03-11 21:09:31,788 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:09:31,788 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:31,789 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:09:31,789 [main:117] - GENERATED CALL = (i3).toChar().uppercase()
2021-03-11 21:09:31,789 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:09:31,789 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:31,789 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:31,884 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:31,886 [main:117] - GENERATED CALL = (i3).toLong().toString(1147819945)
2021-03-11 21:09:31,886 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:31,886 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:31,886 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:31,982 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:31,983 [main:117] - GENERATED CALL = (i3).and(iarg2).toString(717428802)
2021-03-11 21:09:31,984 [main:61] - replacement of "fail: Short.inv" of type String is (i3).toChar().uppercase()
2021-03-11 21:09:32,077 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:32,077 [main:66] - Compilation checking started
2021-03-11 21:09:32,450 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + (i4).toDouble().toBits() // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:32,454 [main:53] - replacing (i1, Int?)
2021-03-11 21:09:32,456 [main:50] - replacing i1 Int?
2021-03-11 21:09:32,456 [main:54] - Getting value of type Int?
2021-03-11 21:09:32,563 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:32,564 [main:58] - GENERATED VALUE OF TYPE Int? = 1085440936
2021-03-11 21:09:32,564 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:32,672 [main:67] - randomType = ArrayList<UInt>
2021-03-11 21:09:32,785 [main:302] - generating value of type = ArrayList<UInt> false depth = 0
2021-03-11 21:09:32,885 [main:43] - GENERATING CALL OF fun <T> arrayListOf(elements: UInt): ArrayList<UInt> = TODO()
2021-03-11 21:09:32,889 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(elements: UInt): ArrayList<UInt> = TODO()
2021-03-11 21:09:32,988 [main:302] - generating value of type = UInt true depth = 3
2021-03-11 21:09:32,989 [main:95] - GENERATED = arrayListOf<UInt>(1434698390.toUInt())
2021-03-11 21:09:33,108 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5751ecf4]
2021-03-11 21:09:33,108 [main:78] - Generated call from random type = (arrayListOf<UInt>(1434698390.toUInt())).size.takeHighestOneBit()
2021-03-11 21:09:33,109 [main:106] - GETTING Int? from Int?
2021-03-11 21:09:33,140 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]]
2021-03-11 21:09:33,141 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:33,141 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]
2021-03-11 21:09:33,141 [main:117] - GENERATED CALL = (i4)?.and(iarg2).inv()
2021-03-11 21:09:33,141 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]]
2021-03-11 21:09:33,141 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:33,236 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:33,238 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]
2021-03-11 21:09:33,239 [main:117] - GENERATED CALL = (i4)?.and(1171457937).or(iarg2)
2021-03-11 21:09:33,239 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]]
2021-03-11 21:09:33,239 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:33,239 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]
2021-03-11 21:09:33,347 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:33,349 [main:117] - GENERATED CALL = (i4)?.toByte().minus(-120)
2021-03-11 21:09:33,349 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@12103546]]
2021-03-11 21:09:33,349 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:33,349 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@12103546]
2021-03-11 21:09:33,349 [main:117] - GENERATED CALL = (i4)?.toByte().unaryPlus()
2021-03-11 21:09:33,349 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:09:33,349 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:33,349 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:09:33,445 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:33,447 [main:117] - GENERATED CALL = (i4)?.toInt().shr(1716355293)
2021-03-11 21:09:33,447 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5db6009b]]
2021-03-11 21:09:33,447 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:33,447 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5db6009b]
2021-03-11 21:09:33,543 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:33,545 [main:117] - GENERATED CALL = (i4)?.toShort().minus(-30)
2021-03-11 21:09:33,545 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60337d73]]
2021-03-11 21:09:33,545 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:33,545 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60337d73]
2021-03-11 21:09:33,642 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:33,643 [main:117] - GENERATED CALL = (i4)?.toInt().div(111)
2021-03-11 21:09:33,643 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]]
2021-03-11 21:09:33,643 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:33,643 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]
2021-03-11 21:09:33,737 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:33,738 [main:117] - GENERATED CALL = (i4)?.toByte().times(-33)
2021-03-11 21:09:33,739 [main:113] - Case = [public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]]
2021-03-11 21:09:33,739 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]
2021-03-11 21:09:33,832 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:33,833 [main:117] - GENERATED CALL = (i4)?.minus(-50)
2021-03-11 21:09:33,833 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]]
2021-03-11 21:09:33,833 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:33,834 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:09:33,834 [main:117] - GENERATED CALL = (i4)?.toInt().shl(iarg2)
2021-03-11 21:09:33,834 [main:61] - replacement of i1 of type Int? is (i4)?.toInt().shl(iarg2)
2021-03-11 21:09:33,927 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:33,927 [main:66] - Compilation checking started
2021-03-11 21:09:34,222 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if ((i4)?.toInt().shl(iarg2) != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + (i4).toDouble().toBits() // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:34,226 [main:53] - replacing (larg1, Long)
2021-03-11 21:09:34,226 [main:50] - replacing larg1 Long
2021-03-11 21:09:34,226 [main:54] - Getting value of type Long
2021-03-11 21:09:34,322 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:34,323 [main:58] - GENERATED VALUE OF TYPE Long = 5292390412731654395
2021-03-11 21:09:34,323 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:34,326 [main:67] - randomType = Byte
2021-03-11 21:09:34,421 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:34,458 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:34,458 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@41b9c30]
2021-03-11 21:09:34,459 [main:78] - Generated call from random type = (1).toDouble().toLong()
2021-03-11 21:09:34,459 [main:106] - GETTING Long from Int?
2021-03-11 21:09:34,498 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun toLong(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1123c95f]]
2021-03-11 21:09:34,498 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:34,498 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1123c95f]
2021-03-11 21:09:34,499 [main:117] - GENERATED CALL = (i3).toLong().toLong()
2021-03-11 21:09:34,499 [main:113] - Case = [public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]]
2021-03-11 21:09:34,499 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:09:34,499 [main:117] - GENERATED CALL = (i3).toLong()
2021-03-11 21:09:34,499 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]]
2021-03-11 21:09:34,499 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:34,499 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]
2021-03-11 21:09:34,595 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:34,596 [main:117] - GENERATED CALL = (i3).and(iarg1).rem(4352735891204191693)
2021-03-11 21:09:34,596 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]]
2021-03-11 21:09:34,596 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:34,694 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:34,696 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:34,696 [main:117] - GENERATED CALL = (i3).div(8357527454742493458).and(larg1)
2021-03-11 21:09:34,696 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]]
2021-03-11 21:09:34,696 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:34,696 [main:149] - GENERATING call of type public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]
2021-03-11 21:09:34,696 [main:117] - GENERATED CALL = (i3).toLong().coerceIn(larg1, larg2)
2021-03-11 21:09:34,696 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Long): kotlin.ranges.LongRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4ad630d3], public final val last: kotlin.Long defined in kotlin.ranges.LongRange[DeserializedPropertyDescriptor@430aedd2]]
2021-03-11 21:09:34,697 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Long): kotlin.ranges.LongRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4ad630d3]
2021-03-11 21:09:34,697 [main:117] - GENERATED CALL = (i3).rangeTo(larg2).last
2021-03-11 21:09:34,697 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]]
2021-03-11 21:09:34,697 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:34,697 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:34,697 [main:117] - GENERATED CALL = (i3).and(iarg2).div(larg2)
2021-03-11 21:09:34,697 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]]
2021-03-11 21:09:34,697 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:34,697 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]
2021-03-11 21:09:34,698 [main:117] - GENERATED CALL = (i3).toLong().or(larg2)
2021-03-11 21:09:34,698 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:09:34,698 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:34,698 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:09:34,792 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:34,794 [main:117] - GENERATED CALL = (i3).div(larg1).rem(116)
2021-03-11 21:09:34,794 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]]
2021-03-11 21:09:34,794 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:34,794 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:09:34,794 [main:117] - GENERATED CALL = (i3).compareTo(iarg2).toLong()
2021-03-11 21:09:34,794 [main:61] - replacement of larg1 of type Long is (1).toDouble().toLong()
2021-03-11 21:09:34,888 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:34,888 [main:66] - Compilation checking started
2021-03-11 21:09:35,242 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + (i4).toDouble().toBits() // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != ((iarg2).toInt().toLong()) + 0xDC56DC56) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:35,247 [main:53] - replacing (((iarg2).toInt().toLong()) + 0xDC56DC56, Long)
2021-03-11 21:09:35,248 [main:50] - replacing ((iarg2).toInt().toLong()) + 0xDC56DC56 Long
2021-03-11 21:09:35,248 [main:54] - Getting value of type Long
2021-03-11 21:09:35,355 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:35,356 [main:58] - GENERATED VALUE OF TYPE Long = 8407819271876184467
2021-03-11 21:09:35,356 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:35,358 [main:67] - randomType = UInt
2021-03-11 21:09:35,470 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:09:35,500 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@6cd51947]
2021-03-11 21:09:35,500 [main:78] - Generated call from random type = (1922046010.toUInt()).toLong()
2021-03-11 21:09:35,501 [main:106] - GETTING Long from Long?
2021-03-11 21:09:35,533 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]]
2021-03-11 21:09:35,533 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:35,626 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:35,627 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]
2021-03-11 21:09:35,628 [main:117] - GENERATED CALL = (l5).compareTo(-23).minus(larg1)
2021-03-11 21:09:35,628 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]]
2021-03-11 21:09:35,628 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:35,628 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:09:35,628 [main:117] - GENERATED CALL = (l5).toInt().toLong()
2021-03-11 21:09:35,628 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]]
2021-03-11 21:09:35,628 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:35,723 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:35,724 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]
2021-03-11 21:09:35,724 [main:117] - GENERATED CALL = (l5).compareTo(16).plus(larg1)
2021-03-11 21:09:35,725 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]]
2021-03-11 21:09:35,725 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:35,725 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4f1f569a]
2021-03-11 21:09:35,725 [main:117] - GENERATED CALL = (l5).toLong().xor(larg2)
2021-03-11 21:09:35,725 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@2e04d682]]
2021-03-11 21:09:35,725 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:35,725 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@2e04d682]
2021-03-11 21:09:35,725 [main:117] - GENERATED CALL = (l5).toShort().plus(larg1)
2021-03-11 21:09:35,725 [main:113] - Case = [public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]]
2021-03-11 21:09:35,725 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@b2a978b]
2021-03-11 21:09:35,726 [main:117] - GENERATED CALL = (l5).unaryMinus()
2021-03-11 21:09:35,726 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]]
2021-03-11 21:09:35,726 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:35,726 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]
2021-03-11 21:09:35,726 [main:117] - GENERATED CALL = (l5).toLong().rotateRight(iarg2)
2021-03-11 21:09:35,726 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]]
2021-03-11 21:09:35,726 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:35,726 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]
2021-03-11 21:09:35,820 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:35,821 [main:117] - GENERATED CALL = (l5).toInt().minus(-4841105361201164005)
2021-03-11 21:09:35,821 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]]
2021-03-11 21:09:35,821 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:35,821 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]
2021-03-11 21:09:35,821 [main:117] - GENERATED CALL = (l5).toShort().toLong()
2021-03-11 21:09:35,821 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]]
2021-03-11 21:09:35,822 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:35,822 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]
2021-03-11 21:09:35,822 [main:117] - GENERATED CALL = (l5).and(larg2).shl(iarg2)
2021-03-11 21:09:35,822 [main:61] - replacement of ((iarg2).toInt().toLong()) + 0xDC56DC56 of type Long is 8407819271876184467
2021-03-11 21:09:35,915 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:09:35,915 [main:66] - Compilation checking started
2021-03-11 21:09:36,295 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + (i4).toDouble().toBits() // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:36,298 [main:53] - replacing (0xDC56DC56.toInt(), Int)
2021-03-11 21:09:36,300 [main:50] - replacing 0xDC56DC56.toInt() Int
2021-03-11 21:09:36,300 [main:54] - Getting value of type Int
2021-03-11 21:09:36,407 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:36,408 [main:58] - GENERATED VALUE OF TYPE Int = -1465184655
2021-03-11 21:09:36,408 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:36,411 [main:67] - randomType = UInt
2021-03-11 21:09:36,504 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:09:36,526 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@7337b377]
2021-03-11 21:09:36,526 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@2f62c5fb]
2021-03-11 21:09:36,527 [main:78] - Generated call from random type = (854239100.toUInt()).toFloat().toInt()
2021-03-11 21:09:36,527 [main:106] - GETTING Int from Int
2021-03-11 21:09:36,556 [main:113] - Case = [@kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@444f3fa7]]
2021-03-11 21:09:36,556 [main:117] - GENERATED CALL = (iarg1).sign
2021-03-11 21:09:36,556 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@68b32e8b]]
2021-03-11 21:09:36,556 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:36,556 [main:149] - GENERATING call of type public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@68b32e8b]
2021-03-11 21:09:36,556 [main:117] - GENERATED CALL = (iarg1).toChar().toInt()
2021-03-11 21:09:36,556 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]]
2021-03-11 21:09:36,556 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:36,557 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]
2021-03-11 21:09:36,557 [main:117] - GENERATED CALL = (iarg1).compareTo(iarg1).takeLowestOneBit()
2021-03-11 21:09:36,557 [main:113] - Case = [public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]]
2021-03-11 21:09:36,557 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]
2021-03-11 21:09:36,557 [main:117] - GENERATED CALL = (iarg1).or(iarg1)
2021-03-11 21:09:36,557 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]]
2021-03-11 21:09:36,557 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:36,557 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:36,651 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:36,652 [main:117] - GENERATED CALL = (iarg1).compareTo(iarg1).and(-31884545)
2021-03-11 21:09:36,652 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]]
2021-03-11 21:09:36,652 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:36,652 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]
2021-03-11 21:09:36,748 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:36,749 [main:117] - GENERATED CALL = (iarg1).toDouble().compareTo(104)
2021-03-11 21:09:36,749 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public final val step: kotlin.Int defined in kotlin.ranges.IntRange[DeserializedPropertyDescriptor@78ba3cd2]]
2021-03-11 21:09:36,749 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:09:36,857 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:36,859 [main:117] - GENERATED CALL = (iarg1).rangeTo(-3).step
2021-03-11 21:09:36,859 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun toInt(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@31151547]]
2021-03-11 21:09:36,859 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:36,859 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@31151547]
2021-03-11 21:09:36,859 [main:117] - GENERATED CALL = (iarg1).toShort().toInt()
2021-03-11 21:09:36,859 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60337d73]]
2021-03-11 21:09:36,859 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:36,859 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60337d73]
2021-03-11 21:09:36,952 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:36,953 [main:117] - GENERATED CALL = (iarg1).toInt().div(-72)
2021-03-11 21:09:36,954 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]]
2021-03-11 21:09:36,954 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:37,048 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:37,049 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]
2021-03-11 21:09:37,143 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:37,144 [main:117] - GENERATED CALL = (iarg1).compareTo(-1365782611).coerceAtLeast(1968038665)
2021-03-11 21:09:37,145 [main:61] - replacement of 0xDC56DC56.toInt() of type Int is (iarg1).sign
2021-03-11 21:09:37,238 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:37,238 [main:66] - Compilation checking started
2021-03-11 21:09:37,506 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = (iarg1).sign
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + (i4).toDouble().toBits() // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:37,508 [main:53] - replacing ((0xDC56DC56L shl 32) + (i4).toDouble().toBits(), Long)
2021-03-11 21:09:37,509 [main:50] - replacing (0xDC56DC56L shl 32) + (i4).toDouble().toBits() Long
2021-03-11 21:09:37,509 [main:54] - Getting value of type Long
2021-03-11 21:09:37,602 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:37,604 [main:58] - GENERATED VALUE OF TYPE Long = 8314395345396211014
2021-03-11 21:09:37,604 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:37,608 [main:67] - randomType = Short?
2021-03-11 21:09:37,702 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:37,753 [main:149] - GENERATING call of type public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487]
2021-03-11 21:09:37,753 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7f624377]
2021-03-11 21:09:37,848 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:37,849 [main:78] - Generated call from random type = (19276)?.toShort().rem(-1256515922486030596)
2021-03-11 21:09:37,850 [main:106] - GETTING Long from Int
2021-03-11 21:09:37,880 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]]
2021-03-11 21:09:37,880 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:37,880 [main:149] - GENERATING call of type public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]
2021-03-11 21:09:37,974 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:37,975 [main:117] - GENERATED CALL = (iarg1).div(larg1).coerceIn(larg1, -6776273072750751900)
2021-03-11 21:09:37,975 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeHighestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@57ac128c]]
2021-03-11 21:09:37,975 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:37,975 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeHighestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@57ac128c]
2021-03-11 21:09:37,976 [main:117] - GENERATED CALL = (iarg1).toLong().takeHighestOneBit()
2021-03-11 21:09:37,976 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin public fun kotlin.Double.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@917de8d]]
2021-03-11 21:09:37,976 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:37,976 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Double.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@917de8d]
2021-03-11 21:09:37,976 [main:117] - GENERATED CALL = (iarg1).toDouble().roundToLong()
2021-03-11 21:09:37,976 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]]
2021-03-11 21:09:37,976 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:37,976 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]
2021-03-11 21:09:38,070 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:38,071 [main:117] - GENERATED CALL = (iarg1).toLong().or(560106871966656871)
2021-03-11 21:09:38,071 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]]
2021-03-11 21:09:38,071 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:38,071 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]
2021-03-11 21:09:38,071 [main:117] - GENERATED CALL = (iarg1).toLong().shr(iarg1)
2021-03-11 21:09:38,071 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]]
2021-03-11 21:09:38,071 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:38,072 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]
2021-03-11 21:09:38,182 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:38,184 [main:117] - GENERATED CALL = (iarg1).toLong().coerceAtMost(3043910191380504072)
2021-03-11 21:09:38,184 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@598ffbc8]]
2021-03-11 21:09:38,184 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:38,184 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@598ffbc8]
2021-03-11 21:09:38,184 [main:117] - GENERATED CALL = (iarg1).toLong().ushr(iarg1)
2021-03-11 21:09:38,184 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]]
2021-03-11 21:09:38,184 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:38,277 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:38,278 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]
2021-03-11 21:09:38,371 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:38,372 [main:117] - GENERATED CALL = (iarg1).div(-4047182490725028153).rotateRight(-1581258385)
2021-03-11 21:09:38,372 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]]
2021-03-11 21:09:38,373 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:38,373 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]
2021-03-11 21:09:38,373 [main:117] - GENERATED CALL = (iarg1).toDouble().toBits()
2021-03-11 21:09:38,373 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]]
2021-03-11 21:09:38,373 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:38,465 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:38,467 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]
2021-03-11 21:09:38,467 [main:117] - GENERATED CALL = (iarg1).div(2659265618677612651).takeLowestOneBit()
2021-03-11 21:09:38,467 [main:61] - replacement of (0xDC56DC56L shl 32) + (i4).toDouble().toBits() of type Long is (iarg1).div(-4047182490725028153).rotateRight(-1581258385)
2021-03-11 21:09:38,559 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:38,560 [main:66] - Compilation checking started
2021-03-11 21:09:38,902 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:38,906 [main:53] - replacing (0xFFFFDC56.toInt(), Int)
2021-03-11 21:09:38,907 [main:50] - replacing 0xFFFFDC56.toInt() Int
2021-03-11 21:09:38,907 [main:54] - Getting value of type Int
2021-03-11 21:09:39,012 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:39,014 [main:58] - GENERATED VALUE OF TYPE Int = 1733995329
2021-03-11 21:09:39,014 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:39,456 [main:67] - randomType = List<HashMap<Sequence<UShort>, Double>>
2021-03-11 21:09:39,457 [main:106] - GETTING Int from Int?
2021-03-11 21:09:39,488 [main:113] - Case = [public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]]
2021-03-11 21:09:39,488 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]
2021-03-11 21:09:39,488 [main:117] - GENERATED CALL = (i4).xor(iarg2)
2021-03-11 21:09:39,488 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]]
2021-03-11 21:09:39,488 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:39,582 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:39,583 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]
2021-03-11 21:09:39,694 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:39,789 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:39,790 [main:117] - GENERATED CALL = (i4).compareTo(-1282801582).coerceIn(-1800622559, 1595477097)
2021-03-11 21:09:39,790 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin public fun kotlin.Double.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@5645a0d]]
2021-03-11 21:09:39,790 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:39,790 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Double.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@5645a0d]
2021-03-11 21:09:39,790 [main:117] - GENERATED CALL = (i4).toDouble().roundToInt()
2021-03-11 21:09:39,790 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]]
2021-03-11 21:09:39,790 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:39,790 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]
2021-03-11 21:09:39,791 [main:117] - GENERATED CALL = (i4).toInt().takeLowestOneBit()
2021-03-11 21:09:39,791 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@68b32e8b]]
2021-03-11 21:09:39,791 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:39,791 [main:149] - GENERATING call of type public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@68b32e8b]
2021-03-11 21:09:39,791 [main:117] - GENERATED CALL = (i4).toChar().toInt()
2021-03-11 21:09:39,791 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:09:39,791 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:39,791 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:09:39,883 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:39,885 [main:117] - GENERATED CALL = (i4).and(iarg2).rem(-8)
2021-03-11 21:09:39,885 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@2af3682f]]
2021-03-11 21:09:39,885 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:39,885 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@2af3682f]
2021-03-11 21:09:39,979 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:09:39,980 [main:117] - GENERATED CALL = (i4).toChar().minus('歙')
2021-03-11 21:09:39,981 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@169b0203]]
2021-03-11 21:09:39,981 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:39,981 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@169b0203]
2021-03-11 21:09:39,981 [main:117] - GENERATED CALL = (i4).toByte().countOneBits()
2021-03-11 21:09:39,981 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]]
2021-03-11 21:09:39,981 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:39,981 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]
2021-03-11 21:09:39,981 [main:117] - GENERATED CALL = (i4).toInt().unaryPlus()
2021-03-11 21:09:39,981 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:09:39,981 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:39,981 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:09:39,982 [main:117] - GENERATED CALL = (i4).and(iarg1).shr(iarg2)
2021-03-11 21:09:39,982 [main:61] - replacement of 0xFFFFDC56.toInt() of type Int is 1733995329
2021-03-11 21:09:40,073 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:09:40,074 [main:66] - Compilation checking started
2021-03-11 21:09:40,417 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:40,420 [main:53] - replacing (0x0000DC56.toInt(), Int)
2021-03-11 21:09:40,422 [main:50] - replacing 0x0000DC56.toInt() Int
2021-03-11 21:09:40,422 [main:54] - Getting value of type Int
2021-03-11 21:09:40,535 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:40,536 [main:58] - GENERATED VALUE OF TYPE Int = -1825571337
2021-03-11 21:09:40,537 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:40,540 [main:67] - randomType = Long
2021-03-11 21:09:40,633 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:40,663 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:40,756 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:40,757 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]
2021-03-11 21:09:40,849 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:40,850 [main:78] - Generated call from random type = (-4600284532773251048).compareTo(119).ushr(-2046840968)
2021-03-11 21:09:40,850 [main:106] - GETTING Int from Int?
2021-03-11 21:09:40,885 [main:113] - Case = [public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]]
2021-03-11 21:09:40,885 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]
2021-03-11 21:09:40,885 [main:117] - GENERATED CALL = (i2).unaryPlus()
2021-03-11 21:09:40,885 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@28383eeb]]
2021-03-11 21:09:40,885 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:40,978 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:40,979 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@28383eeb]
2021-03-11 21:09:41,090 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:41,092 [main:117] - GENERATED CALL = (i2).compareTo(-313933357).plus(-97)
2021-03-11 21:09:41,092 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]]
2021-03-11 21:09:41,092 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:41,185 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:41,186 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]
2021-03-11 21:09:41,186 [main:117] - GENERATED CALL = (i2).compareTo(-18390905).inv()
2021-03-11 21:09:41,186 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]]
2021-03-11 21:09:41,186 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:41,280 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:41,281 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]
2021-03-11 21:09:41,281 [main:117] - GENERATED CALL = (i2).compareTo(1526668937).countTrailingZeroBits()
2021-03-11 21:09:41,281 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public val kotlin.Long.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@1360523c]]
2021-03-11 21:09:41,281 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:41,281 [main:117] - GENERATED CALL = (i2).toLong().sign
2021-03-11 21:09:41,281 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]]
2021-03-11 21:09:41,281 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:41,281 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]
2021-03-11 21:09:41,282 [main:117] - GENERATED CALL = (i2).and(iarg1).ushr(iarg1)
2021-03-11 21:09:41,282 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:09:41,282 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:41,282 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:09:41,282 [main:117] - GENERATED CALL = (i2).compareTo(iarg1).inc()
2021-03-11 21:09:41,282 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]]
2021-03-11 21:09:41,282 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:41,282 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]
2021-03-11 21:09:41,282 [main:117] - GENERATED CALL = (i2).and(iarg2).coerceIn(iarg2, iarg1)
2021-03-11 21:09:41,282 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5694be4c]]
2021-03-11 21:09:41,283 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:41,283 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5694be4c]
2021-03-11 21:09:41,283 [main:117] - GENERATED CALL = (i2).toFloat().toBits()
2021-03-11 21:09:41,283 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]]
2021-03-11 21:09:41,283 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:41,283 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]
2021-03-11 21:09:41,283 [main:117] - GENERATED CALL = (i2).and(iarg2).unaryMinus()
2021-03-11 21:09:41,283 [main:61] - replacement of 0x0000DC56.toInt() of type Int is (i2).compareTo(iarg1).inc()
2021-03-11 21:09:41,375 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:41,375 [main:66] - Compilation checking started
2021-03-11 21:09:41,710 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:41,711 [main:53] - replacing (b2, Byte?)
2021-03-11 21:09:41,711 [main:50] - replacing b2 Byte?
2021-03-11 21:09:41,711 [main:54] - Getting value of type Byte?
2021-03-11 21:09:41,815 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:41,816 [main:58] - GENERATED VALUE OF TYPE Byte? = 79
2021-03-11 21:09:41,816 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:41,925 [main:67] - randomType = UShort
2021-03-11 21:09:42,019 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:09:42,048 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@5e219173]
2021-03-11 21:09:42,048 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@725fc764]
2021-03-11 21:09:42,048 [main:78] - Generated call from random type = (7118.toUShort()).toByte().dec()
2021-03-11 21:09:42,049 [main:61] - replacement of b2 of type Byte? is (7118.toUShort()).toByte().dec()
2021-03-11 21:09:42,140 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:42,143 [main:53] - replacing (larg1, Long)
2021-03-11 21:09:42,144 [main:50] - replacing larg1 Long
2021-03-11 21:09:42,144 [main:54] - Getting value of type Long
2021-03-11 21:09:42,236 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:42,237 [main:58] - GENERATED VALUE OF TYPE Long = 6978289351547199343
2021-03-11 21:09:42,238 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:42,239 [main:67] - randomType = Long
2021-03-11 21:09:42,332 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:42,362 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:42,362 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtMost(maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@26b2b702]
2021-03-11 21:09:42,362 [main:78] - Generated call from random type = (-2401483063879662783).toLong().coerceAtMost(larg2)
2021-03-11 21:09:42,363 [main:106] - GETTING Long from Long?
2021-03-11 21:09:42,392 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4722f673]]
2021-03-11 21:09:42,392 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:42,393 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4722f673]
2021-03-11 21:09:42,393 [main:117] - GENERATED CALL = (l2).toByte().plus(larg2)
2021-03-11 21:09:42,393 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]]
2021-03-11 21:09:42,393 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:42,507 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:42,508 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]
2021-03-11 21:09:42,603 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:42,605 [main:117] - GENERATED CALL = (l2).and(-1040289630786463190).plus(-27)
2021-03-11 21:09:42,605 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]]
2021-03-11 21:09:42,605 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:42,605 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@313c05b9]
2021-03-11 21:09:42,605 [main:117] - GENERATED CALL = (l2).and(larg1).shl(iarg1)
2021-03-11 21:09:42,605 [main:113] - Case = [public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]]
2021-03-11 21:09:42,605 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]
2021-03-11 21:09:42,605 [main:117] - GENERATED CALL = (l2).shr(iarg1)
2021-03-11 21:09:42,605 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]]
2021-03-11 21:09:42,606 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:42,700 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:42,701 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6c808b47]
2021-03-11 21:09:42,701 [main:117] - GENERATED CALL = (l2).compareTo(123).toLong()
2021-03-11 21:09:42,701 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]]
2021-03-11 21:09:42,701 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:42,701 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]
2021-03-11 21:09:42,701 [main:117] - GENERATED CALL = (l2).toLong().rotateRight(iarg2)
2021-03-11 21:09:42,701 [main:113] - Case = [public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]]
2021-03-11 21:09:42,701 [main:149] - GENERATING call of type public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]
2021-03-11 21:09:42,702 [main:117] - GENERATED CALL = (l2).inv()
2021-03-11 21:09:42,702 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@222b24dd]]
2021-03-11 21:09:42,702 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:42,702 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@222b24dd]
2021-03-11 21:09:42,794 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:42,796 [main:117] - GENERATED CALL = (l2).toShort().div(3990475977098170620)
2021-03-11 21:09:42,796 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:09:42,796 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:42,888 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:42,889 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:09:42,983 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:42,984 [main:117] - GENERATED CALL = (l2).and(-142531626394812358).rem(15)
2021-03-11 21:09:42,984 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:09:42,984 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:09:42,984 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:09:42,984 [main:117] - GENERATED CALL = (l2).and(larg2).dec()
2021-03-11 21:09:42,984 [main:61] - replacement of larg1 of type Long is 6978289351547199343
2021-03-11 21:09:43,076 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:09:43,077 [main:66] - Compilation checking started
2021-03-11 21:09:43,429 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:43,431 [main:53] - replacing (((iarg2).toInt().toLong()) + 0xDC56DC56, Long)
2021-03-11 21:09:43,431 [main:50] - replacing ((iarg2).toInt().toLong()) + 0xDC56DC56 Long
2021-03-11 21:09:43,431 [main:54] - Getting value of type Long
2021-03-11 21:09:43,530 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:43,531 [main:58] - GENERATED VALUE OF TYPE Long = -4947793235833246466
2021-03-11 21:09:43,531 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:43,636 [main:67] - randomType = ArrayDeque<Int>
2021-03-11 21:09:43,732 [main:302] - generating value of type = ArrayDeque<Int> false depth = 0
2021-03-11 21:09:43,834 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<Int> = TODO()
2021-03-11 21:09:43,837 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<Int> = TODO()
2021-03-11 21:09:44,067 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:09:44,068 [main:95] - GENERATED = ArrayDeque<Int>(-648747540)
2021-03-11 21:09:44,203 [main:149] - GENERATING call of type public final fun firstOrNull(): kotlin.Int? defined in kotlin.collections.ArrayDeque[DeserializedSimpleFunctionDescriptor@7606a0d4]
2021-03-11 21:09:44,203 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@27136e85]
2021-03-11 21:09:44,296 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:44,297 [main:78] - Generated call from random type = (ArrayDeque<Int>(-648747540)).firstOrNull()?.minus(1242197048100856966)!!
2021-03-11 21:09:44,297 [main:61] - replacement of ((iarg2).toInt().toLong()) + 0xDC56DC56 of type Long is -4947793235833246466
2021-03-11 21:09:44,389 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-11 21:09:44,391 [main:53] - replacing ("fail: Int.inv", String)
2021-03-11 21:09:44,392 [main:50] - replacing "fail: Int.inv" String
2021-03-11 21:09:44,392 [main:54] - Getting value of type String
2021-03-11 21:09:44,485 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:44,486 [main:58] - GENERATED VALUE OF TYPE String = "moykk"
2021-03-11 21:09:44,486 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:44,591 [main:67] - randomType = Array<ULong>
2021-03-11 21:09:44,683 [main:302] - generating value of type = Array<ULong> false depth = 0
2021-03-11 21:09:44,780 [main:43] - GENERATING CALL OF fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->ULong): Array<ULong> = TODO()
2021-03-11 21:09:44,783 [main:61] - WITHOUT TYPE PARAMS = fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->ULong): Array<ULong> = TODO()
2021-03-11 21:09:45,083 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:09:45,084 [main:302] - generating value of type = Function1<Int, ULong> false depth = 3
2021-03-11 21:09:45,085 [main:302] - generating value of type = ULong true depth = 4
2021-03-11 21:09:45,087 [main:95] - GENERATED = Array<ULong>(-385363612, {a: Int -> 3155008882726515168.toULong()})
2021-03-11 21:09:45,100 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:45,100 [main:78] - Generated call from random type = (Array<ULong>(-385363612, {a: Int -> 3155008882726515168.toULong()})).size.toString(iarg1)
2021-03-11 21:09:45,101 [main:106] - GETTING String from Int?
2021-03-11 21:09:45,132 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:45,132 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:45,224 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:45,226 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:45,226 [main:117] - GENERATED CALL = (i5).compareTo(-1012058872).toString(iarg2)
2021-03-11 21:09:45,226 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:09:45,226 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:45,226 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:09:45,226 [main:117] - GENERATED CALL = (i5).toByte().toString(iarg2)
2021-03-11 21:09:45,227 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:09:45,227 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:45,227 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:09:45,227 [main:117] - GENERATED CALL = (i5).toChar().titlecase()
2021-03-11 21:09:45,227 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:09:45,227 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:45,227 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:45,227 [main:117] - GENERATED CALL = (i5).toLong().toString(iarg2)
2021-03-11 21:09:45,227 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:09:45,227 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:45,228 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:09:45,228 [main:117] - GENERATED CALL = (i5).toShort().toString(iarg2)
2021-03-11 21:09:45,228 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:45,228 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:45,228 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:45,228 [main:117] - GENERATED CALL = (i5).toInt().toString(iarg1)
2021-03-11 21:09:45,228 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:09:45,228 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:45,228 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:09:45,229 [main:117] - GENERATED CALL = (i5).toChar().lowercase()
2021-03-11 21:09:45,229 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:09:45,229 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:45,229 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:09:45,229 [main:117] - GENERATED CALL = (i5).toChar().uppercase()
2021-03-11 21:09:45,229 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:09:45,229 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:45,229 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:09:45,323 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:45,324 [main:117] - GENERATED CALL = (i5).toChar().plus("jrwnt")
2021-03-11 21:09:45,325 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:09:45,325 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:45,444 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:45,445 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:09:45,445 [main:117] - GENERATED CALL = (i5).and(-1458259836).toString(iarg2)
2021-03-11 21:09:45,445 [main:61] - replacement of "fail: Int.inv" of type String is (i5).toLong().toString(iarg2)
2021-03-11 21:09:45,542 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:45,543 [main:66] - Compilation checking started
2021-03-11 21:09:45,806 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return (i5).toLong().toString(iarg2)
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:45,809 [main:53] - replacing (i3, Int?)
2021-03-11 21:09:45,810 [main:50] - replacing i3 Int?
2021-03-11 21:09:45,810 [main:54] - Getting value of type Int?
2021-03-11 21:09:45,902 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:45,903 [main:58] - GENERATED VALUE OF TYPE Int? = -729019454
2021-03-11 21:09:45,903 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:46,008 [main:67] - randomType = Set<Int>
2021-03-11 21:09:46,009 [main:106] - GETTING Int? from Int?
2021-03-11 21:09:46,044 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@444f3fa7]]
2021-03-11 21:09:46,044 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:46,137 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:46,138 [main:117] - GENERATED CALL = (i1)?.compareTo(652798131).sign
2021-03-11 21:09:46,138 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@12103546]]
2021-03-11 21:09:46,138 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:46,138 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@12103546]
2021-03-11 21:09:46,138 [main:117] - GENERATED CALL = (i1)?.toByte().unaryPlus()
2021-03-11 21:09:46,138 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]]
2021-03-11 21:09:46,138 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:46,138 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:46,231 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:46,232 [main:117] - GENERATED CALL = (i1)?.toInt().and(-513625623)
2021-03-11 21:09:46,233 [main:113] - Case = [@kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:09:46,233 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:09:46,325 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:46,326 [main:117] - GENERATED CALL = (i1)?.rem(78)
2021-03-11 21:09:46,326 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]]
2021-03-11 21:09:46,326 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:46,326 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]
2021-03-11 21:09:46,326 [main:117] - GENERATED CALL = (i1)?.toByte().toInt()
2021-03-11 21:09:46,326 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]]
2021-03-11 21:09:46,326 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:46,420 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:46,422 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:09:46,422 [main:117] - GENERATED CALL = (i1)?.compareTo(664219993).shl(iarg2)
2021-03-11 21:09:46,422 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public val kotlin.Long.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@1360523c]]
2021-03-11 21:09:46,422 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:46,515 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:46,517 [main:117] - GENERATED CALL = (i1)?.div(3477709554354786396).sign
2021-03-11 21:09:46,517 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.ExperimentalStdlibApi @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Char.code: kotlin.Int defined in kotlin[DeserializedPropertyDescriptor@37f2dfd6]]
2021-03-11 21:09:46,517 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:46,517 [main:117] - GENERATED CALL = (i1)?.toChar().code
2021-03-11 21:09:46,517 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@46fab768]]
2021-03-11 21:09:46,517 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:46,517 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@46fab768]
2021-03-11 21:09:46,610 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:46,611 [main:117] - GENERATED CALL = (i1)?.toFloat().compareTo(2)
2021-03-11 21:09:46,611 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]]
2021-03-11 21:09:46,611 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:46,611 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]
2021-03-11 21:09:46,704 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:46,706 [main:117] - GENERATED CALL = (i1)?.toDouble().compareTo(101)
2021-03-11 21:09:46,706 [main:61] - replacement of i3 of type Int? is (i1)?.toChar().code
2021-03-11 21:09:46,797 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:46,798 [main:66] - Compilation checking started
2021-03-11 21:09:47,106 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if ((i1)?.toChar().code != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:47,108 [main:53] - replacing (i5, Int?)
2021-03-11 21:09:47,109 [main:50] - replacing i5 Int?
2021-03-11 21:09:47,109 [main:54] - Getting value of type Int?
2021-03-11 21:09:47,210 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:47,211 [main:58] - GENERATED VALUE OF TYPE Int? = -1346591778
2021-03-11 21:09:47,211 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:47,325 [main:67] - randomType = Set<Char>
2021-03-11 21:09:47,326 [main:106] - GETTING Int? from Int?
2021-03-11 21:09:47,381 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]]
2021-03-11 21:09:47,381 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:47,476 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:47,477 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]
2021-03-11 21:09:47,477 [main:117] - GENERATED CALL = (i1)?.and(1807611933).dec()
2021-03-11 21:09:47,478 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]]
2021-03-11 21:09:47,478 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:47,478 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]
2021-03-11 21:09:47,478 [main:117] - GENERATED CALL = (i1)?.toInt().unaryPlus()
2021-03-11 21:09:47,478 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]]
2021-03-11 21:09:47,478 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:47,478 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]
2021-03-11 21:09:47,478 [main:117] - GENERATED CALL = (i1)?.toInt().countTrailingZeroBits()
2021-03-11 21:09:47,478 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]]
2021-03-11 21:09:47,478 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:47,478 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]
2021-03-11 21:09:47,573 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:47,574 [main:117] - GENERATED CALL = (i1)?.and(iarg2).ushr(-1154182251)
2021-03-11 21:09:47,574 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]]
2021-03-11 21:09:47,574 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:47,574 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]
2021-03-11 21:09:47,574 [main:117] - GENERATED CALL = (i1)?.toLong().countTrailingZeroBits()
2021-03-11 21:09:47,574 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]]
2021-03-11 21:09:47,574 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:47,672 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:47,673 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]
2021-03-11 21:09:47,673 [main:117] - GENERATED CALL = (i1)?.compareTo(540541726).rotateRight(iarg1)
2021-03-11 21:09:47,673 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]]
2021-03-11 21:09:47,673 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:47,674 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:09:47,768 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:47,770 [main:117] - GENERATED CALL = (i1)?.toShort().compareTo(101)
2021-03-11 21:09:47,770 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:09:47,770 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:47,770 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:09:47,770 [main:117] - GENERATED CALL = (i1)?.toInt().shr(iarg1)
2021-03-11 21:09:47,770 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]]
2021-03-11 21:09:47,770 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:09:47,770 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]
2021-03-11 21:09:47,771 [main:117] - GENERATED CALL = (i1)?.and(iarg2).countLeadingZeroBits()
2021-03-11 21:09:47,771 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public val kotlin.Long.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@1360523c]]
2021-03-11 21:09:47,771 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:47,864 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:47,866 [main:117] - GENERATED CALL = (i1)?.div(990688990496764335).sign
2021-03-11 21:09:47,866 [main:61] - replacement of i5 of type Int? is (i1)?.and(1807611933).dec()
2021-03-11 21:09:47,964 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:47,964 [main:66] - Compilation checking started
2021-03-11 21:09:48,224 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if ((i1)?.and(1807611933).dec() != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if (l5 != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:48,226 [main:53] - replacing (l5, Long?)
2021-03-11 21:09:48,227 [main:50] - replacing l5 Long?
2021-03-11 21:09:48,227 [main:54] - Getting value of type Long?
2021-03-11 21:09:48,320 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:48,321 [main:58] - GENERATED VALUE OF TYPE Long? = 947814432629734849
2021-03-11 21:09:48,321 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:48,324 [main:67] - randomType = Float
2021-03-11 21:09:48,417 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:09:48,445 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@719ac69]
2021-03-11 21:09:48,445 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7f624377]
2021-03-11 21:09:48,445 [main:78] - Generated call from random type = (0.40895718f).toShort().rem(larg2)
2021-03-11 21:09:48,445 [main:61] - replacement of l5 of type Long? is (0.40895718f).toShort().rem(larg2)
2021-03-11 21:09:48,555 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:48,555 [main:66] - Compilation checking started
2021-03-11 21:09:48,889 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:48,889 [main:53] - replacing (0xFFFFFFFFL, Long)
2021-03-11 21:09:48,889 [main:50] - replacing 0xFFFFFFFFL Long
2021-03-11 21:09:48,889 [main:54] - Getting value of type Long
2021-03-11 21:09:48,984 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:48,985 [main:58] - GENERATED VALUE OF TYPE Long = 2714156925175063144
2021-03-11 21:09:48,985 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:48,987 [main:67] - randomType = Boolean
2021-03-11 21:09:49,080 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:49,089 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:09:49,183 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:49,184 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:49,278 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:49,279 [main:78] - Generated call from random type = (true).compareTo(true).div(-8854609976545700885)
2021-03-11 21:09:49,279 [main:61] - replacement of 0xFFFFFFFFL of type Long is 2714156925175063144
2021-03-11 21:09:49,372 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:09:49,372 [main:53] - replacing (larg2, Long)
2021-03-11 21:09:49,372 [main:50] - replacing larg2 Long
2021-03-11 21:09:49,372 [main:54] - Getting value of type Long
2021-03-11 21:09:49,466 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:49,467 [main:58] - GENERATED VALUE OF TYPE Long = 6876868249405170742
2021-03-11 21:09:49,467 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:49,575 [main:67] - randomType = Function1<UInt, Short>
2021-03-11 21:09:49,575 [main:61] - replacement of larg2 of type Long is 6876868249405170742
2021-03-11 21:09:49,669 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:09:49,671 [main:53] - replacing (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE, Boolean)
2021-03-11 21:09:49,672 [main:50] - replacing l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE Boolean
2021-03-11 21:09:49,672 [main:54] - Getting value of type Boolean
2021-03-11 21:09:49,767 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:49,768 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:09:49,768 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:49,980 [main:67] - randomType = List<ULong>
2021-03-11 21:09:49,981 [main:106] - GETTING Boolean from Int?
2021-03-11 21:09:50,022 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:09:50,023 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:50,023 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:09:50,023 [main:117] - GENERATED CALL = (i5).toChar().isLowerCase()
2021-03-11 21:09:50,023 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:09:50,023 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:50,140 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:50,141 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:09:50,141 [main:117] - GENERATED CALL = (i5).div(0.7349692732559013).isFinite()
2021-03-11 21:09:50,141 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]]
2021-03-11 21:09:50,141 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:09:50,234 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:50,235 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]
2021-03-11 21:09:50,329 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:50,331 [main:117] - GENERATED CALL = (i5).rangeTo(81).contains(-689193585)
2021-03-11 21:09:50,331 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]]
2021-03-11 21:09:50,331 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:50,331 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]
2021-03-11 21:09:50,331 [main:117] - GENERATED CALL = (i5).toChar().isTitleCase()
2021-03-11 21:09:50,331 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]]
2021-03-11 21:09:50,331 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:50,331 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]
2021-03-11 21:09:50,332 [main:117] - GENERATED CALL = (i5).toChar().isUpperCase()
2021-03-11 21:09:50,332 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]]
2021-03-11 21:09:50,332 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:50,332 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]
2021-03-11 21:09:50,332 [main:117] - GENERATED CALL = (i5).toChar().isLowSurrogate()
2021-03-11 21:09:50,332 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:09:50,332 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:50,426 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:50,427 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:09:50,520 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:50,521 [main:117] - GENERATED CALL = (i5).div(0.12162632706339405).equals("iliwt")
2021-03-11 21:09:50,521 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@58303fc8]]
2021-03-11 21:09:50,521 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:09:50,613 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:50,614 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@58303fc8]
2021-03-11 21:09:50,614 [main:117] - GENERATED CALL = (i5).rangeTo(70).isEmpty()
2021-03-11 21:09:50,614 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:09:50,614 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:50,614 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:09:50,615 [main:117] - GENERATED CALL = (i5).toChar().isWhitespace()
2021-03-11 21:09:50,615 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]]
2021-03-11 21:09:50,615 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:50,615 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]
2021-03-11 21:09:50,615 [main:117] - GENERATED CALL = (i5).toChar().isDefined()
2021-03-11 21:09:50,615 [main:61] - replacement of l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE of type Boolean is (i5).div(0.7349692732559013).isFinite()
2021-03-11 21:09:50,707 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:50,707 [main:66] - Compilation checking started
2021-03-11 21:09:50,962 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if ((i5).div(0.7349692732559013).isFinite()) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:50,963 [main:53] - replacing (larg1, Long)
2021-03-11 21:09:50,963 [main:50] - replacing larg1 Long
2021-03-11 21:09:50,963 [main:54] - Getting value of type Long
2021-03-11 21:09:51,056 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:51,057 [main:58] - GENERATED VALUE OF TYPE Long = 85526094233858858
2021-03-11 21:09:51,057 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:51,060 [main:67] - randomType = Int
2021-03-11 21:09:51,153 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:51,183 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:51,184 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@76b6e5ab]
2021-03-11 21:09:51,184 [main:78] - Generated call from random type = (-417490810).toFloat().toLong()
2021-03-11 21:09:51,184 [main:61] - replacement of larg1 of type Long is (-417490810).toFloat().toLong()
2021-03-11 21:09:51,281 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:51,283 [main:53] - replacing (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE, Boolean)
2021-03-11 21:09:51,284 [main:50] - replacing l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE Boolean
2021-03-11 21:09:51,284 [main:54] - Getting value of type Boolean
2021-03-11 21:09:51,376 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:51,377 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:09:51,377 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:51,482 [main:67] - randomType = Function1<UInt, Char>
2021-03-11 21:09:51,483 [main:106] - GETTING Boolean from Int
2021-03-11 21:09:51,512 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:09:51,513 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:51,513 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:09:51,606 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:51,606 [main:117] - GENERATED CALL = (iarg2).toDouble().equals("cqkdv")
2021-03-11 21:09:51,606 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]]
2021-03-11 21:09:51,606 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:09:51,721 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:51,721 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]
2021-03-11 21:09:51,815 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:51,816 [main:117] - GENERATED CALL = (iarg2).equals("lzxmb").and(false)
2021-03-11 21:09:51,816 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]]
2021-03-11 21:09:51,816 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:09:51,910 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:51,911 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4fcaa4db]
2021-03-11 21:09:51,912 [main:117] - GENERATED CALL = (iarg2).rangeTo(75).contains(i4)
2021-03-11 21:09:51,912 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]]
2021-03-11 21:09:51,912 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:51,912 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]
2021-03-11 21:09:51,912 [main:117] - GENERATED CALL = (iarg2).toFloat().isInfinite()
2021-03-11 21:09:51,912 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]]
2021-03-11 21:09:51,912 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:51,912 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]
2021-03-11 21:09:51,912 [main:117] - GENERATED CALL = (iarg2).toChar().isLetterOrDigit()
2021-03-11 21:09:51,912 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]]
2021-03-11 21:09:51,912 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:51,912 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]
2021-03-11 21:09:51,913 [main:117] - GENERATED CALL = (iarg2).toChar().isTitleCase()
2021-03-11 21:09:51,913 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:09:51,913 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:09:52,006 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:52,006 [main:117] - GENERATED CALL = (iarg2).equals("uuyqp")
2021-03-11 21:09:52,006 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]]
2021-03-11 21:09:52,006 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:52,006 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]
2021-03-11 21:09:52,006 [main:117] - GENERATED CALL = (iarg2).toChar().isUpperCase()
2021-03-11 21:09:52,007 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]]
2021-03-11 21:09:52,007 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:52,007 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]
2021-03-11 21:09:52,007 [main:117] - GENERATED CALL = (iarg2).toChar().isDefined()
2021-03-11 21:09:52,007 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]]
2021-03-11 21:09:52,007 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:52,007 [main:149] - GENERATING call of type public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]
2021-03-11 21:09:52,007 [main:117] - GENERATED CALL = (iarg2).toFloat().isFinite()
2021-03-11 21:09:52,007 [main:61] - replacement of l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE of type Boolean is (iarg2).toChar().isUpperCase()
2021-03-11 21:09:52,100 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:52,100 [main:66] - Compilation checking started
2021-03-11 21:09:52,361 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if ((iarg2).toChar().isUpperCase()) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:52,364 [main:53] - replacing (i3 != 0xB98AB98A.toInt(), Boolean)
2021-03-11 21:09:52,365 [main:50] - replacing i3 != 0xB98AB98A.toInt() Boolean
2021-03-11 21:09:52,365 [main:54] - Getting value of type Boolean
2021-03-11 21:09:52,460 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:52,461 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:09:52,461 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:52,571 [main:67] - randomType = MutableMap<Int, Short>
2021-03-11 21:09:52,572 [main:106] - GETTING Boolean from Int
2021-03-11 21:09:52,613 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:09:52,613 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:09:52,706 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:52,707 [main:117] - GENERATED CALL = (iarg1).equals("gcshi")
2021-03-11 21:09:52,707 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:09:52,707 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:52,800 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:52,801 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:09:52,894 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:52,895 [main:117] - GENERATED CALL = (iarg1).div(0.8837651252942075).equals("bgawa")
2021-03-11 21:09:52,895 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c00b3f8]]
2021-03-11 21:09:52,895 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:52,895 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c00b3f8]
2021-03-11 21:09:52,989 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:09:53,083 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:53,084 [main:117] - GENERATED CALL = (iarg1).toChar().equals('봸', true)
2021-03-11 21:09:53,084 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:09:53,084 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:53,084 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:09:53,084 [main:117] - GENERATED CALL = (iarg1).toChar().isWhitespace()
2021-03-11 21:09:53,084 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]]
2021-03-11 21:09:53,084 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:53,084 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:09:53,177 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:09:53,178 [main:117] - GENERATED CALL = (iarg1).toLong().equals("fwaqi")
2021-03-11 21:09:53,178 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:09:53,178 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:53,295 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:53,296 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:09:53,296 [main:117] - GENERATED CALL = (iarg1).div(0.23016313607020167).isInfinite()
2021-03-11 21:09:53,296 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:09:53,296 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:53,296 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:09:53,296 [main:117] - GENERATED CALL = (iarg1).toDouble().isNaN()
2021-03-11 21:09:53,296 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:09:53,296 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:53,390 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:53,391 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:09:53,487 [main:117] - GENERATED CALL = (iarg1).compareTo(-289904049).equals(null)
2021-03-11 21:09:53,487 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]]
2021-03-11 21:09:53,487 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:53,487 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]
2021-03-11 21:09:53,488 [main:117] - GENERATED CALL = (iarg1).toChar().isLetter()
2021-03-11 21:09:53,488 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]]
2021-03-11 21:09:53,488 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:53,488 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]
2021-03-11 21:09:53,488 [main:117] - GENERATED CALL = (iarg1).toChar().isHighSurrogate()
2021-03-11 21:09:53,488 [main:61] - replacement of i3 != 0xB98AB98A.toInt() of type Boolean is (iarg1).toChar().isWhitespace()
2021-03-11 21:09:53,580 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:53,581 [main:66] - Compilation checking started
2021-03-11 21:09:53,828 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if ((iarg1).toChar().isWhitespace()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:53,830 [main:53] - replacing ((l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong(), Boolean)
2021-03-11 21:09:53,831 [main:50] - replacing (l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong() Boolean
2021-03-11 21:09:53,831 [main:54] - Getting value of type Boolean
2021-03-11 21:09:53,924 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:09:53,925 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:09:53,926 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:53,928 [main:67] - randomType = Short
2021-03-11 21:09:54,022 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:54,057 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:09:54,057 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]
2021-03-11 21:09:54,057 [main:78] - Generated call from random type = (-16593).toFloat().isInfinite()
2021-03-11 21:09:54,057 [main:61] - replacement of (l3)?.and(larg1).plus(44) != (0x00000000L shl 32) + 0xDC56DC56.toLong() of type Boolean is (-16593).toFloat().isInfinite()
2021-03-11 21:09:54,150 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:54,150 [main:66] - Compilation checking started
2021-03-11 21:09:54,497 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:54,498 [main:53] - replacing ("fail: Short.inv", String)
2021-03-11 21:09:54,498 [main:50] - replacing "fail: Short.inv" String
2021-03-11 21:09:54,498 [main:54] - Getting value of type String
2021-03-11 21:09:54,594 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:09:54,595 [main:58] - GENERATED VALUE OF TYPE String = "yagvz"
2021-03-11 21:09:54,595 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:54,705 [main:67] - randomType = UByte
2021-03-11 21:09:54,799 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:09:54,825 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@51217bf6]
2021-03-11 21:09:54,826 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:09:54,940 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:54,942 [main:78] - Generated call from random type = (95.toUByte()).toLong().toString(1536081409)
2021-03-11 21:09:54,942 [main:61] - replacement of "fail: Short.inv" of type String is (95.toUByte()).toLong().toString(1536081409)
2021-03-11 21:09:55,034 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:55,037 [main:53] - replacing (0x65DC65DC65DC65DC, Long)
2021-03-11 21:09:55,038 [main:50] - replacing 0x65DC65DC65DC65DC Long
2021-03-11 21:09:55,038 [main:54] - Getting value of type Long
2021-03-11 21:09:55,130 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:55,131 [main:58] - GENERATED VALUE OF TYPE Long = -2775948812440977239
2021-03-11 21:09:55,132 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:55,330 [main:67] - randomType = UShort?
2021-03-11 21:09:55,422 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:09:55,450 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@69239882]
2021-03-11 21:09:55,451 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7f624377]
2021-03-11 21:09:55,451 [main:78] - Generated call from random type = (13162.toUShort())?.toShort().rem(larg2)
2021-03-11 21:09:55,452 [main:106] - GETTING Long from Int?
2021-03-11 21:09:55,482 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]]
2021-03-11 21:09:55,482 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:55,482 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4742b2c2]
2021-03-11 21:09:55,574 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:55,576 [main:117] - GENERATED CALL = (i7).div(larg1).plus(-22)
2021-03-11 21:09:55,576 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7f624377]]
2021-03-11 21:09:55,576 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:55,576 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7f624377]
2021-03-11 21:09:55,576 [main:117] - GENERATED CALL = (i7).toShort().rem(larg2)
2021-03-11 21:09:55,576 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]]
2021-03-11 21:09:55,576 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:09:55,576 [main:149] - GENERATING call of type public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]
2021-03-11 21:09:55,576 [main:117] - GENERATED CALL = (i7).toChar().toLong()
2021-03-11 21:09:55,576 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]]
2021-03-11 21:09:55,576 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:55,576 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeLowestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@66fbba6b]
2021-03-11 21:09:55,577 [main:117] - GENERATED CALL = (i7).toLong().takeLowestOneBit()
2021-03-11 21:09:55,577 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]]
2021-03-11 21:09:55,577 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:55,577 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]
2021-03-11 21:09:55,577 [main:117] - GENERATED CALL = (i7).toInt().plus(larg2)
2021-03-11 21:09:55,577 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]]
2021-03-11 21:09:55,577 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:55,577 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@791a2fb8]
2021-03-11 21:09:55,577 [main:117] - GENERATED CALL = (i7).toLong().shr(iarg1)
2021-03-11 21:09:55,577 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:09:55,577 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:55,577 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:09:55,669 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:55,670 [main:117] - GENERATED CALL = (i7).toLong().rem(126)
2021-03-11 21:09:55,670 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]]
2021-03-11 21:09:55,670 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:55,670 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]
2021-03-11 21:09:55,762 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:55,763 [main:117] - GENERATED CALL = (i7).toLong().coerceAtLeast(5947593267867287916)
2021-03-11 21:09:55,763 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:09:55,763 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:09:55,763 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:09:55,764 [main:117] - GENERATED CALL = (i7).div(larg2).dec()
2021-03-11 21:09:55,764 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]]
2021-03-11 21:09:55,764 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:55,764 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Long.rotateRight(bitCount: kotlin.Int): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@39db0f18]
2021-03-11 21:09:55,764 [main:117] - GENERATED CALL = (i7).toLong().rotateRight(iarg2)
2021-03-11 21:09:55,764 [main:61] - replacement of 0x65DC65DC65DC65DC of type Long is (i7).toInt().plus(larg2)
2021-03-11 21:09:55,856 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:55,856 [main:66] - Compilation checking started
2021-03-11 21:09:56,113 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = (i7).toInt().plus(larg2)
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:56,114 [main:53] - replacing (0x00000000L, Long)
2021-03-11 21:09:56,114 [main:50] - replacing 0x00000000L Long
2021-03-11 21:09:56,114 [main:54] - Getting value of type Long
2021-03-11 21:09:56,209 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:56,210 [main:58] - GENERATED VALUE OF TYPE Long = -921282359937931950
2021-03-11 21:09:56,210 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:56,318 [main:67] - randomType = Map<Double, Long>
2021-03-11 21:09:56,318 [main:61] - replacement of 0x00000000L of type Long is -921282359937931950
2021-03-11 21:09:56,409 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-11 21:09:56,410 [main:53] - replacing (0x23.toByte(), Byte)
2021-03-11 21:09:56,410 [main:50] - replacing 0x23.toByte() Byte
2021-03-11 21:09:56,410 [main:54] - Getting value of type Byte
2021-03-11 21:09:56,523 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:56,524 [main:58] - GENERATED VALUE OF TYPE Byte = -10
2021-03-11 21:09:56,524 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:56,526 [main:67] - randomType = Int
2021-03-11 21:09:56,618 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:56,652 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:56,652 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.or(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@55f7b16b]
2021-03-11 21:09:56,745 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:56,746 [main:78] - Generated call from random type = (-329681609).toByte().or(97)
2021-03-11 21:09:56,746 [main:61] - replacement of 0x23.toByte() of type Byte is (-329681609).toByte().or(97)
2021-03-11 21:09:56,838 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:56,838 [main:53] - replacing (s3, Short?)
2021-03-11 21:09:56,839 [main:50] - replacing s3 Short?
2021-03-11 21:09:56,839 [main:54] - Getting value of type Short?
2021-03-11 21:09:56,930 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:56,931 [main:58] - GENERATED VALUE OF TYPE Short? = -12338
2021-03-11 21:09:56,931 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:56,933 [main:67] - randomType = Long
2021-03-11 21:09:57,026 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:09:57,060 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:09:57,060 [main:149] - GENERATING call of type public fun kotlin.Short.coerceIn(minimumValue: kotlin.Short, maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5f8f67d1]
2021-03-11 21:09:57,152 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:57,244 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:57,246 [main:78] - Generated call from random type = (7610520801584400686).toShort().coerceIn(11720, -3098)
2021-03-11 21:09:57,246 [main:61] - replacement of s3 of type Short? is (7610520801584400686).toShort().coerceIn(11720, -3098)
2021-03-11 21:09:57,337 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:57,339 [main:53] - replacing (iarg1 or  iarg2, Int)
2021-03-11 21:09:57,340 [main:50] - replacing iarg1 or  iarg2 Int
2021-03-11 21:09:57,340 [main:54] - Getting value of type Int
2021-03-11 21:09:57,431 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:57,432 [main:58] - GENERATED VALUE OF TYPE Int = 635856968
2021-03-11 21:09:57,432 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:57,435 [main:67] - randomType = Float
2021-03-11 21:09:57,527 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:09:57,556 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:57,556 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:09:57,556 [main:78] - Generated call from random type = (0.109696686f).toInt().toInt()
2021-03-11 21:09:57,556 [main:106] - GETTING Int from Int
2021-03-11 21:09:57,585 [main:113] - Case = [public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:09:57,585 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:09:57,585 [main:117] - GENERATED CALL = (iarg1).inc()
2021-03-11 21:09:57,585 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]]
2021-03-11 21:09:57,585 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:57,585 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]
2021-03-11 21:09:57,677 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:57,678 [main:117] - GENERATED CALL = (iarg1).toByte().times(18)
2021-03-11 21:09:57,678 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]]
2021-03-11 21:09:57,678 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:09:57,678 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]
2021-03-11 21:09:57,678 [main:117] - GENERATED CALL = (iarg1).compareTo(iarg1).dec()
2021-03-11 21:09:57,678 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]]
2021-03-11 21:09:57,678 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:09:57,679 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]
2021-03-11 21:09:57,679 [main:117] - GENERATED CALL = (iarg1).toByte().toInt()
2021-03-11 21:09:57,679 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:09:57,679 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:57,679 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:09:57,679 [main:117] - GENERATED CALL = (iarg1).toInt().shr(iarg2)
2021-03-11 21:09:57,679 [main:113] - Case = [public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]]
2021-03-11 21:09:57,679 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]
2021-03-11 21:09:57,679 [main:117] - GENERATED CALL = (iarg1).xor(iarg1)
2021-03-11 21:09:57,679 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7de53db8]]
2021-03-11 21:09:57,679 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:09:57,679 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7de53db8]
2021-03-11 21:09:57,770 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:57,772 [main:117] - GENERATED CALL = (iarg1).toShort().rem(123)
2021-03-11 21:09:57,772 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]]
2021-03-11 21:09:57,772 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:09:57,864 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:57,865 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]
2021-03-11 21:09:57,958 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:57,959 [main:117] - GENERATED CALL = (iarg1).div(0.7783532367904851).compareTo(75)
2021-03-11 21:09:57,959 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]]
2021-03-11 21:09:57,959 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:57,959 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]
2021-03-11 21:09:57,959 [main:117] - GENERATED CALL = (iarg1).toInt().dec()
2021-03-11 21:09:57,959 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]]
2021-03-11 21:09:57,959 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:57,959 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:09:57,960 [main:117] - GENERATED CALL = (iarg1).toInt().toInt()
2021-03-11 21:09:57,960 [main:61] - replacement of iarg1 or  iarg2 of type Int is (iarg1).xor(iarg1)
2021-03-11 21:09:58,077 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:58,077 [main:66] - Compilation checking started
2021-03-11 21:09:58,572 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr 32
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:09:58,573 [main:53] - replacing (s2, Short?)
2021-03-11 21:09:58,573 [main:50] - replacing s2 Short?
2021-03-11 21:09:58,573 [main:54] - Getting value of type Short?
2021-03-11 21:09:58,665 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:58,667 [main:58] - GENERATED VALUE OF TYPE Short? = 19239
2021-03-11 21:09:58,667 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:58,669 [main:67] - randomType = UInt
2021-03-11 21:09:58,761 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:09:58,787 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@6a70b7da]
2021-03-11 21:09:58,787 [main:149] - GENERATING call of type public fun kotlin.Short.coerceAtLeast(minimumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@511a853a]
2021-03-11 21:09:58,879 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:09:58,880 [main:78] - Generated call from random type = (1508361054.toUInt()).toShort().coerceAtLeast(-6580)
2021-03-11 21:09:58,880 [main:61] - replacement of s2 of type Short? is (1508361054.toUInt()).toShort().coerceAtLeast(-6580)
2021-03-11 21:09:58,971 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:09:58,973 [main:53] - replacing (32, Int)
2021-03-11 21:09:58,974 [main:50] - replacing 32 Int
2021-03-11 21:09:58,974 [main:54] - Getting value of type Int
2021-03-11 21:09:59,066 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:09:59,067 [main:58] - GENERATED VALUE OF TYPE Int = -2812401
2021-03-11 21:09:59,067 [main:61] - GENERATED IS CALL =false
2021-03-11 21:09:59,070 [main:67] - randomType = Double
2021-03-11 21:09:59,161 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:59,190 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toShort(): kotlin.Short defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@1f9f550e]
2021-03-11 21:09:59,190 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]
2021-03-11 21:09:59,282 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:59,283 [main:78] - Generated call from random type = (0.4427894609504168).toShort().plus(-49)
2021-03-11 21:09:59,284 [main:106] - GETTING Int from Long
2021-03-11 21:09:59,313 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]]
2021-03-11 21:09:59,313 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:59,313 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]
2021-03-11 21:09:59,313 [main:117] - GENERATED CALL = (larg2).toInt().takeLowestOneBit()
2021-03-11 21:09:59,313 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@71628c83]]
2021-03-11 21:09:59,313 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:09:59,314 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@71628c83]
2021-03-11 21:09:59,405 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:59,407 [main:117] - GENERATED CALL = (larg2).toByte().rem(-73)
2021-03-11 21:09:59,407 [main:113] - Case = [public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@6d42a613], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5694be4c]]
2021-03-11 21:09:59,407 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@6d42a613]
2021-03-11 21:09:59,498 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:09:59,499 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5694be4c]
2021-03-11 21:09:59,500 [main:117] - GENERATED CALL = (larg2).div(0.95748645f).toBits()
2021-03-11 21:09:59,500 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4a848b8e]]
2021-03-11 21:09:59,500 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:59,500 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4a848b8e]
2021-03-11 21:09:59,592 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:59,593 [main:117] - GENERATED CALL = (larg2).toInt().compareTo(-38)
2021-03-11 21:09:59,593 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]]
2021-03-11 21:09:59,593 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:09:59,593 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]
2021-03-11 21:09:59,594 [main:117] - GENERATED CALL = (larg2).toDouble().toInt()
2021-03-11 21:09:59,594 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]]
2021-03-11 21:09:59,594 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:09:59,594 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]
2021-03-11 21:09:59,594 [main:117] - GENERATED CALL = (larg2).toLong().countTrailingZeroBits()
2021-03-11 21:09:59,594 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]]
2021-03-11 21:09:59,594 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:09:59,594 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]
2021-03-11 21:09:59,594 [main:117] - GENERATED CALL = (larg2).toInt().or(iarg1)
2021-03-11 21:09:59,594 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:09:59,594 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:59,686 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:59,688 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:09:59,780 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:59,781 [main:117] - GENERATED CALL = (larg2).compareTo(26).rem(0)
2021-03-11 21:09:59,781 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], @kotlin.SinceKotlin public fun kotlin.Double.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@5645a0d]]
2021-03-11 21:09:59,781 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:09:59,873 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:09:59,874 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Double.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@5645a0d]
2021-03-11 21:09:59,874 [main:117] - GENERATED CALL = (larg2).div(0.5236326799073313).roundToInt()
2021-03-11 21:09:59,874 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]]
2021-03-11 21:09:59,874 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:09:59,988 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:09:59,989 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]
2021-03-11 21:10:00,090 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:00,091 [main:117] - GENERATED CALL = (larg2).compareTo(94).minus(3)
2021-03-11 21:10:00,091 [main:61] - replacement of 32 of type Int is (larg2).toInt().compareTo(-38)
2021-03-11 21:10:00,182 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:00,182 [main:66] - Compilation checking started
2021-03-11 21:10:00,515 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:00,516 [main:53] - replacing (larg1, Long)
2021-03-11 21:10:00,516 [main:50] - replacing larg1 Long
2021-03-11 21:10:00,516 [main:54] - Getting value of type Long
2021-03-11 21:10:00,609 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:00,610 [main:58] - GENERATED VALUE OF TYPE Long = 3551833715750354464
2021-03-11 21:10:00,610 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:00,613 [main:67] - randomType = Float
2021-03-11 21:10:00,705 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:10:00,734 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@46fab768]
2021-03-11 21:10:00,825 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:00,826 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@73616745]
2021-03-11 21:10:00,918 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:00,919 [main:78] - Generated call from random type = (0.5746803f).compareTo(68).plus(2057826241332818764)
2021-03-11 21:10:00,919 [main:61] - replacement of larg1 of type Long is 3551833715750354464
2021-03-11 21:10:01,011 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:01,011 [main:53] - replacing (32, Int)
2021-03-11 21:10:01,011 [main:50] - replacing 32 Int
2021-03-11 21:10:01,011 [main:54] - Getting value of type Int
2021-03-11 21:10:01,103 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:01,104 [main:58] - GENERATED VALUE OF TYPE Int = -2101200975
2021-03-11 21:10:01,104 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:01,204 [main:67] - randomType = UByte
2021-03-11 21:10:01,296 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:10:01,328 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toInt(): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@232050cb]
2021-03-11 21:10:01,329 [main:78] - Generated call from random type = (89.toUByte()).toInt()
2021-03-11 21:10:01,329 [main:61] - replacement of 32 of type Int is -2101200975
2021-03-11 21:10:01,420 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-11 21:10:01,422 [main:53] - replacing ((6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort(), Boolean)
2021-03-11 21:10:01,423 [main:50] - replacing (6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort() Boolean
2021-03-11 21:10:01,423 [main:54] - Getting value of type Boolean
2021-03-11 21:10:01,515 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:01,516 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:10:01,516 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:01,865 [main:67] - randomType = Map<Long?, Triple<UInt, Byte, Char>>?
2021-03-11 21:10:01,866 [main:106] - GETTING Boolean from Long
2021-03-11 21:10:01,894 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]]
2021-03-11 21:10:01,894 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:01,894 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]
2021-03-11 21:10:01,894 [main:117] - GENERATED CALL = (larg1).toChar().isISOControl()
2021-03-11 21:10:01,894 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]]
2021-03-11 21:10:01,895 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:01,895 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]
2021-03-11 21:10:01,895 [main:117] - GENERATED CALL = (larg1).toChar().isHighSurrogate()
2021-03-11 21:10:01,895 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:10:01,895 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:10:01,986 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:01,988 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:10:01,988 [main:117] - GENERATED CALL = (larg1).div(0.6883779558128149).isNaN()
2021-03-11 21:10:01,988 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:10:01,988 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:10:01,988 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:10:02,079 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:02,080 [main:117] - GENERATED CALL = (larg1).toDouble().equals("oqduh")
2021-03-11 21:10:02,080 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@67ca72ba]]
2021-03-11 21:10:02,080 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:10:02,171 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:02,171 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@67ca72ba]
2021-03-11 21:10:02,263 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:02,264 [main:117] - GENERATED CALL = (larg1).equals("lbyep").equals("zdylp")
2021-03-11 21:10:02,264 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]]
2021-03-11 21:10:02,264 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:10:02,355 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:02,355 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]
2021-03-11 21:10:02,447 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:02,448 [main:117] - GENERATED CALL = (larg1).equals("lxvhe").or(false)
2021-03-11 21:10:02,448 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]]
2021-03-11 21:10:02,448 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:02,448 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]
2021-03-11 21:10:02,448 [main:117] - GENERATED CALL = (larg1).toChar().isDigit()
2021-03-11 21:10:02,448 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]]
2021-03-11 21:10:02,449 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:10:02,449 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]
2021-03-11 21:10:02,449 [main:117] - GENERATED CALL = (larg1).toFloat().isNaN()
2021-03-11 21:10:02,449 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]]
2021-03-11 21:10:02,449 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:02,449 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:10:02,540 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:02,541 [main:117] - GENERATED CALL = (larg1).toLong().equals("ochyq")
2021-03-11 21:10:02,541 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]]
2021-03-11 21:10:02,541 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:02,541 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]
2021-03-11 21:10:02,541 [main:117] - GENERATED CALL = (larg1).toChar().isDefined()
2021-03-11 21:10:02,541 [main:61] - replacement of (6111397445261622474.toULong()).toUInt().toShort() != 0xB98A.toShort() of type Boolean is (larg1).div(0.6883779558128149).isNaN()
2021-03-11 21:10:02,633 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:02,633 [main:66] - Compilation checking started
2021-03-11 21:10:02,948 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if (i6 != 1733995329) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:02,951 [main:53] - replacing (i6 != 1733995329, Boolean)
2021-03-11 21:10:02,953 [main:50] - replacing i6 != 1733995329 Boolean
2021-03-11 21:10:02,953 [main:54] - Getting value of type Boolean
2021-03-11 21:10:03,048 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:03,049 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:10:03,049 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:03,052 [main:67] - randomType = Boolean
2021-03-11 21:10:03,153 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:03,162 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1c6b7dcc]
2021-03-11 21:10:03,162 [main:78] - Generated call from random type = (true).not()
2021-03-11 21:10:03,163 [main:106] - GETTING Boolean from Int?
2021-03-11 21:10:03,193 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]]
2021-03-11 21:10:03,193 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:03,194 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]
2021-03-11 21:10:03,286 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:03,286 [main:117] - GENERATED CALL = (i2).toShort().equals("lvelq")
2021-03-11 21:10:03,286 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:10:03,286 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:10:03,377 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:03,378 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:10:03,379 [main:117] - GENERATED CALL = (i2).div(0.6346517159492792).isFinite()
2021-03-11 21:10:03,379 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]]
2021-03-11 21:10:03,379 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:03,379 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]
2021-03-11 21:10:03,379 [main:117] - GENERATED CALL = (i2).toChar().isHighSurrogate()
2021-03-11 21:10:03,379 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@30647e03]]
2021-03-11 21:10:03,379 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:03,470 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:03,471 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@30647e03]
2021-03-11 21:10:03,586 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:03,587 [main:117] - GENERATED CALL = (i2).rangeTo(-114).equals("lifoq")
2021-03-11 21:10:03,587 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]]
2021-03-11 21:10:03,587 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:03,587 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]
2021-03-11 21:10:03,587 [main:117] - GENERATED CALL = (i2).toChar().isDefined()
2021-03-11 21:10:03,587 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:10:03,587 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:10:03,587 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:10:03,587 [main:117] - GENERATED CALL = (i2).toDouble().isFinite()
2021-03-11 21:10:03,587 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]]
2021-03-11 21:10:03,587 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:03,588 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]
2021-03-11 21:10:03,588 [main:117] - GENERATED CALL = (i2).toChar().isTitleCase()
2021-03-11 21:10:03,588 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]]
2021-03-11 21:10:03,588 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:03,679 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:03,679 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]
2021-03-11 21:10:03,771 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:03,772 [main:117] - GENERATED CALL = (i2).equals("jwhde").and(true)
2021-03-11 21:10:03,772 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]]
2021-03-11 21:10:03,772 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:03,772 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:10:03,863 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:03,863 [main:117] - GENERATED CALL = (i2).toLong().equals("kgkhb")
2021-03-11 21:10:03,863 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c00b3f8]]
2021-03-11 21:10:03,864 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:03,864 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c00b3f8]
2021-03-11 21:10:03,955 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:10:04,047 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:04,048 [main:117] - GENERATED CALL = (i2).toChar().equals('弖', false)
2021-03-11 21:10:04,048 [main:61] - replacement of i6 != 1733995329 of type Boolean is (i2).equals("jwhde").and(true)
2021-03-11 21:10:04,139 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:04,139 [main:66] - Compilation checking started
2021-03-11 21:10:04,455 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:04,455 [main:53] - replacing (0xB98A.toShort(), Short)
2021-03-11 21:10:04,455 [main:50] - replacing 0xB98A.toShort() Short
2021-03-11 21:10:04,456 [main:54] - Getting value of type Short
2021-03-11 21:10:04,572 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:04,573 [main:58] - GENERATED VALUE OF TYPE Short = 20242
2021-03-11 21:10:04,573 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:04,774 [main:67] - randomType = ULong?
2021-03-11 21:10:04,866 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:10:04,894 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@43b632af]
2021-03-11 21:10:04,895 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:10:04,895 [main:78] - Generated call from random type = (2752190128898951669.toULong())?.toLong().toShort()
2021-03-11 21:10:04,895 [main:61] - replacement of 0xB98A.toShort() of type Short is 20242
2021-03-11 21:10:04,986 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:04,989 [main:53] - replacing ("fail: Byte.xor", String)
2021-03-11 21:10:04,989 [main:50] - replacing "fail: Byte.xor" String
2021-03-11 21:10:04,989 [main:54] - Getting value of type String
2021-03-11 21:10:05,080 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:05,081 [main:58] - GENERATED VALUE OF TYPE String = "svajb"
2021-03-11 21:10:05,082 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:05,394 [main:67] - randomType = Array<HashMap<Short?, Long>?>
2021-03-11 21:10:05,512 [main:302] - generating value of type = Array<HashMap<Short?, Long>?> false depth = 0
2021-03-11 21:10:05,610 [main:43] - GENERATING CALL OF fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->HashMap<Short?, Long>?): Array<HashMap<Short?, Long>?> = TODO()
2021-03-11 21:10:05,612 [main:61] - WITHOUT TYPE PARAMS = fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->HashMap<Short?, Long>?): Array<HashMap<Short?, Long>?> = TODO()
2021-03-11 21:10:05,911 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:10:05,912 [main:302] - generating value of type = Function1<Int, HashMap<Short?, Long>?> false depth = 3
2021-03-11 21:10:05,914 [main:302] - generating value of type = HashMap<Short?, Long> false depth = 4
2021-03-11 21:10:06,010 [main:43] - GENERATING CALL OF fun <K, V> hashMapOf(pairs: Pair<Short?, Long>): HashMap<Short?, Long> = TODO()
2021-03-11 21:10:06,013 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> hashMapOf(pairs: Pair<Short?, Long>): HashMap<Short?, Long> = TODO()
2021-03-11 21:10:06,108 [main:302] - generating value of type = Pair<Short?, Long> false depth = 7
2021-03-11 21:10:06,205 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Short?, second: Long): Pair<Short?, Long> = TODO()
2021-03-11 21:10:06,208 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Short?, second: Long): Pair<Short?, Long> = TODO()
2021-03-11 21:10:06,304 [main:302] - generating value of type = Short true depth = 10
2021-03-11 21:10:06,305 [main:302] - generating value of type = Long true depth = 10
2021-03-11 21:10:06,306 [main:95] - GENERATED = Pair<Short?, Long>(7785, 4727138064031849716)
2021-03-11 21:10:06,306 [main:95] - GENERATED = hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))
2021-03-11 21:10:06,307 [main:95] - GENERATED = Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})
2021-03-11 21:10:06,332 [main:149] - GENERATING call of type @kotlin.Deprecated @kotlin.SinceKotlin @kotlin.DeprecatedSinceKotlin public fun <T> kotlin.Array<out T>.contentToString(): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@2d8853ee]
2021-03-11 21:10:06,333 [main:78] - Generated call from random type = (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
2021-03-11 21:10:06,333 [main:61] - replacement of "fail: Byte.xor" of type String is (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
2021-03-11 21:10:06,426 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:06,427 [main:66] - Compilation checking started
2021-03-11 21:10:07,100 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:07,101 [main:53] - replacing (32, Int)
2021-03-11 21:10:07,101 [main:50] - replacing 32 Int
2021-03-11 21:10:07,101 [main:54] - Getting value of type Int
2021-03-11 21:10:07,246 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:07,248 [main:58] - GENERATED VALUE OF TYPE Int = 716235008
2021-03-11 21:10:07,248 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:07,389 [main:67] - randomType = UShort
2021-03-11 21:10:07,512 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:10:07,559 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@53aaab5e]
2021-03-11 21:10:07,559 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@2f62c5fb]
2021-03-11 21:10:07,559 [main:78] - Generated call from random type = (4313.toUShort()).toFloat().toInt()
2021-03-11 21:10:07,559 [main:61] - replacement of 32 of type Int is (4313.toUShort()).toFloat().toInt()
2021-03-11 21:10:07,687 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:07,687 [main:53] - replacing (0xDC56DC56L, Long)
2021-03-11 21:10:07,687 [main:50] - replacing 0xDC56DC56L Long
2021-03-11 21:10:07,687 [main:54] - Getting value of type Long
2021-03-11 21:10:07,808 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:07,810 [main:58] - GENERATED VALUE OF TYPE Long = 4316068163002831486
2021-03-11 21:10:07,810 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:07,814 [main:67] - randomType = Boolean
2021-03-11 21:10:07,963 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:07,978 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:10:08,093 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:08,095 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]
2021-03-11 21:10:08,218 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:08,221 [main:78] - Generated call from random type = (false).compareTo(false).rem(-3401777080404062439)
2021-03-11 21:10:08,221 [main:61] - replacement of 0xDC56DC56L of type Long is 4316068163002831486
2021-03-11 21:10:08,355 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:08,356 [main:53] - replacing ("fail: Long.and", String)
2021-03-11 21:10:08,356 [main:50] - replacing "fail: Long.and" String
2021-03-11 21:10:08,356 [main:54] - Getting value of type String
2021-03-11 21:10:08,462 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:08,464 [main:58] - GENERATED VALUE OF TYPE String = "lhswi"
2021-03-11 21:10:08,464 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:09,100 [main:67] - randomType = Function1<Long, HashSet<LinkedHashMap<UInt?, Byte>>?>
2021-03-11 21:10:09,101 [main:61] - replacement of "fail: Long.and" of type String is "lhswi"
2021-03-11 21:10:09,205 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-11 21:10:09,206 [main:53] - replacing (32, Int)
2021-03-11 21:10:09,206 [main:50] - replacing 32 Int
2021-03-11 21:10:09,206 [main:54] - Getting value of type Int
2021-03-11 21:10:09,307 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:09,309 [main:58] - GENERATED VALUE OF TYPE Int = 183233452
2021-03-11 21:10:09,309 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:09,314 [main:67] - randomType = Double
2021-03-11 21:10:09,419 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:09,465 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]
2021-03-11 21:10:09,566 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:09,568 [main:78] - Generated call from random type = (0.28697110696890693).compareTo(28).absoluteValue
2021-03-11 21:10:09,568 [main:61] - replacement of 32 of type Int is (0.28697110696890693).compareTo(28).absoluteValue
2021-03-11 21:10:09,670 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:09,674 [main:53] - replacing (b3, Byte?)
2021-03-11 21:10:09,675 [main:50] - replacing b3 Byte?
2021-03-11 21:10:09,675 [main:54] - Getting value of type Byte?
2021-03-11 21:10:09,781 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:09,783 [main:58] - GENERATED VALUE OF TYPE Byte? = 54
2021-03-11 21:10:09,783 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:09,901 [main:67] - randomType = ULong
2021-03-11 21:10:10,008 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:10:10,049 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@13e6b8da]
2021-03-11 21:10:10,049 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateRight(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@7447e4aa]
2021-03-11 21:10:10,199 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:10,201 [main:78] - Generated call from random type = (694355064099464817.toULong()).toByte().rotateRight(1182231873)
2021-03-11 21:10:10,201 [main:61] - replacement of b3 of type Byte? is (694355064099464817.toULong()).toByte().rotateRight(1182231873)
2021-03-11 21:10:10,305 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:10,305 [main:66] - Compilation checking started
2021-03-11 21:10:10,808 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:10,811 [main:53] - replacing (i2 != (-9).toLong().toInt(), Boolean)
2021-03-11 21:10:10,814 [main:50] - replacing i2 != (-9).toLong().toInt() Boolean
2021-03-11 21:10:10,814 [main:54] - Getting value of type Boolean
2021-03-11 21:10:10,944 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:10,947 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:10:10,947 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:11,087 [main:67] - randomType = UShort
2021-03-11 21:10:11,198 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:10:11,243 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@54d09591]
2021-03-11 21:10:11,243 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]
2021-03-11 21:10:11,243 [main:78] - Generated call from random type = (4554.toUShort()).toFloat().isNaN()
2021-03-11 21:10:11,244 [main:106] - GETTING Boolean from Int?
2021-03-11 21:10:11,283 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:10:11,283 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:11,284 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:11,385 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:11,386 [main:117] - GENERATED CALL = (i1).compareTo(iarg1).equals("lpplc")
2021-03-11 21:10:11,386 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@30647e03]]
2021-03-11 21:10:11,386 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:11,489 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:11,491 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@30647e03]
2021-03-11 21:10:11,591 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:11,592 [main:117] - GENERATED CALL = (i1).rangeTo(112).equals("herix")
2021-03-11 21:10:11,592 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:10:11,592 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:11,592 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:10:11,592 [main:117] - GENERATED CALL = (i1).toChar().isWhitespace()
2021-03-11 21:10:11,592 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@576eefea]]
2021-03-11 21:10:11,592 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:11,592 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@576eefea]
2021-03-11 21:10:11,592 [main:117] - GENERATED CALL = (i1).toChar().isSurrogate()
2021-03-11 21:10:11,592 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:10:11,592 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:11,693 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:11,693 [main:117] - GENERATED CALL = (i1).equals("wzwob")
2021-03-11 21:10:11,693 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@58303fc8]]
2021-03-11 21:10:11,693 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:11,811 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:11,813 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@58303fc8]
2021-03-11 21:10:11,813 [main:117] - GENERATED CALL = (i1).rangeTo(-26).isEmpty()
2021-03-11 21:10:11,813 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]]
2021-03-11 21:10:11,813 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:10:11,813 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]
2021-03-11 21:10:11,913 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:11,914 [main:117] - GENERATED CALL = (i1).toFloat().equals("karav")
2021-03-11 21:10:11,914 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]]
2021-03-11 21:10:11,914 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:11,914 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]
2021-03-11 21:10:11,914 [main:117] - GENERATED CALL = (i1).toChar().isLetterOrDigit()
2021-03-11 21:10:11,914 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]]
2021-03-11 21:10:11,914 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:11,914 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]
2021-03-11 21:10:11,914 [main:117] - GENERATED CALL = (i1).toChar().isLetter()
2021-03-11 21:10:11,915 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:10:11,915 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:12,013 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:12,015 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:12,113 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:12,113 [main:117] - GENERATED CALL = (i1).and(-711636084).equals("hwqxa")
2021-03-11 21:10:12,114 [main:61] - replacement of i2 != (-9).toLong().toInt() of type Boolean is (i1).toChar().isLetter()
2021-03-11 21:10:12,222 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:12,222 [main:66] - Compilation checking started
2021-03-11 21:10:12,553 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if ((i1).toChar().isLetter()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:12,556 [main:53] - replacing (larg2, Long)
2021-03-11 21:10:12,557 [main:50] - replacing larg2 Long
2021-03-11 21:10:12,557 [main:54] - Getting value of type Long
2021-03-11 21:10:12,656 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:12,658 [main:58] - GENERATED VALUE OF TYPE Long = 338479895306171129
2021-03-11 21:10:12,658 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:12,663 [main:67] - randomType = String
2021-03-11 21:10:12,760 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:12,782 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.sumOf(selector: (kotlin.Char) -> kotlin.Long): kotlin.Long defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7766673e]
2021-03-11 21:10:12,880 [main:302] - generating value of type = Function1<Char, Long> false depth = 0
2021-03-11 21:10:12,882 [main:302] - generating value of type = Long true depth = 1
2021-03-11 21:10:12,884 [main:78] - Generated call from random type = ("mrgcs").sumOf({a: Char -> -3413485493574704913})
2021-03-11 21:10:12,885 [main:106] - GETTING Long from Long?
2021-03-11 21:10:12,915 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public open fun toLong(): kotlin.Long defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@41b9c30]]
2021-03-11 21:10:12,915 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:10:13,014 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:13,016 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@41b9c30]
2021-03-11 21:10:13,016 [main:117] - GENERATED CALL = (l1).div(0.7820904114785637).toLong()
2021-03-11 21:10:13,016 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9], public open val endInclusive: kotlin.Long defined in kotlin.ranges.LongRange[DeserializedPropertyDescriptor@6edd0e0a]]
2021-03-11 21:10:13,016 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9]
2021-03-11 21:10:13,113 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:13,116 [main:117] - GENERATED CALL = (l1).rangeTo(55).endInclusive
2021-03-11 21:10:13,116 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]]
2021-03-11 21:10:13,116 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:13,116 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@34db86a7]
2021-03-11 21:10:13,116 [main:117] - GENERATED CALL = (l1).toLong().dec()
2021-03-11 21:10:13,116 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]]
2021-03-11 21:10:13,116 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:13,116 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:13,117 [main:117] - GENERATED CALL = (l1).and(larg2).and(larg1)
2021-03-11 21:10:13,117 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]]
2021-03-11 21:10:13,117 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:10:13,215 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:13,217 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]
2021-03-11 21:10:13,217 [main:117] - GENERATED CALL = (l1).div(0.07666850109418777).toBits()
2021-03-11 21:10:13,217 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]]
2021-03-11 21:10:13,217 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:13,217 [main:149] - GENERATING call of type public fun kotlin.Long.coerceAtLeast(minimumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7a09f358]
2021-03-11 21:10:13,217 [main:117] - GENERATED CALL = (l1).toLong().coerceAtLeast(larg1)
2021-03-11 21:10:13,217 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]]
2021-03-11 21:10:13,217 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:13,217 [main:149] - GENERATING call of type public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]
2021-03-11 21:10:13,218 [main:117] - GENERATED CALL = (l1).and(larg1).inv()
2021-03-11 21:10:13,218 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@21433be]]
2021-03-11 21:10:13,218 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:13,218 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@21433be]
2021-03-11 21:10:13,315 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:13,317 [main:117] - GENERATED CALL = (l1).toByte().minus(-6988386732482020802)
2021-03-11 21:10:13,317 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun toLong(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1123c95f]]
2021-03-11 21:10:13,317 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:13,317 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1123c95f]
2021-03-11 21:10:13,317 [main:117] - GENERATED CALL = (l1).toLong().toLong()
2021-03-11 21:10:13,317 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final operator fun minus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@51f8c7aa]]
2021-03-11 21:10:13,317 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:13,415 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:13,417 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@51f8c7aa]
2021-03-11 21:10:13,514 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:13,516 [main:117] - GENERATED CALL = (l1).and(1849879090826232513).minus(-83)
2021-03-11 21:10:13,516 [main:61] - replacement of larg2 of type Long is l1
2021-03-11 21:10:13,613 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:10:13,613 [main:66] - Compilation checking started
2021-03-11 21:10:13,900 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and l1
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:13,904 [main:53] - replacing ("fail: Int.and", String)
2021-03-11 21:10:13,907 [main:50] - replacing "fail: Int.and" String
2021-03-11 21:10:13,907 [main:54] - Getting value of type String
2021-03-11 21:10:14,008 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:14,010 [main:58] - GENERATED VALUE OF TYPE String = "chepa"
2021-03-11 21:10:14,010 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:14,244 [main:67] - randomType = Function1<Short?, UShort>
2021-03-11 21:10:14,245 [main:106] - GETTING String from Int
2021-03-11 21:10:14,274 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:14,274 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:14,274 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:14,274 [main:117] - GENERATED CALL = (iarg1).toInt().toString(iarg1)
2021-03-11 21:10:14,274 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:10:14,274 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:14,274 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:10:14,275 [main:117] - GENERATED CALL = (iarg1).toShort().toString(iarg2)
2021-03-11 21:10:14,275 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:10:14,275 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:14,275 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:10:14,275 [main:117] - GENERATED CALL = (iarg1).toChar().uppercase()
2021-03-11 21:10:14,275 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:14,275 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:10:14,373 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:14,375 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:14,375 [main:117] - GENERATED CALL = (iarg1).div(6041018719415819233).toString(iarg2)
2021-03-11 21:10:14,375 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:10:14,375 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:14,375 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:10:14,375 [main:117] - GENERATED CALL = (iarg1).toChar().titlecase()
2021-03-11 21:10:14,375 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:14,376 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:14,475 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:14,477 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:14,600 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:14,602 [main:117] - GENERATED CALL = (iarg1).compareTo(-511123127).toString(1878286202)
2021-03-11 21:10:14,602 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:14,602 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:14,602 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:14,699 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:14,701 [main:117] - GENERATED CALL = (iarg1).toLong().toString(60880169)
2021-03-11 21:10:14,701 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:10:14,701 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:14,701 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:10:14,797 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:14,799 [main:117] - GENERATED CALL = (iarg1).toChar().plus("dpuzo")
2021-03-11 21:10:14,800 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:14,800 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:14,800 [main:117] - GENERATED CALL = (iarg1).toString(iarg2)
2021-03-11 21:10:14,800 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:10:14,800 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:14,800 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:10:14,800 [main:117] - GENERATED CALL = (iarg1).toByte().toString(iarg2)
2021-03-11 21:10:14,800 [main:61] - replacement of "fail: Int.and" of type String is (iarg1).toInt().toString(iarg1)
2021-03-11 21:10:14,898 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:14,898 [main:66] - Compilation checking started
2021-03-11 21:10:15,328 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:15,328 [main:53] - replacing (iarg1 or  iarg2, Int)
2021-03-11 21:10:15,328 [main:50] - replacing iarg1 or  iarg2 Int
2021-03-11 21:10:15,328 [main:54] - Getting value of type Int
2021-03-11 21:10:15,447 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:15,449 [main:58] - GENERATED VALUE OF TYPE Int = -1550683340
2021-03-11 21:10:15,449 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:15,673 [main:67] - randomType = ArrayList<UShort>
2021-03-11 21:10:15,770 [main:302] - generating value of type = ArrayList<UShort> false depth = 0
2021-03-11 21:10:15,872 [main:43] - GENERATING CALL OF fun <T> arrayListOf(): ArrayList<UShort> = TODO()
2021-03-11 21:10:15,875 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(): ArrayList<UShort> = TODO()
2021-03-11 21:10:15,985 [main:95] - GENERATED = arrayListOf<UShort>()
2021-03-11 21:10:16,133 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]
2021-03-11 21:10:16,133 [main:78] - Generated call from random type = (arrayListOf<UShort>()).modCount.unaryMinus()
2021-03-11 21:10:16,133 [main:61] - replacement of iarg1 or  iarg2 of type Int is (arrayListOf<UShort>()).modCount.unaryMinus()
2021-03-11 21:10:16,232 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:16,235 [main:53] - replacing ("fail: Short.xor", String)
2021-03-11 21:10:16,236 [main:50] - replacing "fail: Short.xor" String
2021-03-11 21:10:16,236 [main:54] - Getting value of type String
2021-03-11 21:10:16,337 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:16,339 [main:58] - GENERATED VALUE OF TYPE String = "hkckn"
2021-03-11 21:10:16,339 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:16,345 [main:67] - randomType = Int
2021-03-11 21:10:16,444 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:16,483 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:16,484 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:10:16,484 [main:78] - Generated call from random type = (-1659840850).toByte().toString(iarg1)
2021-03-11 21:10:16,485 [main:106] - GETTING String from Long?
2021-03-11 21:10:16,524 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:10:16,524 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:16,524 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:10:16,524 [main:117] - GENERATED CALL = (l3).toChar().titlecase()
2021-03-11 21:10:16,524 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:16,524 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:16,524 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:16,629 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:16,631 [main:117] - GENERATED CALL = (l3).toInt().toString(-1384014725)
2021-03-11 21:10:16,631 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:10:16,631 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:16,632 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:10:16,632 [main:117] - GENERATED CALL = (l3).toChar().lowercase()
2021-03-11 21:10:16,632 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:16,632 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:10:16,758 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:16,760 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:16,760 [main:117] - GENERATED CALL = (l3).compareTo(42).toString(iarg2)
2021-03-11 21:10:16,760 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:16,760 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:16,760 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:16,760 [main:117] - GENERATED CALL = (l3).toLong().toString(iarg2)
2021-03-11 21:10:16,761 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:10:16,761 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:16,761 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:10:16,761 [main:117] - GENERATED CALL = (l3).toChar().uppercase()
2021-03-11 21:10:16,761 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:10:16,761 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:16,761 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:10:16,863 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:16,865 [main:117] - GENERATED CALL = (l3).toChar().plus("sgotx")
2021-03-11 21:10:16,865 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:16,866 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:16,866 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:16,866 [main:117] - GENERATED CALL = (l3).and(larg1).toString(iarg2)
2021-03-11 21:10:16,866 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:10:16,866 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:10:16,866 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:10:16,970 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:16,973 [main:117] - GENERATED CALL = (l3).toShort().toString(-828029626)
2021-03-11 21:10:16,975 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:10:16,975 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:16,975 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:10:16,975 [main:117] - GENERATED CALL = (l3).toByte().toString(iarg2)
2021-03-11 21:10:16,975 [main:61] - replacement of "fail: Short.xor" of type String is (l3).toLong().toString(iarg2)
2021-03-11 21:10:17,076 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:17,076 [main:66] - Compilation checking started
2021-03-11 21:10:17,468 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:17,472 [main:53] - replacing (iarg1, Int)
2021-03-11 21:10:17,475 [main:50] - replacing iarg1 Int
2021-03-11 21:10:17,475 [main:54] - Getting value of type Int
2021-03-11 21:10:17,600 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:17,602 [main:58] - GENERATED VALUE OF TYPE Int = -900420604
2021-03-11 21:10:17,602 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:17,716 [main:67] - randomType = UShort
2021-03-11 21:10:17,827 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:10:17,855 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toUByte(): kotlin.UByte defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@5ef27843]
2021-03-11 21:10:17,855 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByte.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@72ebfc21]
2021-03-11 21:10:17,855 [main:78] - Generated call from random type = (22331.toUShort()).toUByte().countTrailingZeroBits()
2021-03-11 21:10:17,855 [main:61] - replacement of iarg1 of type Int is (22331.toUShort()).toUByte().countTrailingZeroBits()
2021-03-11 21:10:17,953 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:17,953 [main:66] - Compilation checking started
2021-03-11 21:10:18,367 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if (l1 != 0x4454445444544454) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:18,368 [main:53] - replacing (iarg2, Int)
2021-03-11 21:10:18,368 [main:50] - replacing iarg2 Int
2021-03-11 21:10:18,368 [main:54] - Getting value of type Int
2021-03-11 21:10:18,473 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:18,475 [main:58] - GENERATED VALUE OF TYPE Int = 20724048
2021-03-11 21:10:18,475 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:18,967 [main:67] - randomType = Function2<Boolean, Function2<UInt, Short, Byte>, LinkedHashSet<UByte>>
2021-03-11 21:10:18,967 [main:61] - replacement of iarg2 of type Int is 20724048
2021-03-11 21:10:19,086 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:19,088 [main:53] - replacing (l1 != 0x4454445444544454, Boolean)
2021-03-11 21:10:19,090 [main:50] - replacing l1 != 0x4454445444544454 Boolean
2021-03-11 21:10:19,090 [main:54] - Getting value of type Boolean
2021-03-11 21:10:19,189 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:19,190 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:10:19,191 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:19,306 [main:67] - randomType = List<Double>
2021-03-11 21:10:19,307 [main:106] - GETTING Boolean from Int
2021-03-11 21:10:19,337 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@30647e03]]
2021-03-11 21:10:19,337 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:19,435 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:19,437 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@30647e03]
2021-03-11 21:10:19,535 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:19,536 [main:117] - GENERATED CALL = (iarg1).rangeTo(-88).equals("mmukf")
2021-03-11 21:10:19,536 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]]
2021-03-11 21:10:19,536 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:19,536 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]
2021-03-11 21:10:19,536 [main:117] - GENERATED CALL = (iarg1).toChar().isDefined()
2021-03-11 21:10:19,536 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]]
2021-03-11 21:10:19,536 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:19,536 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]
2021-03-11 21:10:19,537 [main:117] - GENERATED CALL = (iarg1).toChar().isUpperCase()
2021-03-11 21:10:19,537 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:10:19,537 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:10:19,537 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:10:19,537 [main:117] - GENERATED CALL = (iarg1).toDouble().isFinite()
2021-03-11 21:10:19,537 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:10:19,537 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:10:19,537 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:10:19,537 [main:117] - GENERATED CALL = (iarg1).toDouble().isInfinite()
2021-03-11 21:10:19,537 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:10:19,537 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:10:19,636 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:19,638 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:10:19,638 [main:117] - GENERATED CALL = (iarg1).div(0.792554942830994).isInfinite()
2021-03-11 21:10:19,638 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:10:19,638 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:19,737 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:19,739 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:19,838 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:19,838 [main:117] - GENERATED CALL = (iarg1).compareTo(-1073595951).equals("scusi")
2021-03-11 21:10:19,838 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]]
2021-03-11 21:10:19,838 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:19,838 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]
2021-03-11 21:10:19,839 [main:117] - GENERATED CALL = (iarg1).toChar().isLetterOrDigit()
2021-03-11 21:10:19,839 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:10:19,839 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:19,839 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:10:19,839 [main:117] - GENERATED CALL = (iarg1).toChar().isWhitespace()
2021-03-11 21:10:19,839 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]]
2021-03-11 21:10:19,839 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:19,839 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]
2021-03-11 21:10:19,839 [main:117] - GENERATED CALL = (iarg1).toChar().isLowSurrogate()
2021-03-11 21:10:19,839 [main:61] - replacement of l1 != 0x4454445444544454 of type Boolean is (iarg1).rangeTo(-88).equals("mmukf")
2021-03-11 21:10:19,937 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:19,937 [main:66] - Compilation checking started
2021-03-11 21:10:20,328 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:20,330 [main:53] - replacing (l4, Long?)
2021-03-11 21:10:20,332 [main:50] - replacing l4 Long?
2021-03-11 21:10:20,332 [main:54] - Getting value of type Long?
2021-03-11 21:10:20,443 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:20,445 [main:58] - GENERATED VALUE OF TYPE Long? = -2635757533525477200
2021-03-11 21:10:20,445 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:20,575 [main:67] - randomType = ArrayDeque<Long>
2021-03-11 21:10:20,681 [main:302] - generating value of type = ArrayDeque<Long> false depth = 0
2021-03-11 21:10:20,799 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(): ArrayDeque<Long> = TODO()
2021-03-11 21:10:20,803 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(): ArrayDeque<Long> = TODO()
2021-03-11 21:10:20,908 [main:95] - GENERATED = ArrayDeque<Long>()
2021-03-11 21:10:21,047 [main:149] - GENERATING call of type @kotlin.Deprecated @kotlin.DeprecatedSinceKotlin public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.minBy(selector: (T) -> R): T? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@21d6c7ba]
2021-03-11 21:10:21,148 [main:302] - generating value of type = Function1<T, R> false depth = 0
2021-03-11 21:10:21,150 [main:302] - generating value of type = R false depth = 1
2021-03-11 21:10:21,519 [main:43] - GENERATING CALL OF fun <R> run(block: ()->Function2<Byte?, Float, Boolean?>): R = TODO()
2021-03-11 21:10:21,522 [main:61] - WITHOUT TYPE PARAMS = fun <R> run(block: ()->Function2<Byte?, Float, Boolean?>): R = TODO()
2021-03-11 21:10:21,748 [main:302] - generating value of type = Function0<Function2<Byte?, Float, Boolean?>> false depth = 4
2021-03-11 21:10:21,750 [main:302] - generating value of type = Function2<Byte?, Float, Boolean?> false depth = 5
2021-03-11 21:10:21,751 [main:302] - generating value of type = Boolean true depth = 6
2021-03-11 21:10:21,754 [main:95] - GENERATED = run<Function2<Byte?, Float, Boolean?>>({ {a: Byte?, b: Float -> false}})
2021-03-11 21:10:21,754 [main:78] - Generated call from random type = (ArrayDeque<Long>()).minBy({a: T -> run<Function2<Byte?, Float, Boolean?>>({ {a: Byte?, b: Float -> false}})})
2021-03-11 21:10:21,754 [main:61] - replacement of l4 of type Long? is (ArrayDeque<Long>()).minBy({a: T -> run<Function2<Byte?, Float, Boolean?>>({ {a: Byte?, b: Float -> false}})})
2021-03-11 21:10:21,855 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:21,855 [main:66] - Compilation checking started
2021-03-11 21:10:22,305 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if ((ArrayDeque<Long>()).minBy({a: T -> run<Function2<Byte?, Float, Boolean?>>({ {a: Byte?, b: Float -> false}})}) != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-1668203291).div(0.08675039327629874).toByte() or  barg2
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:22,310 [main:53] - replacing ((-1668203291).div(0.08675039327629874).toByte() or  barg2, Byte)
2021-03-11 21:10:22,313 [main:50] - replacing (-1668203291).div(0.08675039327629874).toByte() or  barg2 Byte
2021-03-11 21:10:22,313 [main:54] - Getting value of type Byte
2021-03-11 21:10:22,435 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:22,437 [main:58] - GENERATED VALUE OF TYPE Byte = 119
2021-03-11 21:10:22,437 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:22,445 [main:67] - randomType = Long?
2021-03-11 21:10:22,552 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:22,599 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:22,722 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:22,725 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,726 [main:78] - Generated call from random type = (-2443963980816079306)?.and(-7493477219778897225).toByte()
2021-03-11 21:10:22,727 [main:106] - GETTING Byte from Long
2021-03-11 21:10:22,784 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun inc(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3f893413]]
2021-03-11 21:10:22,784 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,784 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3f893413]
2021-03-11 21:10:22,785 [main:117] - GENERATED CALL = (larg2).toByte().inc()
2021-03-11 21:10:22,785 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.or(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@55f7b16b]]
2021-03-11 21:10:22,785 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,785 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.or(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@55f7b16b]
2021-03-11 21:10:22,785 [main:117] - GENERATED CALL = (larg2).toByte().or(barg1)
2021-03-11 21:10:22,785 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]]
2021-03-11 21:10:22,785 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,785 [main:117] - GENERATED CALL = (larg2).toByte()
2021-03-11 21:10:22,785 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateLeft(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@1cf22470]]
2021-03-11 21:10:22,786 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,786 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateLeft(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@1cf22470]
2021-03-11 21:10:22,897 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:22,899 [main:117] - GENERATED CALL = (larg2).toByte().rotateLeft(1932654885)
2021-03-11 21:10:22,899 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public fun kotlin.Byte.coerceIn(minimumValue: kotlin.Byte, maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@66f9183]]
2021-03-11 21:10:22,899 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,899 [main:149] - GENERATING call of type public fun kotlin.Byte.coerceIn(minimumValue: kotlin.Byte, maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@66f9183]
2021-03-11 21:10:22,900 [main:117] - GENERATED CALL = (larg2).toByte().coerceIn(barg1, barg2)
2021-03-11 21:10:22,900 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]]
2021-03-11 21:10:22,900 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,900 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]
2021-03-11 21:10:22,900 [main:117] - GENERATED CALL = (larg2).toByte().takeHighestOneBit()
2021-03-11 21:10:22,900 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateRight(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@7447e4aa]]
2021-03-11 21:10:22,900 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:22,900 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Byte.rotateRight(bitCount: kotlin.Int): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@7447e4aa]
2021-03-11 21:10:23,012 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:23,014 [main:117] - GENERATED CALL = (larg2).toByte().rotateRight(-160613265)
2021-03-11 21:10:23,014 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public open fun toByte(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6b84f2be]]
2021-03-11 21:10:23,014 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:23,014 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6b84f2be]
2021-03-11 21:10:23,014 [main:117] - GENERATED CALL = (larg2).toByte().toByte()
2021-03-11 21:10:23,014 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.xor(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@3a9e4a66]]
2021-03-11 21:10:23,014 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:23,014 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.xor(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@3a9e4a66]
2021-03-11 21:10:23,015 [main:117] - GENERATED CALL = (larg2).toByte().xor(barg2)
2021-03-11 21:10:23,015 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]]
2021-03-11 21:10:23,015 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:23,015 [main:149] - GENERATING call of type public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]
2021-03-11 21:10:23,015 [main:117] - GENERATED CALL = (larg2).toByte().coerceAtMost(barg1)
2021-03-11 21:10:23,015 [main:61] - replacement of (-1668203291).div(0.08675039327629874).toByte() or  barg2 of type Byte is (-2443963980816079306)?.and(-7493477219778897225).toByte()
2021-03-11 21:10:23,124 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:23,124 [main:66] - Compilation checking started
2021-03-11 21:10:23,611 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:23,616 [main:53] - replacing (0x65.toByte(), Byte)
2021-03-11 21:10:23,619 [main:50] - replacing 0x65.toByte() Byte
2021-03-11 21:10:23,619 [main:54] - Getting value of type Byte
2021-03-11 21:10:23,778 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:23,781 [main:58] - GENERATED VALUE OF TYPE Byte = -82
2021-03-11 21:10:23,782 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:24,178 [main:67] - randomType = MutableMap<ArrayList<Char>, UShort>?
2021-03-11 21:10:24,179 [main:106] - GETTING Byte from Int?
2021-03-11 21:10:24,220 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]]
2021-03-11 21:10:24,220 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:24,220 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.takeHighestOneBit(): kotlin.Byte defined in kotlin[DeserializedSimpleFunctionDescriptor@28dd27cc]
2021-03-11 21:10:24,220 [main:117] - GENERATED CALL = (i6).toByte().takeHighestOneBit()
2021-03-11 21:10:24,220 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.or(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@55f7b16b]]
2021-03-11 21:10:24,220 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:24,220 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Byte.or(other: kotlin.Byte): kotlin.Byte defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@55f7b16b]
2021-03-11 21:10:24,221 [main:117] - GENERATED CALL = (i6).toByte().or(barg2)
2021-03-11 21:10:24,221 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]]
2021-03-11 21:10:24,221 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:24,221 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:24,221 [main:117] - GENERATED CALL = (i6).and(iarg1).toByte()
2021-03-11 21:10:24,221 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]]
2021-03-11 21:10:24,221 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:24,221 [main:149] - GENERATING call of type public fun kotlin.Byte.coerceAtMost(maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5ccdf14f]
2021-03-11 21:10:24,221 [main:117] - GENERATED CALL = (i6).toByte().coerceAtMost(barg1)
2021-03-11 21:10:24,221 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]]
2021-03-11 21:10:24,221 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:10:24,222 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@733a6500]
2021-03-11 21:10:24,222 [main:117] - GENERATED CALL = (i6).toDouble().toByte()
2021-03-11 21:10:24,222 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]]
2021-03-11 21:10:24,222 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:24,222 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:10:24,222 [main:117] - GENERATED CALL = (i6).toShort().toByte()
2021-03-11 21:10:24,222 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public fun kotlin.Byte.coerceIn(minimumValue: kotlin.Byte, maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@66f9183]]
2021-03-11 21:10:24,222 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:24,222 [main:149] - GENERATING call of type public fun kotlin.Byte.coerceIn(minimumValue: kotlin.Byte, maximumValue: kotlin.Byte): kotlin.Byte defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@66f9183]
2021-03-11 21:10:24,222 [main:117] - GENERATED CALL = (i6).toByte().coerceIn(barg2, barg1)
2021-03-11 21:10:24,222 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]]
2021-03-11 21:10:24,222 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:24,222 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:24,223 [main:117] - GENERATED CALL = (i6).toInt().toByte()
2021-03-11 21:10:24,223 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]]
2021-03-11 21:10:24,223 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:24,223 [main:117] - GENERATED CALL = (i6).toByte()
2021-03-11 21:10:24,223 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]]
2021-03-11 21:10:24,223 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:24,223 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:24,223 [main:117] - GENERATED CALL = (i6).toLong().toByte()
2021-03-11 21:10:24,223 [main:61] - replacement of 0x65.toByte() of type Byte is (i6).toByte().coerceAtMost(barg1)
2021-03-11 21:10:24,323 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:24,324 [main:66] - Compilation checking started
2021-03-11 21:10:24,652 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = (i6).toByte().coerceAtMost(barg1)
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:24,653 [main:53] - replacing (larg1, Long)
2021-03-11 21:10:24,653 [main:50] - replacing larg1 Long
2021-03-11 21:10:24,653 [main:54] - Getting value of type Long
2021-03-11 21:10:24,756 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:24,758 [main:58] - GENERATED VALUE OF TYPE Long = -8863430829987184867
2021-03-11 21:10:24,758 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:24,767 [main:67] - randomType = Short?
2021-03-11 21:10:24,870 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:24,938 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:10:24,938 [main:149] - GENERATING call of type public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]
2021-03-11 21:10:24,939 [main:78] - Generated call from random type = (4791)?.toChar().toLong()
2021-03-11 21:10:24,939 [main:61] - replacement of larg1 of type Long is (4791)?.toChar().toLong()
2021-03-11 21:10:25,045 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:25,047 [main:53] - replacing ((22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2, Int)
2021-03-11 21:10:25,049 [main:50] - replacing (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2 Int
2021-03-11 21:10:25,049 [main:54] - Getting value of type Int
2021-03-11 21:10:25,154 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:25,156 [main:58] - GENERATED VALUE OF TYPE Int = -986240041
2021-03-11 21:10:25,156 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:25,160 [main:67] - randomType = Boolean
2021-03-11 21:10:25,264 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:25,280 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:10:25,381 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:25,383 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4a848b8e]
2021-03-11 21:10:25,486 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:25,488 [main:78] - Generated call from random type = (false).compareTo(false).compareTo(100)
2021-03-11 21:10:25,488 [main:106] - GETTING Int from Int?
2021-03-11 21:10:25,545 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]]
2021-03-11 21:10:25,545 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:25,545 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]
2021-03-11 21:10:25,545 [main:117] - GENERATED CALL = (i1).and(iarg2).unaryPlus()
2021-03-11 21:10:25,545 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]]
2021-03-11 21:10:25,546 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:25,648 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:25,650 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7f1b0c8c]
2021-03-11 21:10:25,651 [main:117] - GENERATED CALL = (i1).compareTo(-1380487651).inv()
2021-03-11 21:10:25,651 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]]
2021-03-11 21:10:25,651 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:25,651 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]
2021-03-11 21:10:25,753 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:25,755 [main:117] - GENERATED CALL = (i1).toShort().plus(-71)
2021-03-11 21:10:25,755 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]]
2021-03-11 21:10:25,755 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:25,755 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]
2021-03-11 21:10:25,856 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:25,859 [main:117] - GENERATED CALL = (i1).toShort().div(-93)
2021-03-11 21:10:25,859 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]]
2021-03-11 21:10:25,859 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:25,984 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:25,984 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:10:26,095 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:26,097 [main:117] - GENERATED CALL = (i1).equals("ppodo").compareTo(true)
2021-03-11 21:10:26,097 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Float.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@6849d91a]]
2021-03-11 21:10:26,097 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:10:26,098 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Float.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@6849d91a]
2021-03-11 21:10:26,098 [main:117] - GENERATED CALL = (i1).toFloat().roundToInt()
2021-03-11 21:10:26,098 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@e1ced84]]
2021-03-11 21:10:26,098 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:26,098 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@e1ced84]
2021-03-11 21:10:26,098 [main:117] - GENERATED CALL = (i1).toShort().unaryMinus()
2021-03-11 21:10:26,098 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:10:26,098 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:26,098 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:10:26,199 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:26,201 [main:117] - GENERATED CALL = (i1).toInt().rem(-116)
2021-03-11 21:10:26,201 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]]
2021-03-11 21:10:26,201 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:26,202 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]
2021-03-11 21:10:26,202 [main:117] - GENERATED CALL = (i1).toInt().dec()
2021-03-11 21:10:26,202 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]]
2021-03-11 21:10:26,202 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:26,202 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]
2021-03-11 21:10:26,202 [main:117] - GENERATED CALL = (i1).and(iarg2).countOneBits()
2021-03-11 21:10:26,202 [main:61] - replacement of (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2 of type Int is (i1).toInt().rem(-116)
2021-03-11 21:10:26,301 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:26,301 [main:66] - Compilation checking started
2021-03-11 21:10:26,624 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (i1).toInt().rem(-116)
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:26,626 [main:53] - replacing (i1, Int?)
2021-03-11 21:10:26,628 [main:50] - replacing i1 Int?
2021-03-11 21:10:26,628 [main:54] - Getting value of type Int?
2021-03-11 21:10:26,728 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:26,730 [main:58] - GENERATED VALUE OF TYPE Int? = 269356435
2021-03-11 21:10:26,730 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:26,967 [main:67] - randomType = Pair<Char, UInt?>
2021-03-11 21:10:27,066 [main:302] - generating value of type = Pair<Char, UInt?> false depth = 0
2021-03-11 21:10:27,172 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Char, second: UInt?): Pair<Char, UInt?> = TODO()
2021-03-11 21:10:27,175 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Char, second: UInt?): Pair<Char, UInt?> = TODO()
2021-03-11 21:10:27,279 [main:302] - generating value of type = Char true depth = 3
2021-03-11 21:10:27,281 [main:302] - generating value of type = UInt true depth = 3
2021-03-11 21:10:27,283 [main:95] - GENERATED = Pair<Char, UInt?>('沈', 1909032231.toUInt())
2021-03-11 21:10:27,295 [main:149] - GENERATING call of type @kotlin.ExperimentalStdlibApi @kotlin.SinceKotlin public fun kotlin.Char.digitToInt(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2f6bf989]
2021-03-11 21:10:27,296 [main:78] - Generated call from random type = (Pair<Char, UInt?>('沈', 1909032231.toUInt())).first.digitToInt()
2021-03-11 21:10:27,297 [main:106] - GETTING Int? from Int?
2021-03-11 21:10:27,333 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]]
2021-03-11 21:10:27,333 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:27,333 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]
2021-03-11 21:10:27,435 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:27,438 [main:117] - GENERATED CALL = (i4)?.and(iarg2).minus(-49)
2021-03-11 21:10:27,438 [main:113] - Case = [@kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:10:27,438 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:10:27,539 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:27,541 [main:117] - GENERATED CALL = (i4)?.rem(-45)
2021-03-11 21:10:27,541 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]]
2021-03-11 21:10:27,541 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:27,541 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]
2021-03-11 21:10:27,541 [main:117] - GENERATED CALL = (i4)?.toByte().toInt()
2021-03-11 21:10:27,541 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]]
2021-03-11 21:10:27,541 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:27,541 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]
2021-03-11 21:10:27,643 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:27,645 [main:117] - GENERATED CALL = (i4)?.toInt().coerceAtLeast(9409053)
2021-03-11 21:10:27,645 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]]
2021-03-11 21:10:27,645 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:27,645 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]
2021-03-11 21:10:27,744 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:27,746 [main:117] - GENERATED CALL = (i4)?.toInt().or(1985229940)
2021-03-11 21:10:27,746 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:10:27,746 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:27,746 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:10:27,845 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:27,847 [main:117] - GENERATED CALL = (i4)?.compareTo(iarg2).rem(-25)
2021-03-11 21:10:27,847 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]]
2021-03-11 21:10:27,848 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:27,848 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]
2021-03-11 21:10:27,947 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:27,949 [main:117] - GENERATED CALL = (i4)?.toInt().xor(-1371455641)
2021-03-11 21:10:27,949 [main:113] - Case = [public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]]
2021-03-11 21:10:27,949 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]
2021-03-11 21:10:27,949 [main:117] - GENERATED CALL = (i4)?.or(iarg1)
2021-03-11 21:10:27,949 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@32dfaf36]]
2021-03-11 21:10:27,949 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:27,949 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@32dfaf36]
2021-03-11 21:10:28,049 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:28,051 [main:117] - GENERATED CALL = (i4)?.toByte().div(-126)
2021-03-11 21:10:28,051 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1cd90407]]
2021-03-11 21:10:28,051 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:28,051 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1cd90407]
2021-03-11 21:10:28,184 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:28,186 [main:117] - GENERATED CALL = (i4)?.toByte().plus(105)
2021-03-11 21:10:28,186 [main:61] - replacement of i1 of type Int? is (i4)?.and(iarg2).minus(-49)
2021-03-11 21:10:28,284 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:28,284 [main:66] - Compilation checking started
2021-03-11 21:10:28,588 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if ((i4)?.and(iarg2).minus(-49) != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:28,590 [main:53] - replacing (iarg1, Int)
2021-03-11 21:10:28,592 [main:50] - replacing iarg1 Int
2021-03-11 21:10:28,592 [main:54] - Getting value of type Int
2021-03-11 21:10:28,697 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:28,699 [main:58] - GENERATED VALUE OF TYPE Int = 1224719568
2021-03-11 21:10:28,699 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:28,704 [main:67] - randomType = Int
2021-03-11 21:10:28,805 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:28,843 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:28,943 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:28,945 [main:78] - Generated call from random type = (-1301659117).rangeTo(-8).first
2021-03-11 21:10:28,945 [main:61] - replacement of iarg1 of type Int is (-1301659117).rangeTo(-8).first
2021-03-11 21:10:29,043 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:29,043 [main:66] - Compilation checking started
2021-03-11 21:10:29,524 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if ((false)?.compareTo(false).toByte() != 0x44.toByte()) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:29,525 [main:53] - replacing (32, Int)
2021-03-11 21:10:29,525 [main:50] - replacing 32 Int
2021-03-11 21:10:29,525 [main:54] - Getting value of type Int
2021-03-11 21:10:29,646 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:29,648 [main:58] - GENERATED VALUE OF TYPE Int = -424211436
2021-03-11 21:10:29,648 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:29,652 [main:67] - randomType = UInt
2021-03-11 21:10:29,754 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:10:29,782 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@562e759f]
2021-03-11 21:10:29,783 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5db6009b]
2021-03-11 21:10:29,884 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:29,887 [main:78] - Generated call from random type = (18376820.toUInt()).toShort().minus(-45)
2021-03-11 21:10:29,887 [main:61] - replacement of 32 of type Int is (18376820.toUInt()).toShort().minus(-45)
2021-03-11 21:10:29,992 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:29,993 [main:53] - replacing ((4316068163002831486 shl 32), Long)
2021-03-11 21:10:29,993 [main:50] - replacing (4316068163002831486 shl 32) Long
2021-03-11 21:10:29,993 [main:54] - Getting value of type Long
2021-03-11 21:10:30,096 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:30,098 [main:58] - GENERATED VALUE OF TYPE Long = -3939872636989254164
2021-03-11 21:10:30,098 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:30,603 [main:67] - randomType = Collection<Sequence<String?>?>
2021-03-11 21:10:30,603 [main:61] - replacement of (4316068163002831486 shl 32) of type Long is -3939872636989254164
2021-03-11 21:10:30,703 [main:33] - Trying to replace Element(PARENTHESIZED) on Element(PREFIX_EXPRESSION)
2021-03-11 21:10:30,706 [main:53] - replacing ((false)?.compareTo(false).toByte() != 0x44.toByte(), Boolean)
2021-03-11 21:10:30,708 [main:50] - replacing (false)?.compareTo(false).toByte() != 0x44.toByte() Boolean
2021-03-11 21:10:30,708 [main:54] - Getting value of type Boolean
2021-03-11 21:10:30,807 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:30,809 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:10:30,809 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:30,814 [main:67] - randomType = String
2021-03-11 21:10:30,913 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:30,934 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@6db738]
2021-03-11 21:10:31,033 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:31,036 [main:149] - GENERATING call of type public fun kotlin.CharSequence.regionMatches(thisOffset: kotlin.Int, other: kotlin.CharSequence, otherOffset: kotlin.Int, length: kotlin.Int, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@26f31a6]
2021-03-11 21:10:31,136 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:10:31,241 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:31,343 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:31,444 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:31,446 [main:78] - Generated call from random type = ("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)
2021-03-11 21:10:31,446 [main:61] - replacement of (false)?.compareTo(false).toByte() != 0x44.toByte() of type Boolean is ("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)
2021-03-11 21:10:31,546 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:31,546 [main:66] - Compilation checking started
2021-03-11 21:10:31,955 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return "fail: Byte.inv"

    return "OK"
}


2021-03-11 21:10:31,961 [main:53] - replacing ("fail: Byte.inv", String)
2021-03-11 21:10:31,964 [main:50] - replacing "fail: Byte.inv" String
2021-03-11 21:10:31,964 [main:54] - Getting value of type String
2021-03-11 21:10:32,106 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:32,108 [main:58] - GENERATED VALUE OF TYPE String = "bgcor"
2021-03-11 21:10:32,109 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:32,114 [main:67] - randomType = Float
2021-03-11 21:10:32,215 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:10:32,246 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@76b6e5ab]
2021-03-11 21:10:32,246 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:32,246 [main:78] - Generated call from random type = (0.29659742f).toLong().toString(iarg1)
2021-03-11 21:10:32,247 [main:106] - GETTING String from Int?
2021-03-11 21:10:32,281 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:32,281 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:32,281 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:32,381 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:32,383 [main:117] - GENERATED CALL = (i7).toLong().toString(-403051488)
2021-03-11 21:10:32,383 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:10:32,383 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:32,383 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:10:32,383 [main:117] - GENERATED CALL = (i7).toByte().toString(iarg1)
2021-03-11 21:10:32,383 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:32,383 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:32,484 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:32,486 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:32,486 [main:117] - GENERATED CALL = (i7).and(-1190058275).toString(iarg1)
2021-03-11 21:10:32,486 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:10:32,486 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:32,486 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:10:32,586 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:32,588 [main:117] - GENERATED CALL = (i7).toChar().plus("npayi")
2021-03-11 21:10:32,588 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:10:32,589 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:32,589 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:10:32,589 [main:117] - GENERATED CALL = (i7).toChar().lowercase()
2021-03-11 21:10:32,589 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:32,589 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:10:32,717 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:32,719 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:32,719 [main:117] - GENERATED CALL = (i7).div(-5518692363494734718).toString(iarg2)
2021-03-11 21:10:32,719 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:32,719 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:32,719 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:32,818 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:32,820 [main:117] - GENERATED CALL = (i7).compareTo(iarg2).toString(1401700238)
2021-03-11 21:10:32,820 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:10:32,820 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:32,821 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:10:32,821 [main:117] - GENERATED CALL = (i7).toChar().uppercase()
2021-03-11 21:10:32,821 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:10:32,821 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:32,821 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:10:32,821 [main:117] - GENERATED CALL = (i7).toChar().titlecase()
2021-03-11 21:10:32,822 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:32,822 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:32,822 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:32,822 [main:117] - GENERATED CALL = (i7).toInt().toString(iarg1)
2021-03-11 21:10:32,822 [main:61] - replacement of "fail: Byte.inv" of type String is (0.29659742f).toLong().toString(iarg1)
2021-03-11 21:10:32,925 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:32,925 [main:66] - Compilation checking started
2021-03-11 21:10:33,344 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:33,345 [main:53] - replacing ((0xDC56DC56L shl 32), Long)
2021-03-11 21:10:33,345 [main:50] - replacing (0xDC56DC56L shl 32) Long
2021-03-11 21:10:33,345 [main:54] - Getting value of type Long
2021-03-11 21:10:33,467 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:33,469 [main:58] - GENERATED VALUE OF TYPE Long = -7327422641407204786
2021-03-11 21:10:33,469 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:33,720 [main:67] - randomType = HashMap<UShort, Long>
2021-03-11 21:10:33,820 [main:302] - generating value of type = HashMap<UShort, Long> false depth = 0
2021-03-11 21:10:33,926 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(pairs: Pair<UShort, Long>): HashMap<UShort, Long> = TODO()
2021-03-11 21:10:33,930 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(pairs: Pair<UShort, Long>): HashMap<UShort, Long> = TODO()
2021-03-11 21:10:34,035 [main:302] - generating value of type = Pair<UShort, Long> false depth = 3
2021-03-11 21:10:34,145 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: UShort, second: Long): Pair<UShort, Long> = TODO()
2021-03-11 21:10:34,148 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: UShort, second: Long): Pair<UShort, Long> = TODO()
2021-03-11 21:10:34,256 [main:302] - generating value of type = UShort true depth = 6
2021-03-11 21:10:34,257 [main:302] - generating value of type = Long true depth = 6
2021-03-11 21:10:34,259 [main:95] - GENERATED = Pair<UShort, Long>(3370.toUShort(), 4709173344374689686)
2021-03-11 21:10:34,260 [main:95] - GENERATED = linkedMapOf<UShort, Long>(Pair<UShort, Long>(3370.toUShort(), 4709173344374689686))
2021-03-11 21:10:34,364 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Collection<T>.random(): T defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@741a0b56]
2021-03-11 21:10:34,364 [main:78] - Generated call from random type = (linkedMapOf<UShort, Long>(Pair<UShort, Long>(3370.toUShort(), 4709173344374689686))).values.random()!!
2021-03-11 21:10:34,364 [main:61] - replacement of (0xDC56DC56L shl 32) of type Long is -7327422641407204786
2021-03-11 21:10:34,469 [main:33] - Trying to replace Element(PARENTHESIZED) on Element(PREFIX_EXPRESSION)
2021-03-11 21:10:34,470 [main:53] - replacing (i6 != 1733995329, Boolean)
2021-03-11 21:10:34,470 [main:50] - replacing i6 != 1733995329 Boolean
2021-03-11 21:10:34,470 [main:54] - Getting value of type Boolean
2021-03-11 21:10:34,576 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:34,578 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:10:34,578 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:34,582 [main:67] - randomType = Char
2021-03-11 21:10:34,685 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:10:34,705 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@4e28c353]
2021-03-11 21:10:34,807 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:10:34,809 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:34,911 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:34,911 [main:78] - Generated call from random type = ('ꢚ').compareTo('').equals("wxjqw")
2021-03-11 21:10:34,911 [main:61] - replacement of i6 != 1733995329 of type Boolean is ('ꢚ').compareTo('').equals("wxjqw")
2021-03-11 21:10:35,038 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:35,041 [main:53] - replacing (iarg1 shl 16, Int)
2021-03-11 21:10:35,042 [main:50] - replacing iarg1 shl 16 Int
2021-03-11 21:10:35,042 [main:54] - Getting value of type Int
2021-03-11 21:10:35,145 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:35,147 [main:58] - GENERATED VALUE OF TYPE Int = -1587912551
2021-03-11 21:10:35,147 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:35,152 [main:67] - randomType = UShort
2021-03-11 21:10:35,254 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:10:35,283 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@2bc02a64]
2021-03-11 21:10:35,385 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:10:35,387 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:35,388 [main:78] - Generated call from random type = (5078.toUShort()).compareTo(33.toUByte()).and(iarg1)
2021-03-11 21:10:35,388 [main:106] - GETTING Int from Int?
2021-03-11 21:10:35,421 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]]
2021-03-11 21:10:35,421 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:35,421 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]
2021-03-11 21:10:35,524 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:35,526 [main:117] - GENERATED CALL = (i4).toShort().plus(53)
2021-03-11 21:10:35,526 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]]
2021-03-11 21:10:35,526 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:35,526 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:10:35,527 [main:117] - GENERATED CALL = (i4).toInt().toInt()
2021-03-11 21:10:35,527 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]]
2021-03-11 21:10:35,527 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:35,527 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]
2021-03-11 21:10:35,631 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:35,634 [main:117] - GENERATED CALL = (i4).compareTo(iarg1).minus(36)
2021-03-11 21:10:35,634 [main:113] - Case = [public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@28383eeb]]
2021-03-11 21:10:35,634 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@28383eeb]
2021-03-11 21:10:35,736 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:35,739 [main:117] - GENERATED CALL = (i4).plus(-61)
2021-03-11 21:10:35,739 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@506e1d0f]]
2021-03-11 21:10:35,739 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:10:35,839 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:35,841 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@506e1d0f]
2021-03-11 21:10:35,841 [main:117] - GENERATED CALL = (i4).div(4214723802472783990).countLeadingZeroBits()
2021-03-11 21:10:35,841 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]]
2021-03-11 21:10:35,841 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:35,842 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]
2021-03-11 21:10:35,842 [main:117] - GENERATED CALL = (i4).toInt().countOneBits()
2021-03-11 21:10:35,842 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:10:35,842 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:35,842 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:10:35,943 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:35,945 [main:117] - GENERATED CALL = (i4).and(iarg1).rem(-16)
2021-03-11 21:10:35,946 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@444f3fa7]]
2021-03-11 21:10:35,946 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:35,946 [main:117] - GENERATED CALL = (i4).toInt().sign
2021-03-11 21:10:35,946 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Int.absoluteValue: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@2d3aa64a]]
2021-03-11 21:10:35,946 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:35,946 [main:117] - GENERATED CALL = (i4).toInt().absoluteValue
2021-03-11 21:10:35,946 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3b8a9150]]
2021-03-11 21:10:35,946 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:35,946 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3b8a9150]
2021-03-11 21:10:35,947 [main:117] - GENERATED CALL = (i4).toShort().countOneBits()
2021-03-11 21:10:35,947 [main:61] - replacement of iarg1 shl 16 of type Int is i4
2021-03-11 21:10:36,048 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:10:36,048 [main:66] - Compilation checking started
2021-03-11 21:10:36,462 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:36,463 [main:53] - replacing (0x00000000L, Long)
2021-03-11 21:10:36,463 [main:50] - replacing 0x00000000L Long
2021-03-11 21:10:36,463 [main:54] - Getting value of type Long
2021-03-11 21:10:36,570 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:36,572 [main:58] - GENERATED VALUE OF TYPE Long = 549063142579398703
2021-03-11 21:10:36,573 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:36,578 [main:67] - randomType = Float
2021-03-11 21:10:36,681 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:10:36,711 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@76b6e5ab]
2021-03-11 21:10:36,712 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@598ffbc8]
2021-03-11 21:10:36,812 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:36,814 [main:78] - Generated call from random type = (0.060989857f).toLong().ushr(904451230)
2021-03-11 21:10:36,814 [main:61] - replacement of 0x00000000L of type Long is 549063142579398703
2021-03-11 21:10:36,914 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:36,915 [main:53] - replacing (0xFDDE.toShort(), Short)
2021-03-11 21:10:36,915 [main:50] - replacing 0xFDDE.toShort() Short
2021-03-11 21:10:36,915 [main:54] - Getting value of type Short
2021-03-11 21:10:37,015 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:37,017 [main:58] - GENERATED VALUE OF TYPE Short = 20260
2021-03-11 21:10:37,018 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:37,408 [main:67] - randomType = Collection<ArrayDeque<String>>
2021-03-11 21:10:37,408 [main:61] - replacement of 0xFDDE.toShort() of type Short is 20260
2021-03-11 21:10:37,512 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:37,515 [main:53] - replacing (s4 != 0x23A9.toShort(), Boolean)
2021-03-11 21:10:37,517 [main:50] - replacing s4 != 0x23A9.toShort() Boolean
2021-03-11 21:10:37,517 [main:54] - Getting value of type Boolean
2021-03-11 21:10:37,619 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:37,621 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:10:37,621 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:37,626 [main:67] - randomType = UInt
2021-03-11 21:10:37,727 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:10:37,754 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@81c353f]
2021-03-11 21:10:37,755 [main:149] - GENERATING call of type public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]
2021-03-11 21:10:37,755 [main:78] - Generated call from random type = (1976106920.toUInt()).toFloat().isFinite()
2021-03-11 21:10:37,756 [main:106] - GETTING Boolean from Short
2021-03-11 21:10:37,785 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]]
2021-03-11 21:10:37,786 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]
2021-03-11 21:10:37,889 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:37,889 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]
2021-03-11 21:10:37,990 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:37,992 [main:117] - GENERATED CALL = (sarg2).equals("slbst").and(true)
2021-03-11 21:10:37,992 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]]
2021-03-11 21:10:37,993 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:10:37,993 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]
2021-03-11 21:10:37,993 [main:117] - GENERATED CALL = (sarg2).toChar().isLowSurrogate()
2021-03-11 21:10:37,993 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]]
2021-03-11 21:10:37,993 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:10:37,993 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2dede4d3]
2021-03-11 21:10:37,993 [main:117] - GENERATED CALL = (sarg2).toChar().isUpperCase()
2021-03-11 21:10:37,993 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:10:37,993 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:37,993 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:38,094 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:38,095 [main:117] - GENERATED CALL = (sarg2).toInt().equals("dgfhv")
2021-03-11 21:10:38,095 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]]
2021-03-11 21:10:38,095 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:10:38,095 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ca868dc]
2021-03-11 21:10:38,095 [main:117] - GENERATED CALL = (sarg2).toChar().isLetterOrDigit()
2021-03-11 21:10:38,095 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]]
2021-03-11 21:10:38,095 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:10:38,095 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]
2021-03-11 21:10:38,095 [main:117] - GENERATED CALL = (sarg2).toChar().isISOControl()
2021-03-11 21:10:38,095 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:10:38,095 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:10:38,095 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:10:38,197 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:38,198 [main:117] - GENERATED CALL = (sarg2).toDouble().equals("fryct")
2021-03-11 21:10:38,198 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@15d84c80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:10:38,198 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@15d84c80]
2021-03-11 21:10:38,299 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:38,301 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:10:38,301 [main:117] - GENERATED CALL = (sarg2).div(0.5436713688038441).isInfinite()
2021-03-11 21:10:38,301 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@67ca72ba]]
2021-03-11 21:10:38,301 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]
2021-03-11 21:10:38,401 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:38,401 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@67ca72ba]
2021-03-11 21:10:38,502 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:38,503 [main:117] - GENERATED CALL = (sarg2).equals("faspc").equals("jerlm")
2021-03-11 21:10:38,503 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:10:38,503 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:10:38,503 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:10:38,503 [main:117] - GENERATED CALL = (sarg2).toDouble().isInfinite()
2021-03-11 21:10:38,503 [main:61] - replacement of s4 != 0x23A9.toShort() of type Boolean is (sarg2).toChar().isUpperCase()
2021-03-11 21:10:38,604 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:38,604 [main:66] - Compilation checking started
2021-03-11 21:10:38,887 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if ((sarg2).toChar().isUpperCase()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:38,888 [main:53] - replacing (0xDC56DC56, Long)
2021-03-11 21:10:38,888 [main:50] - replacing 0xDC56DC56 Long
2021-03-11 21:10:38,888 [main:54] - Getting value of type Long
2021-03-11 21:10:38,993 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:38,995 [main:58] - GENERATED VALUE OF TYPE Long = 4000115489199713098
2021-03-11 21:10:38,996 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:39,124 [main:67] - randomType = Function1<ULong, Float>
2021-03-11 21:10:39,124 [main:61] - replacement of 0xDC56DC56 of type Long is 4000115489199713098
2021-03-11 21:10:39,226 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:39,226 [main:53] - replacing (s1, Short?)
2021-03-11 21:10:39,226 [main:50] - replacing s1 Short?
2021-03-11 21:10:39,226 [main:54] - Getting value of type Short?
2021-03-11 21:10:39,327 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:39,329 [main:58] - GENERATED VALUE OF TYPE Short? = -26006
2021-03-11 21:10:39,329 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:39,478 [main:67] - randomType = Function1<Float, Float>
2021-03-11 21:10:39,478 [main:61] - replacement of s1 of type Short? is -26006
2021-03-11 21:10:39,578 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-11 21:10:39,581 [main:53] - replacing (('캮').toLong().ushr(iarg2) shl 32, Long)
2021-03-11 21:10:39,583 [main:50] - replacing ('캮').toLong().ushr(iarg2) shl 32 Long
2021-03-11 21:10:39,583 [main:54] - Getting value of type Long
2021-03-11 21:10:39,683 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:39,685 [main:58] - GENERATED VALUE OF TYPE Long = 7176731271846286740
2021-03-11 21:10:39,685 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:39,688 [main:67] - randomType = Int
2021-03-11 21:10:39,788 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:39,821 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:10:39,821 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@598ffbc8]
2021-03-11 21:10:39,921 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:39,923 [main:78] - Generated call from random type = (814478019).div(larg1).ushr(1474446203)
2021-03-11 21:10:39,923 [main:106] - GETTING Long from Long?
2021-03-11 21:10:39,954 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]]
2021-03-11 21:10:39,954 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:39,954 [main:149] - GENERATING call of type public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]
2021-03-11 21:10:40,055 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:40,057 [main:117] - GENERATED CALL = (l5).and(larg1).coerceIn(-9121178245642966227, larg1)
2021-03-11 21:10:40,057 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.ranges.LongRange.random(): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@450458d7]]
2021-03-11 21:10:40,057 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9]
2021-03-11 21:10:40,159 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:40,161 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.ranges.LongRange.random(): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@450458d7]
2021-03-11 21:10:40,161 [main:117] - GENERATED CALL = (l5).rangeTo(78).random()
2021-03-11 21:10:40,161 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]]
2021-03-11 21:10:40,161 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:40,161 [main:149] - GENERATING call of type public fun kotlin.Long.coerceIn(minimumValue: kotlin.Long, maximumValue: kotlin.Long): kotlin.Long defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@49b126e9]
2021-03-11 21:10:40,161 [main:117] - GENERATED CALL = (l5).toLong().coerceIn(larg1, larg1)
2021-03-11 21:10:40,162 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]]
2021-03-11 21:10:40,162 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:10:40,262 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:40,264 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Double.toBits(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@d863d54]
2021-03-11 21:10:40,264 [main:117] - GENERATED CALL = (l5).div(0.6550014255386434).toBits()
2021-03-11 21:10:40,264 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]]
2021-03-11 21:10:40,264 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:10:40,264 [main:149] - GENERATING call of type public open fun toLong(): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@10b6782]
2021-03-11 21:10:40,264 [main:117] - GENERATED CALL = (l5).toShort().toLong()
2021-03-11 21:10:40,264 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]]
2021-03-11 21:10:40,264 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:10:40,366 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:40,368 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@504ea9b3]
2021-03-11 21:10:40,368 [main:117] - GENERATED CALL = (l5).compareTo(-122).rem(larg1)
2021-03-11 21:10:40,368 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]]
2021-03-11 21:10:40,368 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:40,369 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2a2cd4f0]
2021-03-11 21:10:40,471 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:40,473 [main:117] - GENERATED CALL = (l5).and(larg1).rem(-35)
2021-03-11 21:10:40,473 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]]
2021-03-11 21:10:40,473 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:10:40,473 [main:149] - GENERATING call of type public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@13324cee]
2021-03-11 21:10:40,473 [main:117] - GENERATED CALL = (l5).toChar().toLong()
2021-03-11 21:10:40,473 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]]
2021-03-11 21:10:40,473 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:40,473 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@67aadf64]
2021-03-11 21:10:40,574 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:40,576 [main:117] - GENERATED CALL = (l5).and(larg1).or(-6558633951949141134)
2021-03-11 21:10:40,576 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]]
2021-03-11 21:10:40,576 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:10:40,677 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:40,679 [main:149] - GENERATING call of type public final fun inv(): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@37c09e8a]
2021-03-11 21:10:40,679 [main:117] - GENERATED CALL = (l5).and(-8944887344244726148).inv()
2021-03-11 21:10:40,679 [main:61] - replacement of ('캮').toLong().ushr(iarg2) shl 32 of type Long is (l5).compareTo(-122).rem(larg1)
2021-03-11 21:10:40,779 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:40,779 [main:66] - Compilation checking started
2021-03-11 21:10:41,063 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != ((l5).compareTo(-122).rem(larg1)) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return "fail: Byte.and"
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:41,066 [main:53] - replacing ("fail: Byte.and", String)
2021-03-11 21:10:41,067 [main:50] - replacing "fail: Byte.and" String
2021-03-11 21:10:41,067 [main:54] - Getting value of type String
2021-03-11 21:10:41,170 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:41,172 [main:58] - GENERATED VALUE OF TYPE String = "xrvcu"
2021-03-11 21:10:41,172 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:41,176 [main:67] - randomType = Long
2021-03-11 21:10:41,276 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:41,307 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:10:41,308 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:10:41,308 [main:78] - Generated call from random type = (2060314059589454872).toByte().toString(iarg2)
2021-03-11 21:10:41,309 [main:106] - GETTING String from Int
2021-03-11 21:10:41,339 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:10:41,339 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:41,339 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:10:41,339 [main:117] - GENERATED CALL = (iarg2).toShort().toString(iarg2)
2021-03-11 21:10:41,339 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:41,339 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:41,339 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:41,340 [main:117] - GENERATED CALL = (iarg2).toLong().toString(iarg1)
2021-03-11 21:10:41,340 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:10:41,340 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:41,340 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:10:41,440 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:10:41,442 [main:117] - GENERATED CALL = (iarg2).toChar().plus("ejlkw")
2021-03-11 21:10:41,442 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:41,442 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:41,443 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:41,543 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:41,545 [main:117] - GENERATED CALL = (iarg2).compareTo(iarg1).toString(-2020241026)
2021-03-11 21:10:41,545 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:41,545 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:41,545 [main:117] - GENERATED CALL = (iarg2).toString(iarg1)
2021-03-11 21:10:41,545 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:10:41,545 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:41,545 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:10:41,545 [main:117] - GENERATED CALL = (iarg2).toInt().toString(iarg1)
2021-03-11 21:10:41,546 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:10:41,546 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:41,546 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:10:41,546 [main:117] - GENERATED CALL = (iarg2).toChar().titlecase()
2021-03-11 21:10:41,546 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:10:41,546 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:41,546 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:10:41,546 [main:117] - GENERATED CALL = (iarg2).toChar().uppercase()
2021-03-11 21:10:41,546 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:10:41,546 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:10:41,672 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:41,674 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:10:41,774 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:41,776 [main:117] - GENERATED CALL = (iarg2).div(-1167911755234261849).toString(421290835)
2021-03-11 21:10:41,776 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:10:41,776 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:41,776 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:10:41,776 [main:117] - GENERATED CALL = (iarg2).toByte().toString(iarg1)
2021-03-11 21:10:41,776 [main:61] - replacement of "fail: Byte.and" of type String is (iarg2).toByte().toString(iarg1)
2021-03-11 21:10:41,879 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:41,880 [main:66] - Compilation checking started
2021-03-11 21:10:42,305 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:42,306 [main:53] - replacing ((false)?.compareTo(false).toByte() != 0x44.toByte(), Boolean)
2021-03-11 21:10:42,306 [main:50] - replacing (false)?.compareTo(false).toByte() != 0x44.toByte() Boolean
2021-03-11 21:10:42,306 [main:54] - Getting value of type Boolean
2021-03-11 21:10:42,413 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:42,415 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:10:42,415 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:42,420 [main:67] - randomType = Byte
2021-03-11 21:10:42,524 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:42,558 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:42,559 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:10:42,659 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:42,659 [main:78] - Generated call from random type = (-8).toInt().equals("ndqnn")
2021-03-11 21:10:42,660 [main:61] - replacement of (false)?.compareTo(false).toByte() != 0x44.toByte() of type Boolean is (-8).toInt().equals("ndqnn")
2021-03-11 21:10:42,759 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:42,759 [main:53] - replacing ((-921282359937931950 shl -2101200975) + 0xDC56DC56.toLong(), Long)
2021-03-11 21:10:42,760 [main:50] - replacing (-921282359937931950 shl -2101200975) + 0xDC56DC56.toLong() Long
2021-03-11 21:10:42,760 [main:54] - Getting value of type Long
2021-03-11 21:10:42,859 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:42,861 [main:58] - GENERATED VALUE OF TYPE Long = -8254015063728360753
2021-03-11 21:10:42,861 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:42,867 [main:67] - randomType = Short
2021-03-11 21:10:42,967 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:42,999 [main:149] - GENERATING call of type public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487]
2021-03-11 21:10:43,000 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@222b24dd]
2021-03-11 21:10:43,099 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:43,102 [main:78] - Generated call from random type = (-32712).toShort().div(-8059527087154591108)
2021-03-11 21:10:43,102 [main:61] - replacement of (-921282359937931950 shl -2101200975) + 0xDC56DC56.toLong() of type Long is (-32712).toShort().div(-8059527087154591108)
2021-03-11 21:10:43,201 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:43,203 [main:53] - replacing (0x44544454.toInt(), Int)
2021-03-11 21:10:43,205 [main:50] - replacing 0x44544454.toInt() Int
2021-03-11 21:10:43,205 [main:54] - Getting value of type Int
2021-03-11 21:10:43,305 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:43,307 [main:58] - GENERATED VALUE OF TYPE Int = -591038040
2021-03-11 21:10:43,307 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:43,428 [main:67] - randomType = Array<Byte?>
2021-03-11 21:10:43,529 [main:302] - generating value of type = Array<Byte?> false depth = 0
2021-03-11 21:10:43,635 [main:43] - GENERATING CALL OF fun <T> emptyArray(): Array<Byte?> = TODO()
2021-03-11 21:10:43,638 [main:61] - WITHOUT TYPE PARAMS = fun <T> emptyArray(): Array<Byte?> = TODO()
2021-03-11 21:10:43,746 [main:95] - GENERATED = emptyArray<Byte?>()
2021-03-11 21:10:43,757 [main:78] - Generated call from random type = (emptyArray<Byte?>()).lastIndex
2021-03-11 21:10:43,758 [main:106] - GETTING Int from Int?
2021-03-11 21:10:43,789 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]]
2021-03-11 21:10:43,789 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:43,790 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]
2021-03-11 21:10:43,890 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:43,892 [main:117] - GENERATED CALL = (i6).toByte().minus(-29)
2021-03-11 21:10:43,892 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]]
2021-03-11 21:10:43,892 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:43,892 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@12b4f3a6]
2021-03-11 21:10:43,892 [main:117] - GENERATED CALL = (i6).compareTo(iarg2).rotateRight(iarg1)
2021-03-11 21:10:43,892 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]]
2021-03-11 21:10:43,893 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:43,893 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]
2021-03-11 21:10:43,893 [main:117] - GENERATED CALL = (i6).and(iarg1).countLeadingZeroBits()
2021-03-11 21:10:43,893 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]]
2021-03-11 21:10:43,893 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:44,018 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:44,020 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]
2021-03-11 21:10:44,020 [main:117] - GENERATED CALL = (i6).compareTo(1993527444).unaryMinus()
2021-03-11 21:10:44,020 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]]
2021-03-11 21:10:44,020 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:44,020 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]
2021-03-11 21:10:44,020 [main:117] - GENERATED CALL = (i6).toLong().countTrailingZeroBits()
2021-03-11 21:10:44,020 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.ranges.IntRange.random(): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@f8a969d]]
2021-03-11 21:10:44,020 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:44,120 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:44,122 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.ranges.IntRange.random(): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@f8a969d]
2021-03-11 21:10:44,122 [main:117] - GENERATED CALL = (i6).rangeTo(-121).random()
2021-03-11 21:10:44,122 [main:113] - Case = [@kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:10:44,122 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:10:44,223 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:44,225 [main:117] - GENERATED CALL = (i6).rem(71)
2021-03-11 21:10:44,225 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]]
2021-03-11 21:10:44,225 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:10:44,326 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:44,328 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:10:44,328 [main:117] - GENERATED CALL = (i6).and(-1231458975).shl(iarg1)
2021-03-11 21:10:44,328 [main:113] - Case = [public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]]
2021-03-11 21:10:44,328 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]
2021-03-11 21:10:44,329 [main:117] - GENERATED CALL = (i6).or(iarg1)
2021-03-11 21:10:44,329 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@54f1acb2]]
2021-03-11 21:10:44,329 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:44,329 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@54f1acb2]
2021-03-11 21:10:44,329 [main:117] - GENERATED CALL = (i6).toShort().unaryPlus()
2021-03-11 21:10:44,329 [main:61] - replacement of 0x44544454.toInt() of type Int is (i6).and(iarg1).countLeadingZeroBits()
2021-03-11 21:10:44,429 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:44,429 [main:66] - Compilation checking started
2021-03-11 21:10:44,717 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != (i6).and(iarg1).countLeadingZeroBits()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:44,718 [main:53] - replacing (iarg1, Int)
2021-03-11 21:10:44,718 [main:50] - replacing iarg1 Int
2021-03-11 21:10:44,718 [main:54] - Getting value of type Int
2021-03-11 21:10:44,819 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:44,820 [main:58] - GENERATED VALUE OF TYPE Int = 551906158
2021-03-11 21:10:44,821 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:44,826 [main:67] - randomType = Char
2021-03-11 21:10:44,927 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:10:44,946 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@4e28c353]
2021-03-11 21:10:45,046 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:10:45,049 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:10:45,148 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:45,150 [main:78] - Generated call from random type = ('址').compareTo('䀤').shr(-1822096640)
2021-03-11 21:10:45,150 [main:61] - replacement of iarg1 of type Int is ('址').compareTo('䀤').shr(-1822096640)
2021-03-11 21:10:45,250 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:45,250 [main:53] - replacing (0xFDDEFDDEL, Long)
2021-03-11 21:10:45,251 [main:50] - replacing 0xFDDEFDDEL Long
2021-03-11 21:10:45,251 [main:54] - Getting value of type Long
2021-03-11 21:10:45,351 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:45,352 [main:58] - GENERATED VALUE OF TYPE Long = 5561050965325651532
2021-03-11 21:10:45,353 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:45,478 [main:67] - randomType = LinkedHashMap<Long, Double>
2021-03-11 21:10:45,578 [main:302] - generating value of type = LinkedHashMap<Long, Double> false depth = 0
2021-03-11 21:10:45,684 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(pairs: Pair<Long, Double>): LkedHashMap<Long, Double> = TODO()
2021-03-11 21:10:45,687 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(pairs: Pair<Long, Double>): LkedHashMap<Long, Double> = TODO()
2021-03-11 21:10:45,792 [main:302] - generating value of type = Pair<Long, Double> false depth = 3
2021-03-11 21:10:45,899 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Long, second: Double): Pair<Long, Double> = TODO()
2021-03-11 21:10:45,902 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Long, second: Double): Pair<Long, Double> = TODO()
2021-03-11 21:10:46,007 [main:302] - generating value of type = Long true depth = 6
2021-03-11 21:10:46,009 [main:302] - generating value of type = Double true depth = 6
2021-03-11 21:10:46,011 [main:95] - GENERATED = Pair<Long, Double>(-9222304804372927441, 0.7916867341820956)
2021-03-11 21:10:46,011 [main:95] - GENERATED = linkedMapOf<Long, Double>(Pair<Long, Double>(-9222304804372927441, 0.7916867341820956))
2021-03-11 21:10:46,128 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:10:46,263 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:46,265 [main:78] - Generated call from random type = (linkedMapOf<Long, Double>(Pair<Long, Double>(-9222304804372927441, 0.7916867341820956))).size.div(-8641035535514788847)
2021-03-11 21:10:46,266 [main:61] - replacement of 0xFDDEFDDEL of type Long is (linkedMapOf<Long, Double>(Pair<Long, Double>(-9222304804372927441, 0.7916867341820956))).size.div(-8641035535514788847)
2021-03-11 21:10:46,367 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:46,367 [main:53] - replacing (b1, Byte?)
2021-03-11 21:10:46,367 [main:50] - replacing b1 Byte?
2021-03-11 21:10:46,367 [main:54] - Getting value of type Byte?
2021-03-11 21:10:46,468 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:46,470 [main:58] - GENERATED VALUE OF TYPE Byte? = -69
2021-03-11 21:10:46,470 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:46,589 [main:67] - randomType = Float?
2021-03-11 21:10:46,690 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:10:46,722 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]
2021-03-11 21:10:46,723 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Byte defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@725fc764]
2021-03-11 21:10:46,723 [main:78] - Generated call from random type = (0.97891366f)?.toByte().dec()
2021-03-11 21:10:46,723 [main:61] - replacement of b1 of type Byte? is (0.97891366f)?.toByte().dec()
2021-03-11 21:10:46,822 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:46,823 [main:53] - replacing (i6, Int?)
2021-03-11 21:10:46,823 [main:50] - replacing i6 Int?
2021-03-11 21:10:46,823 [main:54] - Getting value of type Int?
2021-03-11 21:10:46,924 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:46,926 [main:58] - GENERATED VALUE OF TYPE Int? = 1526276868
2021-03-11 21:10:46,927 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:47,048 [main:67] - randomType = HashSet<Int>
2021-03-11 21:10:47,148 [main:302] - generating value of type = HashSet<Int> false depth = 0
2021-03-11 21:10:47,255 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: Int): HashSet<Int> = TODO()
2021-03-11 21:10:47,257 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: Int): HashSet<Int> = TODO()
2021-03-11 21:10:47,363 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:10:47,365 [main:95] - GENERATED = linkedSetOf<Int>(-1817982290)
2021-03-11 21:10:47,471 [main:149] - GENERATING call of type @kotlin.Deprecated @kotlin.DeprecatedSinceKotlin public fun <T> kotlin.collections.Iterable<T>.minWith(comparator: kotlin.Comparator<in T>): T? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@733c4651]
2021-03-11 21:10:47,572 [main:302] - generating value of type = Comparator<in T> false depth = 0
2021-03-11 21:10:47,686 [main:43] - GENERATING CALL OF fun <T> nullsLast(comparator: kotlin.Comparator<T>): Comparator<T> = TODO()
2021-03-11 21:10:47,689 [main:61] - WITHOUT TYPE PARAMS = fun <T> nullsLast(comparator: kotlin.Comparator<T>): Comparator<T> = TODO()
2021-03-11 21:10:47,919 [main:385] - Cant generate call of fun <T> nullsLast(comparator: kotlin.Comparator<T>): Comparator<T> = TODO()
2021-03-11 21:10:47,919 [main:158] - CANT GENERATE PARAMS FOR @kotlin.Deprecated @kotlin.DeprecatedSinceKotlin public fun <T> kotlin.collections.Iterable<T>.minWith(comparator: kotlin.Comparator<in T>): T? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@733c4651]
2021-03-11 21:10:47,919 [main:78] - Generated call from random type = (linkedSetOf<Int>(-1817982290)).null
2021-03-11 21:10:47,919 [main:61] - replacement of i6 of type Int? is (linkedSetOf<Int>(-1817982290)).null
2021-03-11 21:10:48,022 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:48,023 [main:53] - replacing ((-921282359937931950 shl -2101200975), Long)
2021-03-11 21:10:48,023 [main:50] - replacing (-921282359937931950 shl -2101200975) Long
2021-03-11 21:10:48,023 [main:54] - Getting value of type Long
2021-03-11 21:10:48,137 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:48,139 [main:58] - GENERATED VALUE OF TYPE Long = 6513953513182863413
2021-03-11 21:10:48,139 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:48,145 [main:67] - randomType = Int
2021-03-11 21:10:48,246 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:48,279 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:10:48,279 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Float.roundToLong(): kotlin.Long defined in kotlin.math[DeserializedSimpleFunctionDescriptor@37dd50c2]
2021-03-11 21:10:48,279 [main:78] - Generated call from random type = (-882082068).toFloat().roundToLong()
2021-03-11 21:10:48,279 [main:61] - replacement of (-921282359937931950 shl -2101200975) of type Long is 6513953513182863413
2021-03-11 21:10:48,380 [main:33] - Trying to replace Element(PARENTHESIZED) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:48,382 [main:53] - replacing (i1 != 0x44544454.toInt(), Boolean)
2021-03-11 21:10:48,384 [main:50] - replacing i1 != 0x44544454.toInt() Boolean
2021-03-11 21:10:48,384 [main:54] - Getting value of type Boolean
2021-03-11 21:10:48,514 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:48,517 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:10:48,517 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:48,521 [main:67] - randomType = Char
2021-03-11 21:10:48,624 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:10:48,644 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@7f796fb0]
2021-03-11 21:10:48,747 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:10:48,747 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@31585973]
2021-03-11 21:10:48,848 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:48,850 [main:78] - Generated call from random type = ('?').equals("rpzks").xor(false)
2021-03-11 21:10:48,850 [main:61] - replacement of i1 != 0x44544454.toInt() of type Boolean is ('?').equals("rpzks").xor(false)
2021-03-11 21:10:48,951 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:48,952 [main:66] - Compilation checking started
2021-03-11 21:10:49,269 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (('?').equals("rpzks").xor(false)) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:49,269 [main:53] - replacing (0xFFFFFFFFL, Long)
2021-03-11 21:10:49,269 [main:50] - replacing 0xFFFFFFFFL Long
2021-03-11 21:10:49,269 [main:54] - Getting value of type Long
2021-03-11 21:10:49,372 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:49,374 [main:58] - GENERATED VALUE OF TYPE Long = -4432319411921695648
2021-03-11 21:10:49,374 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:49,378 [main:67] - randomType = Byte
2021-03-11 21:10:49,478 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:49,511 [main:149] - GENERATING call of type public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@25847567]
2021-03-11 21:10:49,511 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4722f673]
2021-03-11 21:10:49,612 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:49,614 [main:78] - Generated call from random type = (-122).toByte().plus(6847692600987822094)
2021-03-11 21:10:49,614 [main:61] - replacement of 0xFFFFFFFFL of type Long is -4432319411921695648
2021-03-11 21:10:49,715 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-11 21:10:49,715 [main:53] - replacing ((6111397445261622474.toULong()).toUInt().toShort() != 20242, Boolean)
2021-03-11 21:10:49,715 [main:50] - replacing (6111397445261622474.toULong()).toUInt().toShort() != 20242 Boolean
2021-03-11 21:10:49,715 [main:54] - Getting value of type Boolean
2021-03-11 21:10:49,816 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:49,818 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:10:49,818 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:50,174 [main:67] - randomType = LinkedHashMap<Long, Collection<Float>>
2021-03-11 21:10:50,275 [main:302] - generating value of type = LinkedHashMap<Long, Collection<Float>> false depth = 0
2021-03-11 21:10:50,382 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): LkedHashMap<Long, Collection<Float>> = TODO()
2021-03-11 21:10:50,385 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): LkedHashMap<Long, Collection<Float>> = TODO()
2021-03-11 21:10:50,491 [main:95] - GENERATED = linkedMapOf<Long, Collection<Float>>()
2021-03-11 21:10:50,656 [main:149] - GENERATING call of type public abstract fun containsAll(elements: kotlin.collections.Collection<kotlin.collections.Collection<kotlin.Float>>): kotlin.Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor@3a44ce75]
2021-03-11 21:10:50,758 [main:302] - generating value of type = Collection<Collection<Float>> false depth = 0
2021-03-11 21:10:50,866 [main:43] - GENERATING CALL OF fun <T> arrayListOf(): Collection<Collection<Float>> = TODO()
2021-03-11 21:10:50,869 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(): Collection<Collection<Float>> = TODO()
2021-03-11 21:10:51,011 [main:95] - GENERATED = arrayListOf<Collection<Float>>()
2021-03-11 21:10:51,011 [main:78] - Generated call from random type = (linkedMapOf<Long, Collection<Float>>()).values.containsAll(arrayListOf<Collection<Float>>())
2021-03-11 21:10:51,011 [main:61] - replacement of (6111397445261622474.toULong()).toUInt().toShort() != 20242 of type Boolean is (linkedMapOf<Long, Collection<Float>>()).values.containsAll(arrayListOf<Collection<Float>>())
2021-03-11 21:10:51,115 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:51,116 [main:53] - replacing (16, Int)
2021-03-11 21:10:51,116 [main:50] - replacing 16 Int
2021-03-11 21:10:51,116 [main:54] - Getting value of type Int
2021-03-11 21:10:51,220 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:51,223 [main:58] - GENERATED VALUE OF TYPE Int = -152787130
2021-03-11 21:10:51,223 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:51,350 [main:67] - randomType = Function1<Byte, UByte>
2021-03-11 21:10:51,350 [main:61] - replacement of 16 of type Int is -152787130
2021-03-11 21:10:51,454 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-11 21:10:51,454 [main:53] - replacing (6513953513182863413 + 0xDC56DC56.toLong(), Long)
2021-03-11 21:10:51,454 [main:50] - replacing 6513953513182863413 + 0xDC56DC56.toLong() Long
2021-03-11 21:10:51,454 [main:54] - Getting value of type Long
2021-03-11 21:10:51,556 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:51,557 [main:58] - GENERATED VALUE OF TYPE Long = -3728221905038904300
2021-03-11 21:10:51,558 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:51,686 [main:67] - randomType = Function2<Char, UInt, Long>
2021-03-11 21:10:51,687 [main:61] - replacement of 6513953513182863413 + 0xDC56DC56.toLong() of type Long is -3728221905038904300
2021-03-11 21:10:51,788 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-11 21:10:51,789 [main:53] - replacing (larg1, Long)
2021-03-11 21:10:51,789 [main:50] - replacing larg1 Long
2021-03-11 21:10:51,789 [main:54] - Getting value of type Long
2021-03-11 21:10:51,891 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:51,893 [main:58] - GENERATED VALUE OF TYPE Long = 5232125399756950421
2021-03-11 21:10:51,893 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:51,897 [main:67] - randomType = Short
2021-03-11 21:10:51,998 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:52,031 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@222b24dd]
2021-03-11 21:10:52,132 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:52,134 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.takeHighestOneBit(): kotlin.Long defined in kotlin[DeserializedSimpleFunctionDescriptor@57ac128c]
2021-03-11 21:10:52,135 [main:78] - Generated call from random type = (17745).div(5811585703250747347).takeHighestOneBit()
2021-03-11 21:10:52,135 [main:61] - replacement of larg1 of type Long is (17745).div(5811585703250747347).takeHighestOneBit()
2021-03-11 21:10:52,238 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:52,240 [main:53] - replacing (i1, Int?)
2021-03-11 21:10:52,242 [main:50] - replacing i1 Int?
2021-03-11 21:10:52,242 [main:54] - Getting value of type Int?
2021-03-11 21:10:52,344 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:52,345 [main:58] - GENERATED VALUE OF TYPE Int? = 741989378
2021-03-11 21:10:52,346 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:52,349 [main:67] - randomType = ULong
2021-03-11 21:10:52,450 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:10:52,478 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@368a589]
2021-03-11 21:10:52,479 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@169b0203]
2021-03-11 21:10:52,479 [main:78] - Generated call from random type = (327893042256010490.toULong()).toByte().countOneBits()
2021-03-11 21:10:52,479 [main:106] - GETTING Int? from Int
2021-03-11 21:10:52,509 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]]
2021-03-11 21:10:52,510 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:10:52,612 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:10:52,614 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]
2021-03-11 21:10:52,614 [main:117] - GENERATED CALL = (iarg2)?.div(0.06126422007080812).toInt()
2021-03-11 21:10:52,614 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public open val endInclusive: kotlin.Int defined in kotlin.ranges.IntRange[DeserializedPropertyDescriptor@3aeaf2e5]]
2021-03-11 21:10:52,614 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:52,716 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:52,718 [main:117] - GENERATED CALL = (iarg2)?.rangeTo(-68).endInclusive
2021-03-11 21:10:52,718 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Int.absoluteValue: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@2d3aa64a]]
2021-03-11 21:10:52,718 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:52,819 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:52,821 [main:117] - GENERATED CALL = (iarg2)?.compareTo(1140609528).absoluteValue
2021-03-11 21:10:52,821 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74385fde]]
2021-03-11 21:10:52,822 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:52,822 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74385fde]
2021-03-11 21:10:52,925 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:52,927 [main:117] - GENERATED CALL = (iarg2)?.toInt().times(99)
2021-03-11 21:10:52,927 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]]
2021-03-11 21:10:52,927 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:10:52,927 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@265c8f7a]
2021-03-11 21:10:52,927 [main:117] - GENERATED CALL = (iarg2)?.compareTo(iarg2).countTrailingZeroBits()
2021-03-11 21:10:52,927 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]]
2021-03-11 21:10:52,927 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:52,927 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]
2021-03-11 21:10:52,928 [main:117] - GENERATED CALL = (iarg2)?.toInt().coerceAtLeast(iarg1)
2021-03-11 21:10:52,928 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]]
2021-03-11 21:10:52,928 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:52,928 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]
2021-03-11 21:10:53,034 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:53,036 [main:117] - GENERATED CALL = (iarg2)?.toShort().div(45)
2021-03-11 21:10:53,036 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@444f3fa7]]
2021-03-11 21:10:53,036 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:53,037 [main:117] - GENERATED CALL = (iarg2)?.toInt().sign
2021-03-11 21:10:53,037 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public final val last: kotlin.Int defined in kotlin.ranges.IntRange[DeserializedPropertyDescriptor@1c7f6345]]
2021-03-11 21:10:53,037 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:53,138 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:53,140 [main:117] - GENERATED CALL = (iarg2)?.rangeTo(105).last
2021-03-11 21:10:53,140 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]]
2021-03-11 21:10:53,140 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:10:53,140 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:10:53,241 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:53,243 [main:117] - GENERATED CALL = (iarg2)?.toLong().compareTo(44)
2021-03-11 21:10:53,243 [main:61] - replacement of i1 of type Int? is (iarg2)?.rangeTo(-68).endInclusive
2021-03-11 21:10:53,381 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:53,382 [main:66] - Compilation checking started
2021-03-11 21:10:53,700 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if ((iarg2)?.rangeTo(-68).endInclusive != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:53,701 [main:53] - replacing (0x23A923A923A923A9, Long)
2021-03-11 21:10:53,701 [main:50] - replacing 0x23A923A923A923A9 Long
2021-03-11 21:10:53,701 [main:54] - Getting value of type Long
2021-03-11 21:10:53,802 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:53,804 [main:58] - GENERATED VALUE OF TYPE Long = -5256888718074542714
2021-03-11 21:10:53,804 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:53,808 [main:67] - randomType = Float
2021-03-11 21:10:53,908 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:10:53,940 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]
2021-03-11 21:10:53,941 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Long): kotlin.Long defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@131b016c]
2021-03-11 21:10:54,042 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:54,044 [main:78] - Generated call from random type = (0.2970196f).toByte().rem(-2884951865039807186)
2021-03-11 21:10:54,044 [main:61] - replacement of 0x23A923A923A923A9 of type Long is (0.2970196f).toByte().rem(-2884951865039807186)
2021-03-11 21:10:54,145 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:54,146 [main:53] - replacing (32, Int)
2021-03-11 21:10:54,146 [main:50] - replacing 32 Int
2021-03-11 21:10:54,146 [main:54] - Getting value of type Int
2021-03-11 21:10:54,247 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:54,249 [main:58] - GENERATED VALUE OF TYPE Int = 2077643031
2021-03-11 21:10:54,249 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:54,253 [main:67] - randomType = Int
2021-03-11 21:10:54,354 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:54,387 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:10:54,387 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@2af3682f]
2021-03-11 21:10:54,488 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:10:54,490 [main:78] - Generated call from random type = (-731130637).toChar().minus('嘭')
2021-03-11 21:10:54,490 [main:61] - replacement of 32 of type Int is 2077643031
2021-03-11 21:10:54,591 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:54,593 [main:53] - replacing (s4, Short?)
2021-03-11 21:10:54,595 [main:50] - replacing s4 Short?
2021-03-11 21:10:54,595 [main:54] - Getting value of type Short?
2021-03-11 21:10:54,696 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:54,698 [main:58] - GENERATED VALUE OF TYPE Short? = -7814
2021-03-11 21:10:54,698 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:54,702 [main:67] - randomType = Boolean
2021-03-11 21:10:54,802 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:54,813 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:10:54,914 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:10:54,916 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:54,916 [main:78] - Generated call from random type = (true).compareTo(false).toShort()
2021-03-11 21:10:54,917 [main:106] - GETTING Short? from Int?
2021-03-11 21:10:54,949 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]]
2021-03-11 21:10:54,950 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:54,950 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:54,950 [main:117] - GENERATED CALL = (i2)?.toInt().toShort()
2021-03-11 21:10:54,950 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.xor(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@282e8980]]
2021-03-11 21:10:54,950 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:54,950 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.xor(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@282e8980]
2021-03-11 21:10:55,050 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:55,053 [main:117] - GENERATED CALL = (i2)?.toShort().xor(-9546)
2021-03-11 21:10:55,053 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d]]
2021-03-11 21:10:55,053 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:55,053 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d]
2021-03-11 21:10:55,053 [main:117] - GENERATED CALL = (i2)?.toByte().toShort()
2021-03-11 21:10:55,053 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4]]
2021-03-11 21:10:55,053 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:55,053 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4]
2021-03-11 21:10:55,053 [main:117] - GENERATED CALL = (i2)?.toShort().dec()
2021-03-11 21:10:55,053 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public fun kotlin.Short.coerceAtMost(maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ec993d6]]
2021-03-11 21:10:55,053 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:55,053 [main:149] - GENERATING call of type public fun kotlin.Short.coerceAtMost(maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ec993d6]
2021-03-11 21:10:55,053 [main:117] - GENERATED CALL = (i2)?.toShort().coerceAtMost(sarg1)
2021-03-11 21:10:55,054 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public fun kotlin.Short.coerceIn(minimumValue: kotlin.Short, maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5f8f67d1]]
2021-03-11 21:10:55,054 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:55,054 [main:149] - GENERATING call of type public fun kotlin.Short.coerceIn(minimumValue: kotlin.Short, maximumValue: kotlin.Short): kotlin.Short defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5f8f67d1]
2021-03-11 21:10:55,154 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:10:55,156 [main:117] - GENERATED CALL = (i2)?.toShort().coerceIn(20134, sarg1)
2021-03-11 21:10:55,156 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public open fun toShort(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5e9dc66]]
2021-03-11 21:10:55,156 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:55,156 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5e9dc66]
2021-03-11 21:10:55,157 [main:117] - GENERATED CALL = (i2)?.toShort().toShort()
2021-03-11 21:10:55,157 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]]
2021-03-11 21:10:55,157 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:55,157 [main:117] - GENERATED CALL = (i2)?.toShort()
2021-03-11 21:10:55,157 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeHighestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@7a6d5fdf]]
2021-03-11 21:10:55,157 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:55,157 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.takeHighestOneBit(): kotlin.Short defined in kotlin[DeserializedSimpleFunctionDescriptor@7a6d5fdf]
2021-03-11 21:10:55,157 [main:117] - GENERATED CALL = (i2)?.toShort().takeHighestOneBit()
2021-03-11 21:10:55,157 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.or(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@486aa623]]
2021-03-11 21:10:55,157 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:55,157 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline infix fun kotlin.Short.or(other: kotlin.Short): kotlin.Short defined in kotlin.experimental[DeserializedSimpleFunctionDescriptor@486aa623]
2021-03-11 21:10:55,157 [main:117] - GENERATED CALL = (i2)?.toShort().or(sarg2)
2021-03-11 21:10:55,157 [main:61] - replacement of s4 of type Short? is (i2)?.toByte().toShort()
2021-03-11 21:10:55,257 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:55,258 [main:66] - Compilation checking started
2021-03-11 21:10:55,533 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr 16
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if ((i2)?.toByte().toShort() != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:55,533 [main:53] - replacing (0xFDDEFDDEL, Long)
2021-03-11 21:10:55,533 [main:50] - replacing 0xFDDEFDDEL Long
2021-03-11 21:10:55,533 [main:54] - Getting value of type Long
2021-03-11 21:10:55,634 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:55,636 [main:58] - GENERATED VALUE OF TYPE Long = 5046346233580492821
2021-03-11 21:10:55,637 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:55,756 [main:67] - randomType = LinkedHashSet<Char>
2021-03-11 21:10:55,886 [main:302] - generating value of type = LinkedHashSet<Char> false depth = 0
2021-03-11 21:10:55,992 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(): LkedHashSet<Char> = TODO()
2021-03-11 21:10:55,994 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(): LkedHashSet<Char> = TODO()
2021-03-11 21:10:56,100 [main:95] - GENERATED = linkedSetOf<Char>()
2021-03-11 21:10:56,222 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:10:56,323 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:56,325 [main:78] - Generated call from random type = (linkedSetOf<Char>()).size.div(4742289471157866729)
2021-03-11 21:10:56,325 [main:61] - replacement of 0xFDDEFDDEL of type Long is 5046346233580492821
2021-03-11 21:10:56,426 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:56,429 [main:53] - replacing (16, Int)
2021-03-11 21:10:56,430 [main:50] - replacing 16 Int
2021-03-11 21:10:56,431 [main:54] - Getting value of type Int
2021-03-11 21:10:56,532 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:10:56,534 [main:58] - GENERATED VALUE OF TYPE Int = 1186388663
2021-03-11 21:10:56,534 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:56,676 [main:67] - randomType = Triple<ArrayList<Long?>, UShort, Byte>
2021-03-11 21:10:56,777 [main:302] - generating value of type = Triple<ArrayList<Long?>, UShort, Byte> false depth = 0
2021-03-11 21:10:56,884 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: ArrayList<Long?>, second: UShort, third: Byte): Triple<ArrayList<Long?>, UShort, Byte> = TODO()
2021-03-11 21:10:56,886 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: ArrayList<Long?>, second: UShort, third: Byte): Triple<ArrayList<Long?>, UShort, Byte> = TODO()
2021-03-11 21:10:56,992 [main:302] - generating value of type = ArrayList<Long?> false depth = 3
2021-03-11 21:10:57,097 [main:43] - GENERATING CALL OF fun <T> arrayListOf(elements: Long?): ArrayList<Long?> = TODO()
2021-03-11 21:10:57,100 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(elements: Long?): ArrayList<Long?> = TODO()
2021-03-11 21:10:57,206 [main:302] - generating value of type = Long true depth = 6
2021-03-11 21:10:57,209 [main:95] - GENERATED = arrayListOf<Long?>(-6361686791489548759)
2021-03-11 21:10:57,209 [main:302] - generating value of type = UShort true depth = 3
2021-03-11 21:10:57,211 [main:302] - generating value of type = Byte true depth = 3
2021-03-11 21:10:57,213 [main:95] - GENERATED = Triple<ArrayList<Long?>, UShort, Byte>(arrayListOf<Long?>(-6361686791489548759), 9684.toUShort(), 124)
2021-03-11 21:10:57,239 [main:149] - GENERATING call of type public open fun lastIndexOf(element: kotlin.Long?): kotlin.Int defined in kotlin.collections.ArrayList[DeserializedSimpleFunctionDescriptor@86cd079]
2021-03-11 21:10:57,340 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:10:57,343 [main:78] - Generated call from random type = (Triple<ArrayList<Long?>, UShort, Byte>(arrayListOf<Long?>(-6361686791489548759), 9684.toUShort(), 124)).first.lastIndexOf(1571371387374973228)
2021-03-11 21:10:57,343 [main:106] - GETTING Int from Int
2021-03-11 21:10:57,376 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]]
2021-03-11 21:10:57,376 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:57,376 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]
2021-03-11 21:10:57,377 [main:117] - GENERATED CALL = (iarg1).toInt().coerceIn(iarg2, iarg2)
2021-03-11 21:10:57,377 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1cd90407]]
2021-03-11 21:10:57,377 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:57,377 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1cd90407]
2021-03-11 21:10:57,477 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:57,479 [main:117] - GENERATED CALL = (iarg1).toByte().plus(-41)
2021-03-11 21:10:57,479 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]]
2021-03-11 21:10:57,479 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:57,479 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:10:57,479 [main:117] - GENERATED CALL = (iarg1).toInt().shl(iarg2)
2021-03-11 21:10:57,479 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]]
2021-03-11 21:10:57,479 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:57,480 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:10:57,480 [main:117] - GENERATED CALL = (iarg1).toInt().toInt()
2021-03-11 21:10:57,480 [main:113] - Case = [public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]]
2021-03-11 21:10:57,480 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]
2021-03-11 21:10:57,480 [main:117] - GENERATED CALL = (iarg1).unaryPlus()
2021-03-11 21:10:57,480 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]]
2021-03-11 21:10:57,480 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:57,480 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]
2021-03-11 21:10:57,580 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:57,582 [main:117] - GENERATED CALL = (iarg1).toShort().plus(-40)
2021-03-11 21:10:57,582 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]]
2021-03-11 21:10:57,582 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:10:57,583 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]
2021-03-11 21:10:57,683 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:57,685 [main:117] - GENERATED CALL = (iarg1).toInt().minus(-104)
2021-03-11 21:10:57,685 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@e1ced84]]
2021-03-11 21:10:57,685 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:57,685 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@e1ced84]
2021-03-11 21:10:57,685 [main:117] - GENERATED CALL = (iarg1).toShort().unaryMinus()
2021-03-11 21:10:57,685 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685], public final val last: kotlin.Int defined in kotlin.ranges.IntRange[DeserializedPropertyDescriptor@1c7f6345]]
2021-03-11 21:10:57,685 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16fa4685]
2021-03-11 21:10:57,785 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:57,787 [main:117] - GENERATED CALL = (iarg1).rangeTo(37).last
2021-03-11 21:10:57,787 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]]
2021-03-11 21:10:57,787 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:10:57,787 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:10:57,888 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:57,891 [main:117] - GENERATED CALL = (iarg1).toShort().compareTo(-112)
2021-03-11 21:10:57,891 [main:61] - replacement of 16 of type Int is (iarg1).toShort().unaryMinus()
2021-03-11 21:10:57,991 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:57,991 [main:66] - Compilation checking started
2021-03-11 21:10:58,434 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (-10970).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:58,434 [main:53] - replacing (0x23.toByte(), Byte)
2021-03-11 21:10:58,434 [main:50] - replacing 0x23.toByte() Byte
2021-03-11 21:10:58,434 [main:54] - Getting value of type Byte
2021-03-11 21:10:58,548 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:10:58,550 [main:58] - GENERATED VALUE OF TYPE Byte = 56
2021-03-11 21:10:58,550 [main:61] - GENERATED IS CALL =false
2021-03-11 21:10:58,671 [main:67] - randomType = LinkedHashSet<UShort>
2021-03-11 21:10:58,784 [main:302] - generating value of type = LinkedHashSet<UShort> false depth = 0
2021-03-11 21:10:58,896 [main:43] - GENERATING CALL OF fun <E> LinkedHashSet(initialCapacity: kotlin.Int): LinkedHashSet<UShort> = TODO()
2021-03-11 21:10:58,899 [main:61] - WITHOUT TYPE PARAMS = fun <E> LinkedHashSet(initialCapacity: kotlin.Int): LinkedHashSet<UShort> = TODO()
2021-03-11 21:10:59,117 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:10:59,119 [main:95] - GENERATED = LinkedHashSet<UShort>(-590632319)
2021-03-11 21:10:59,239 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:10:59,240 [main:78] - Generated call from random type = (LinkedHashSet<UShort>(-590632319)).size.toByte()
2021-03-11 21:10:59,240 [main:61] - replacement of 0x23.toByte() of type Byte is (LinkedHashSet<UShort>(-590632319)).size.toByte()
2021-03-11 21:10:59,341 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:10:59,444 [main:119] - TRYING TO REPLACE CONSTANT 10970
2021-03-11 21:10:59,546 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:10:59,546 [main:66] - Compilation checking started
2021-03-11 21:10:59,936 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (623445619.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:10:59,937 [main:119] - TRYING TO REPLACE CONSTANT 0.11114194376014819
2021-03-11 21:11:00,047 [main:33] - Trying to replace Element(FLOAT_CONSTANT) on Element(FLOAT_CONSTANT)
2021-03-11 21:11:00,047 [main:66] - Compilation checking started
2021-03-11 21:11:00,426 [main:119] - TRYING TO REPLACE CONSTANT 623445619
2021-03-11 21:11:00,527 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:00,527 [main:66] - Compilation checking started
2021-03-11 21:11:00,894 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(true)) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:00,895 [main:119] - TRYING TO REPLACE CONSTANT true
2021-03-11 21:11:01,024 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(BINARY_EXPRESSION)
2021-03-11 21:11:01,025 [main:66] - Compilation checking started
2021-03-11 21:11:01,395 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.5818931f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:01,395 [main:119] - TRYING TO REPLACE CONSTANT 0.5818931f
2021-03-11 21:11:01,501 [main:33] - Trying to replace Element(FLOAT_CONSTANT) on Element(FLOAT_CONSTANT)
2021-03-11 21:11:01,501 [main:66] - Compilation checking started
2021-03-11 21:11:01,897 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:01,897 [main:119] - TRYING TO REPLACE CONSTANT 101
2021-03-11 21:11:02,001 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-11 21:11:02,001 [main:66] - Compilation checking started
2021-03-11 21:11:02,292 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(toInt())) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-6).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:02,292 [main:119] - TRYING TO REPLACE CONSTANT 6
2021-03-11 21:11:02,396 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-11 21:11:02,397 [main:66] - Compilation checking started
2021-03-11 21:11:02,792 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times(-3504722803321226677)
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:02,793 [main:119] - TRYING TO REPLACE CONSTANT 3504722803321226677
2021-03-11 21:11:02,897 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:02,898 [main:66] - Compilation checking started
2021-03-11 21:11:03,286 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (-86).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:03,287 [main:119] - TRYING TO REPLACE CONSTANT 86
2021-03-11 21:11:03,388 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:03,388 [main:66] - Compilation checking started
2021-03-11 21:11:03,786 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore('眙', "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:03,786 [main:119] - TRYING TO REPLACE CONSTANT '眙'
2021-03-11 21:11:03,895 [main:33] - Trying to replace Element(CHARACTER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:03,895 [main:66] - Compilation checking started
2021-03-11 21:11:04,262 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:04,262 [main:119] - TRYING TO REPLACE CONSTANT 9
2021-03-11 21:11:04,364 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(PARENTHESIZED)
2021-03-11 21:11:04,364 [main:66] - Compilation checking started
2021-03-11 21:11:04,644 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != ((i2)).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(-1100024263)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:04,644 [main:119] - TRYING TO REPLACE CONSTANT 1100024263
2021-03-11 21:11:04,749 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:04,749 [main:66] - Compilation checking started
2021-03-11 21:11:05,114 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (('캮').toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:05,114 [main:119] - TRYING TO REPLACE CONSTANT '캮'
2021-03-11 21:11:05,245 [main:33] - Trying to replace Element(CHARACTER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:05,246 [main:66] - Compilation checking started
2021-03-11 21:11:05,614 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (1).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:05,615 [main:119] - TRYING TO REPLACE CONSTANT 1
2021-03-11 21:11:05,716 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:05,716 [main:66] - Compilation checking started
2021-03-11 21:11:06,107 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(-1581258385) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:06,108 [main:119] - TRYING TO REPLACE CONSTANT 1581258385
2021-03-11 21:11:06,219 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:06,219 [main:66] - Compilation checking started
2021-03-11 21:11:06,631 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:06,631 [main:119] - TRYING TO REPLACE CONSTANT 4047182490725028153
2021-03-11 21:11:06,733 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:11:06,733 [main:66] - Compilation checking started
2021-03-11 21:11:07,013 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(dec()).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.40895718f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:07,014 [main:119] - TRYING TO REPLACE CONSTANT 0.40895718f
2021-03-11 21:11:07,114 [main:33] - Trying to replace Element(FLOAT_CONSTANT) on Element(FLOAT_CONSTANT)
2021-03-11 21:11:07,114 [main:66] - Compilation checking started
2021-03-11 21:11:07,511 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((-16593).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:07,511 [main:119] - TRYING TO REPLACE CONSTANT 16593
2021-03-11 21:11:07,629 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:07,630 [main:66] - Compilation checking started
2021-03-11 21:11:07,994 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(-38)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:07,995 [main:119] - TRYING TO REPLACE CONSTANT 38
2021-03-11 21:11:08,100 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:08,100 [main:66] - Compilation checking started
2021-03-11 21:11:08,462 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div(0.6883779558128149).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:08,462 [main:119] - TRYING TO REPLACE CONSTANT 0.6883779558128149
2021-03-11 21:11:08,563 [main:33] - Trying to replace Element(FLOAT_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:08,563 [main:66] - Compilation checking started
2021-03-11 21:11:08,926 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:08,927 [main:119] - TRYING TO REPLACE CONSTANT true
2021-03-11 21:11:09,057 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(BINARY_EXPRESSION)
2021-03-11 21:11:09,057 [main:66] - Compilation checking started
2021-03-11 21:11:09,343 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-775684012, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:09,344 [main:119] - TRYING TO REPLACE CONSTANT 775684012
2021-03-11 21:11:09,446 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-11 21:11:09,447 [main:66] - Compilation checking started
2021-03-11 21:11:09,808 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(7785, 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:09,809 [main:119] - TRYING TO REPLACE CONSTANT 7785
2021-03-11 21:11:09,915 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:09,915 [main:66] - Compilation checking started
2021-03-11 21:11:10,279 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 4727138064031849716))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:10,280 [main:119] - TRYING TO REPLACE CONSTANT 4727138064031849716
2021-03-11 21:11:10,384 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:10,384 [main:66] - Compilation checking started
2021-03-11 21:11:10,749 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if ((694355064099464817.toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:10,749 [main:119] - TRYING TO REPLACE CONSTANT 694355064099464817
2021-03-11 21:11:10,853 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:10,853 [main:66] - Compilation checking started
2021-03-11 21:11:11,218 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:11,218 [main:119] - TRYING TO REPLACE CONSTANT 1182231873
2021-03-11 21:11:11,319 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-11 21:11:11,320 [main:66] - Compilation checking started
2021-03-11 21:11:11,626 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (22331.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(xor(iarg1)) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:11,626 [main:119] - TRYING TO REPLACE CONSTANT 22331
2021-03-11 21:11:11,729 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:11,729 [main:66] - Compilation checking started
2021-03-11 21:11:12,094 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:12,095 [main:119] - TRYING TO REPLACE CONSTANT 88
2021-03-11 21:11:12,198 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:11:12,198 [main:66] - Compilation checking started
2021-03-11 21:11:12,473 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(compareTo(1182231873)).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = (-2443963980816079306)?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:12,474 [main:119] - TRYING TO REPLACE CONSTANT 2443963980816079306
2021-03-11 21:11:12,582 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-11 21:11:12,582 [main:66] - Compilation checking started
2021-03-11 21:11:12,968 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:12,968 [main:119] - TRYING TO REPLACE CONSTANT 7493477219778897225
2021-03-11 21:11:13,073 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:11:13,073 [main:66] - Compilation checking started
2021-03-11 21:11:13,352 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(inv()).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:13,352 [main:119] - TRYING TO REPLACE CONSTANT 1301659117
2021-03-11 21:11:13,454 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:13,455 [main:66] - Compilation checking started
2021-03-11 21:11:13,739 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (first).rangeTo(-8).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:13,739 [main:119] - TRYING TO REPLACE CONSTANT 8
2021-03-11 21:11:13,845 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:13,845 [main:66] - Compilation checking started
2021-03-11 21:11:14,255 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(32).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, false)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:14,255 [main:119] - TRYING TO REPLACE CONSTANT false
2021-03-11 21:11:14,357 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(BOOLEAN_CONSTANT)
2021-03-11 21:11:14,357 [main:66] - Compilation checking started
2021-03-11 21:11:14,719 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(32).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, true)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:14,719 [main:119] - TRYING TO REPLACE CONSTANT 2041591579
2021-03-11 21:11:14,821 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:11:14,821 [main:66] - Compilation checking started
2021-03-11 21:11:15,099 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(32).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", toInt(), -1150470076, true)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:15,100 [main:119] - TRYING TO REPLACE CONSTANT 1150470076
2021-03-11 21:11:15,208 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:11:15,209 [main:66] - Compilation checking started
2021-03-11 21:11:15,487 [main:49] - Result = false
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(32).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(-1715770110, iarg2).regionMatches(iarg2, "xrzim", -2041591579, toInt(), true)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:15,487 [main:119] - TRYING TO REPLACE CONSTANT 1715770110
2021-03-11 21:11:15,590 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:15,591 [main:66] - Compilation checking started
2021-03-11 21:11:15,951 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(32).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(22331, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, true)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return (0.29659742f).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:15,952 [main:119] - TRYING TO REPLACE CONSTANT 0.29659742f
2021-03-11 21:11:16,067 [main:33] - Trying to replace Element(FLOAT_CONSTANT) on Element(PARENTHESIZED)
2021-03-11 21:11:16,067 [main:66] - Compilation checking started
2021-03-11 21:11:16,431 [main:53] - Result = true
Text:
import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = (6).toInt().toInt()
    var i1: Int? = (iarg2.toUShort()).toUByte().countTrailingZeroBits() and iarg2
    var i2: Int? = (iarg1).xor(iarg1)
    var i3: Int? = (-1301659117).rangeTo(32).first xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = i4
    var i6: Int? = iarg1 shr (iarg1).toShort().unaryMinus()
    var i7: Int? = (iarg1.toUInt()).toFloat().toInt()

    if (i1 != 0x44544454.toInt()) return (iarg1).toInt().toString(iarg1)
    if (i2 != (-9).toLong().toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != (0.29659742f)?.toShort().times(101)) return (i3).toChar().lowercase()
    if ((i2).equals("jwhde").and(true)) return "fail: Int.shr"
    if (i7 != (i2).compareTo(iarg1).inc()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (iarg1).div(-4047182490725028153).rotateRight(iarg2) // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  (larg2).div(0.11114194376014819).toRawBits()
    var l3: Long? = (iarg2).toShort().times((0.29659742f).toLong())
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = 6978289351547199343 shr 32
    var l7: Long? = (6).toDouble().toLong() ushr (larg2).toInt().compareTo(1182231873)
    
    if ((iarg1).rangeTo(-88).equals("mmukf")) return (iarg1).div(larg1).toString(iarg1)
    if (l2 != (((i5).toChar()).toLong().ushr(iarg2) shl 32) + 0xFDDEFDDE) return ("jbecc")?.plus("tejag").replaceBefore((larg2).toChar(), "kxdhd", "gfmac")
    if (l3 != (iarg1).toDouble().toLong()) return (larg1).toLong().toString(iarg2)
    if (l4 != (iarg2).div(larg2).dec()) return "fail: Long.inv"
    if ((0.5818931f).toShort().rem(larg2) != (iarg1).toLong().inv()/*!!!*/) return "fail: Long.shl"
    if (l6 != 8407819271876184467) return "fail: Long.shr"
    if ((1715770110).toFloat().isInfinite()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = (i5).toChar().toShort() and sarg2
    var s2: Short? = (arrayListOf<Long?>())?.get(iarg1)?.toShort()!!
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if ((i1).rangeTo(-8).contains(i4)) return "fail: Short.and"
    if ((l2).equals("scfeb").or(i2 != (-9).toLong().toInt())) return "fail: Short.or"
    if ((larg1).div((6).toDouble()).isNaN()) return (l3).toLong().toString(iarg2)
    if (s4 != 0x23A9.toShort()) return (i3).toChar().uppercase()

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and (larg1).toFloat().toByte()
    var b2: Byte? = ((-2443963980816079306)?.and(-7493477219778897225))?.and(-7493477219778897225).toByte()
    var b3: Byte? = barg1 xor (i2).toShort().toByte()
    var b4: Byte? = (s4).toByte().xor(barg1)

    if (("veevc").subSequence(22331, iarg2).regionMatches(iarg2, "xrzim", -2041591579, -1150470076, true)) return (iarg2).toByte().toString(iarg1)
    if ((i7).equals("hyfao")) return "fail: Byte.or"
    if (((iarg1).toDouble().toLong().toULong()).toByte().rotateRight(1182231873) != 0xB9.toByte()) return (Array<HashMap<Short?, Long>?>(-2041591579, {a: Int -> hashMapOf<Short?, Long>(Pair<Short?, Long>(0xDC56.toShort(), 0xB98AB98A))})).contentToString()
    if ((larg2).toChar().isUpperCase()) return ((0.29659742f)).toLong().toString(iarg1)

    return "OK"
}


2021-03-11 21:11:16,455 [main:41] - AFTER TRY 0 res = import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}
2021-03-11 21:11:16,811 [main:43] - Try №0
2021-03-11 21:11:17,115 [main:41] - AFTER TRY 1 res = import kotlin.experimental.*

fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}
2021-03-11 21:11:17,521 [main:43] - Try №1
2021-03-11 21:11:20,700 [main:69] - Trying to insert suspend fun fu3() {
    fu1()
    fu1()
}
2021-03-11 21:11:20,888 [main:66] - Compilation checking started
2021-03-11 21:11:21,608 [main:103] - Trying to change 46 nodes
2021-03-11 21:11:21,608 [main:107] - replacing (c, SuspendFunction0<Unit>)
2021-03-11 21:11:21,619 [main:50] - replacing c SuspendFunction0<Unit>
2021-03-11 21:11:21,619 [main:54] - Getting value of type SuspendFunction0<Unit>
2021-03-11 21:11:21,753 [main:302] - generating value of type = SuspendFunction0<Unit> false depth = 0
2021-03-11 21:11:21,755 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:11:21,896 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:11:21,899 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:11:22,180 [main:302] - generating value of type = Boolean true depth = 4
2021-03-11 21:11:22,182 [main:95] - GENERATED = check(false)
2021-03-11 21:11:22,182 [main:58] - GENERATED VALUE OF TYPE SuspendFunction0<Unit> = { check(false)}
2021-03-11 21:11:22,183 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:22,323 [main:67] - randomType = UByte
2021-03-11 21:11:22,445 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:11:22,499 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,536 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:22,570 [main:106] - GETTING SuspendFunction0<Unit> from Int
2021-03-11 21:11:22,602 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,603 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,604 [main:106] - GETTING SuspendFunction0<Unit> from Short
2021-03-11 21:11:22,637 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:22,672 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,673 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,674 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,675 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:22,676 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,677 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,678 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:22,715 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:22,716 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:22,717 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:22,766 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:22,767 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:22,768 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:22,769 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:22,770 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,771 [main:106] - GETTING SuspendFunction0<Unit> from Byte
2021-03-11 21:11:22,810 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:22,811 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:22,812 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,813 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:22,814 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:22,814 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:22,815 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:22,816 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:22,817 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:22,818 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,819 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:22,820 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:22,821 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:22,822 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:22,822 [main:114] - replacement of c of type SuspendFunction0<Unit> is { check(false)}
2021-03-11 21:11:22,945 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-11 21:11:22,945 [main:66] - Compilation checking started
2021-03-11 21:11:23,257 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {
    prope1++
    prope3 = { it.resume(Unit) }
}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    { check(false)}.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if (prope1 != counter + 1) return "Expected ${counter + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    prope3()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:23,259 [main:107] - replacing (prope1 != 10, Boolean)
2021-03-11 21:11:23,272 [main:50] - replacing prope1 != 10 Boolean
2021-03-11 21:11:23,273 [main:54] - Getting value of type Boolean
2021-03-11 21:11:23,414 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:23,416 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:11:23,416 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:23,564 [main:67] - randomType = Char
2021-03-11 21:11:23,698 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:11:23,723 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Char): kotlin.ranges.CharRange defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@45a285b1]
2021-03-11 21:11:23,852 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:11:23,855 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.CharRange.contains(element: kotlin.Char?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@13e0a23f]
2021-03-11 21:11:24,017 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:11:24,020 [main:78] - Generated call from random type = ('⾆').rangeTo('໼').contains('꾈')
2021-03-11 21:11:24,021 [main:106] - GETTING Boolean from Long?
2021-03-11 21:11:24,055 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]]
2021-03-11 21:11:24,055 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:11:24,055 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:11:24,176 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:24,177 [main:117] - GENERATED CALL = (l2).toLong().equals("snznj")
2021-03-11 21:11:24,177 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:11:24,177 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:24,177 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:11:24,177 [main:117] - GENERATED CALL = (l2).toChar().isLowerCase()
2021-03-11 21:11:24,177 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]]
2021-03-11 21:11:24,177 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:24,177 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]
2021-03-11 21:11:24,177 [main:117] - GENERATED CALL = (l2).toChar().isLetter()
2021-03-11 21:11:24,177 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1c6b7dcc]]
2021-03-11 21:11:24,177 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:11:24,302 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:24,303 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1c6b7dcc]
2021-03-11 21:11:24,303 [main:117] - GENERATED CALL = (l2).equals("ozesg").not()
2021-03-11 21:11:24,303 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]]
2021-03-11 21:11:24,303 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:11:24,303 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5130ed87]
2021-03-11 21:11:24,430 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:24,431 [main:117] - GENERATED CALL = (l2).toFloat().equals("kebhm")
2021-03-11 21:11:24,431 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]]
2021-03-11 21:11:24,431 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:24,431 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]
2021-03-11 21:11:24,431 [main:117] - GENERATED CALL = (l2).toChar().isLowSurrogate()
2021-03-11 21:11:24,431 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]]
2021-03-11 21:11:24,431 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:11:24,431 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]
2021-03-11 21:11:24,564 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:24,565 [main:117] - GENERATED CALL = (l2).toShort().equals("czbzt")
2021-03-11 21:11:24,565 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:11:24,565 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:11:24,565 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:11:24,565 [main:117] - GENERATED CALL = (l2).toDouble().isFinite()
2021-03-11 21:11:24,565 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]]
2021-03-11 21:11:24,565 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:11:24,565 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4f6d940e]
2021-03-11 21:11:24,566 [main:117] - GENERATED CALL = (l2).toFloat().isInfinite()
2021-03-11 21:11:24,566 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@31585973]]
2021-03-11 21:11:24,566 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:11:24,686 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:24,686 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@31585973]
2021-03-11 21:11:24,802 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:24,805 [main:117] - GENERATED CALL = (l2).equals("rcrap").xor(true)
2021-03-11 21:11:24,805 [main:114] - replacement of prope1 != 10 of type Boolean is (l2).toChar().isLetter()
2021-03-11 21:11:24,924 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:24,924 [main:66] - Compilation checking started
2021-03-11 21:11:25,224 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {
    prope1++
    prope3 = { it.resume(Unit) }
}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if (prope1 != counter + 1) return "Expected ${counter + 1}, got $prope1"
        prope3()
    }
    if ((l2).toChar().isLetter()) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    prope3()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:25,227 [main:107] - replacing (prope3, Function0<Unit>)
2021-03-11 21:11:25,228 [main:50] - replacing prope3 Function0<Unit>
2021-03-11 21:11:25,228 [main:54] - Getting value of type Function0<Unit>
2021-03-11 21:11:25,358 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-11 21:11:25,360 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:11:25,484 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:11:25,488 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:11:25,877 [main:302] - generating value of type = Boolean true depth = 4
2021-03-11 21:11:25,880 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-11 21:11:25,881 [main:302] - generating value of type = Any false depth = 5
2021-03-11 21:11:25,882 [main:95] - GENERATED = check(true, { "csrij"})
2021-03-11 21:11:25,882 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { check(true, { "csrij"})}
2021-03-11 21:11:25,882 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:25,886 [main:67] - randomType = String
2021-03-11 21:11:26,001 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:11:26,022 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:26,063 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:26,099 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,128 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:26,129 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:26,130 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,131 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,132 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:26,166 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,167 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:26,168 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,169 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,170 [main:106] - GETTING Function0<Unit> from Short
2021-03-11 21:11:26,212 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:26,213 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,214 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:26,215 [main:106] - GETTING Function0<Unit> from Byte
2021-03-11 21:11:26,251 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:26,283 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:26,285 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,285 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,286 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:26,287 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:26,288 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:26,289 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:26,290 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,291 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:26,292 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,293 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:11:26,325 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:26,326 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:26,327 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:26,328 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:26,329 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:26,330 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:26,331 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:26,332 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:26,332 [main:114] - replacement of prope3 of type Function0<Unit> is { check(true, { "csrij"})}
2021-03-11 21:11:26,447 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-11 21:11:26,447 [main:66] - Compilation checking started
2021-03-11 21:11:26,957 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {
    prope1++
    prope3 = { it.resume(Unit) }
}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if (prope1 != counter + 1) return "Expected ${counter + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:26,991 [main:107] - replacing (prope1 != counter + 1, Boolean)
2021-03-11 21:11:26,991 [main:50] - replacing prope1 != counter + 1 Boolean
2021-03-11 21:11:26,991 [main:54] - Getting value of type Boolean
2021-03-11 21:11:27,121 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:27,123 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:11:27,124 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:27,128 [main:67] - randomType = Int
2021-03-11 21:11:27,254 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:27,312 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:11:27,312 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:11:27,313 [main:78] - Generated call from random type = (801862170).toDouble().isFinite()
2021-03-11 21:11:27,314 [main:106] - GETTING Boolean from Short?
2021-03-11 21:11:27,370 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]]
2021-03-11 21:11:27,370 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:11:27,370 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36360aab]
2021-03-11 21:11:27,370 [main:117] - GENERATED CALL = (s2).toChar().isLowSurrogate()
2021-03-11 21:11:27,370 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:11:27,370 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:11:27,371 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:11:27,497 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:27,497 [main:117] - GENERATED CALL = (s2).compareTo(var barg1: Byte =.equals("oksoq")
2021-03-11 21:11:27,498 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]]
2021-03-11 21:11:27,498 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:11:27,498 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]
2021-03-11 21:11:27,498 [main:117] - GENERATED CALL = (s2).toChar().isHighSurrogate()
2021-03-11 21:11:27,498 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@15d84c80], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:11:27,498 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@15d84c80]
2021-03-11 21:11:27,626 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:11:27,628 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:11:27,629 [main:117] - GENERATED CALL = (s2).div(0.4053452241812817).isNaN()
2021-03-11 21:11:27,629 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]]
2021-03-11 21:11:27,629 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3fabd4e2]
2021-03-11 21:11:27,750 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:27,750 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]
2021-03-11 21:11:27,867 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:27,869 [main:117] - GENERATED CALL = (s2).equals("skitu").and(true)
2021-03-11 21:11:27,869 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:11:27,869 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:11:27,869 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:11:27,986 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:27,987 [main:117] - GENERATED CALL = (s2).toDouble().equals("ujpxk")
2021-03-11 21:11:27,987 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@15d84c80], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:11:27,987 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@15d84c80]
2021-03-11 21:11:28,105 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:11:28,107 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:11:28,107 [main:117] - GENERATED CALL = (s2).div(0.8906834942800741).isFinite()
2021-03-11 21:11:28,107 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]]
2021-03-11 21:11:28,107 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:11:28,107 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5cdbcf6b]
2021-03-11 21:11:28,107 [main:117] - GENERATED CALL = (s2).toChar().isDefined()
2021-03-11 21:11:28,108 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6eaba6ed], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@58303fc8]]
2021-03-11 21:11:28,108 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6eaba6ed]
2021-03-11 21:11:28,108 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@58303fc8]
2021-03-11 21:11:28,108 [main:117] - GENERATED CALL = (s2).rangeTo(var barg2: Byte =.isEmpty()
2021-03-11 21:11:28,108 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:11:28,108 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:11:28,108 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:11:28,108 [main:117] - GENERATED CALL = (s2).toChar().isLowerCase()
2021-03-11 21:11:28,108 [main:114] - replacement of prope1 != counter + 1 of type Boolean is (s2).div(0.8906834942800741).isFinite()
2021-03-11 21:11:28,225 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:28,226 [main:66] - Compilation checking started
2021-03-11 21:11:28,519 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {
    prope1++
    prope3 = { it.resume(Unit) }
}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((s2).div(0.8906834942800741).isFinite()) return "Expected ${counter + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:28,521 [main:107] - replacing ({
    prope1++
    prope3 = { it.resume(Unit) }
}, Function1<Continuation<Unit>, Unit>)
2021-03-11 21:11:28,521 [main:50] - replacing {
    prope1++
    prope3 = { it.resume(Unit) }
} Function1<Continuation<Unit>, Unit>
2021-03-11 21:11:28,521 [main:54] - Getting value of type Function1<Continuation<Unit>, Unit>
2021-03-11 21:11:28,641 [main:302] - generating value of type = Function1<Continuation<Unit>, Unit> false depth = 0
2021-03-11 21:11:28,643 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:11:28,649 [main:58] - GENERATED VALUE OF TYPE Function1<Continuation<Unit>, Unit> = {a: Continuation<Unit> -> println()}
2021-03-11 21:11:28,649 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:28,653 [main:67] - randomType = Byte
2021-03-11 21:11:28,771 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:28,816 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int?
2021-03-11 21:11:28,850 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int?
2021-03-11 21:11:28,851 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long?
2021-03-11 21:11:28,884 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Byte?
2021-03-11 21:11:28,925 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long?
2021-03-11 21:11:28,927 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int?
2021-03-11 21:11:28,928 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Byte?
2021-03-11 21:11:28,929 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int?
2021-03-11 21:11:28,931 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Short?
2021-03-11 21:11:28,973 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,004 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long?
2021-03-11 21:11:29,005 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Byte?
2021-03-11 21:11:29,007 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Short?
2021-03-11 21:11:29,008 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Short
2021-03-11 21:11:29,040 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,042 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,043 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Byte
2021-03-11 21:11:29,075 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,077 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-11 21:11:29,108 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,110 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Short?
2021-03-11 21:11:29,111 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,112 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Short?
2021-03-11 21:11:29,114 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long?
2021-03-11 21:11:29,115 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long?
2021-03-11 21:11:29,117 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,118 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,119 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,121 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int?
2021-03-11 21:11:29,122 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,124 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,125 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long?
2021-03-11 21:11:29,127 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long
2021-03-11 21:11:29,128 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int?
2021-03-11 21:11:29,129 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int?
2021-03-11 21:11:29,131 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Long?
2021-03-11 21:11:29,132 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Byte?
2021-03-11 21:11:29,132 [main:114] - replacement of {
    prope1++
    prope3 = { it.resume(Unit) }
} of type Function1<Continuation<Unit>, Unit> is {a: Continuation<Unit> -> println()}
2021-03-11 21:11:29,253 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-11 21:11:29,254 [main:66] - Compilation checking started
2021-03-11 21:11:29,700 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if (prope1 != counter + 1) return "Expected ${counter + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:29,702 [main:107] - replacing (c, SuspendFunction0<Unit>)
2021-03-11 21:11:29,703 [main:50] - replacing c SuspendFunction0<Unit>
2021-03-11 21:11:29,703 [main:54] - Getting value of type SuspendFunction0<Unit>
2021-03-11 21:11:29,828 [main:302] - generating value of type = SuspendFunction0<Unit> false depth = 0
2021-03-11 21:11:29,830 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:11:29,978 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:11:29,981 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:11:30,367 [main:302] - generating value of type = Boolean true depth = 4
2021-03-11 21:11:30,370 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-11 21:11:30,372 [main:302] - generating value of type = Any false depth = 5
2021-03-11 21:11:30,372 [main:95] - GENERATED = require(true, { "exrea"})
2021-03-11 21:11:30,372 [main:58] - GENERATED VALUE OF TYPE SuspendFunction0<Unit> = { require(true, { "exrea"})}
2021-03-11 21:11:30,372 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:30,511 [main:67] - randomType = UInt
2021-03-11 21:11:30,628 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:11:30,668 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:30,716 [main:106] - GETTING SuspendFunction0<Unit> from Int
2021-03-11 21:11:30,747 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:30,780 [main:106] - GETTING SuspendFunction0<Unit> from Byte
2021-03-11 21:11:30,812 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,843 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,844 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,845 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:30,877 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,878 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:30,879 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:30,880 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:30,881 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:30,882 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,882 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:30,916 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:30,917 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,918 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:30,919 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:30,920 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:30,921 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:30,922 [main:106] - GETTING SuspendFunction0<Unit> from Short
2021-03-11 21:11:30,953 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,954 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,955 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:30,956 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:30,957 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:30,958 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,958 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,959 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:30,960 [main:106] - GETTING SuspendFunction0<Unit> from Long?
2021-03-11 21:11:30,961 [main:106] - GETTING SuspendFunction0<Unit> from Byte?
2021-03-11 21:11:30,962 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:30,963 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,964 [main:106] - GETTING SuspendFunction0<Unit> from Long
2021-03-11 21:11:30,965 [main:106] - GETTING SuspendFunction0<Unit> from Short?
2021-03-11 21:11:30,966 [main:106] - GETTING SuspendFunction0<Unit> from Int?
2021-03-11 21:11:30,966 [main:114] - replacement of c of type SuspendFunction0<Unit> is { require(true, { "exrea"})}
2021-03-11 21:11:31,078 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-11 21:11:31,079 [main:66] - Compilation checking started
2021-03-11 21:11:31,353 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    { require(true, { "exrea"})}.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if (prope1 != counter + 1) return "Expected ${counter + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:31,355 [main:107] - replacing (prope1, Int)
2021-03-11 21:11:31,355 [main:50] - replacing prope1 Int
2021-03-11 21:11:31,355 [main:54] - Getting value of type Int
2021-03-11 21:11:31,469 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:31,471 [main:58] - GENERATED VALUE OF TYPE Int = 319789455
2021-03-11 21:11:31,471 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:31,726 [main:67] - randomType = UByte?
2021-03-11 21:11:31,839 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:11:31,869 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@77fa51f2]
2021-03-11 21:11:31,870 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3aff343b]
2021-03-11 21:11:31,870 [main:78] - Generated call from random type = (102.toUByte())?.toByte().countTrailingZeroBits()
2021-03-11 21:11:31,871 [main:106] - GETTING Int from Long
2021-03-11 21:11:31,900 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5751ecf4]]
2021-03-11 21:11:31,900 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:31,900 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5751ecf4]
2021-03-11 21:11:31,900 [main:117] - GENERATED CALL = (0x00000000L shl 32).toInt().takeHighestOneBit()
2021-03-11 21:11:31,900 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@506e1d0f]]
2021-03-11 21:11:31,900 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@506e1d0f]
2021-03-11 21:11:31,901 [main:117] - GENERATED CALL = (0x00000000L shl 32).countLeadingZeroBits()
2021-03-11 21:11:31,901 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]]
2021-03-11 21:11:31,901 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:31,901 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]
2021-03-11 21:11:31,901 [main:117] - GENERATED CALL = (0x00000000L shl 32).toInt().dec()
2021-03-11 21:11:31,901 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]]
2021-03-11 21:11:31,901 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:11:31,901 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]
2021-03-11 21:11:32,016 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:32,018 [main:117] - GENERATED CALL = (0x00000000L shl 32).toByte().times(-110)
2021-03-11 21:11:32,018 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]]
2021-03-11 21:11:32,018 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:32,018 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:11:32,019 [main:117] - GENERATED CALL = (0x00000000L shl 32).toInt().toInt()
2021-03-11 21:11:32,019 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]]
2021-03-11 21:11:32,019 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:32,019 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@bc537fe]
2021-03-11 21:11:32,132 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:32,134 [main:117] - GENERATED CALL = (0x00000000L shl 32).toInt().coerceAtLeast(-1280922303)
2021-03-11 21:11:32,134 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@32dfaf36]]
2021-03-11 21:11:32,134 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:11:32,134 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@32dfaf36]
2021-03-11 21:11:32,135 [main:117] - GENERATED CALL = (0x00000000L shl 32).toByte().div(var barg2: Byte =
2021-03-11 21:11:32,135 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:11:32,135 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:11:32,248 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:32,251 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:11:32,251 [main:117] - GENERATED CALL = (0x00000000L shl 32).compareTo(53).shr(var iarg2: Int =
2021-03-11 21:11:32,251 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]]
2021-03-11 21:11:32,251 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:11:32,251 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]
2021-03-11 21:11:32,251 [main:117] - GENERATED CALL = (0x00000000L shl 32).toByte().compareTo(barg1)
2021-03-11 21:11:32,251 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74385fde]]
2021-03-11 21:11:32,251 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:11:32,251 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74385fde]
2021-03-11 21:11:32,252 [main:117] - GENERATED CALL = (0x00000000L shl 32).compareTo(barg1).times(barg1)
2021-03-11 21:11:32,252 [main:114] - replacement of prope1 of type Int is (0x00000000L shl 32).compareTo(barg1).times(barg1)
2021-03-11 21:11:32,366 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:32,366 [main:66] - Compilation checking started
2021-03-11 21:11:32,814 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != counter + 1) return "Expected ${counter + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:32,816 [main:107] - replacing (counter, Int)
2021-03-11 21:11:32,817 [main:50] - replacing counter Int
2021-03-11 21:11:32,817 [main:54] - Getting value of type Int
2021-03-11 21:11:32,931 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:32,933 [main:58] - GENERATED VALUE OF TYPE Int = -1179864331
2021-03-11 21:11:32,933 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:33,062 [main:67] - randomType = UByte
2021-03-11 21:11:33,174 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:11:33,202 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@5145eae3]
2021-03-11 21:11:33,203 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@14085a6d]
2021-03-11 21:11:33,203 [main:78] - Generated call from random type = (102.toUByte()).toShort().countLeadingZeroBits()
2021-03-11 21:11:33,204 [main:106] - GETTING Int from Long
2021-03-11 21:11:33,232 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]]
2021-03-11 21:11:33,233 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:11:33,233 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:11:33,233 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).compareTo(var barg2: Byte =.and(var iarg1: Int =
2021-03-11 21:11:33,233 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]]
2021-03-11 21:11:33,233 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:11:33,233 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:11:33,233 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).toLong().compareTo(var barg1: Byte =
2021-03-11 21:11:33,234 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]]
2021-03-11 21:11:33,234 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]
2021-03-11 21:11:33,234 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).countTrailingZeroBits()
2021-03-11 21:11:33,234 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]]
2021-03-11 21:11:33,234 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:33,234 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]
2021-03-11 21:11:33,234 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).toInt().xor(iarg1)
2021-03-11 21:11:33,234 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]]
2021-03-11 21:11:33,234 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:11:33,234 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]
2021-03-11 21:11:33,234 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).toByte().times(var barg2: Byte =
2021-03-11 21:11:33,234 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]]
2021-03-11 21:11:33,234 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:33,235 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]
2021-03-11 21:11:33,235 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).toInt().countOneBits()
2021-03-11 21:11:33,235 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74385fde]]
2021-03-11 21:11:33,235 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:33,235 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74385fde]
2021-03-11 21:11:33,235 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).toInt().times(var barg1: Byte =
2021-03-11 21:11:33,235 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@12103546]]
2021-03-11 21:11:33,235 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:11:33,235 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@12103546]
2021-03-11 21:11:33,235 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).toByte().unaryPlus()
2021-03-11 21:11:33,235 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3b8a9150]]
2021-03-11 21:11:33,235 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:11:33,236 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3b8a9150]
2021-03-11 21:11:33,236 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).toShort().countOneBits()
2021-03-11 21:11:33,236 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]]
2021-03-11 21:11:33,236 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:11:33,236 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@15f0e0aa]
2021-03-11 21:11:33,236 [main:117] - GENERATED CALL = ((0x00000000L shl 32)).compareTo(var barg1: Byte =.ushr(var iarg2: Int =
2021-03-11 21:11:33,236 [main:114] - replacement of counter of type Int is ((0x00000000L shl 32)).toInt().xor(iarg1)
2021-03-11 21:11:33,348 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:33,348 [main:66] - Compilation checking started
2021-03-11 21:11:33,783 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            r.getOrThrow()
            prope3 = {
                prope0 = "OK"
                prope2 = true
            }
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != counter + 1) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:33,785 [main:107] - replacing ({
                prope0 = "OK"
                prope2 = true
            }, Function0<Unit>)
2021-03-11 21:11:33,794 [main:50] - replacing {
                prope0 = "OK"
                prope2 = true
            } Function0<Unit>
2021-03-11 21:11:33,794 [main:54] - Getting value of type Function0<Unit>
2021-03-11 21:11:33,937 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-11 21:11:33,939 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:11:33,945 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println()}
2021-03-11 21:11:33,945 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:34,106 [main:67] - randomType = UShort
2021-03-11 21:11:34,236 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:11:34,279 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,325 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:34,373 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,374 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,375 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:34,376 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,377 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:34,414 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:34,415 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:34,416 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:34,417 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,418 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:34,419 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:34,420 [main:106] - GETTING Function0<Unit> from Byte
2021-03-11 21:11:34,451 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:34,452 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,453 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:34,454 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,455 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,456 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:34,490 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:34,522 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,523 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,524 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:34,525 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,526 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:34,527 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:34,528 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:34,529 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:34,530 [main:106] - GETTING Function0<Unit> from Short
2021-03-11 21:11:34,564 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:34,565 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:34,566 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:34,567 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:34,568 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:34,569 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:34,570 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:11:34,600 [main:114] - replacement of {
                prope0 = "OK"
                prope2 = true
            } of type Function0<Unit> is { println()}
2021-03-11 21:11:34,725 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-11 21:11:34,725 [main:66] - Compilation checking started
2021-03-11 21:11:35,181 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != counter + 1) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:35,185 [main:107] - replacing ("resume on root continuation is called", String)
2021-03-11 21:11:35,186 [main:50] - replacing "resume on root continuation is called" String
2021-03-11 21:11:35,186 [main:54] - Getting value of type String
2021-03-11 21:11:35,345 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:11:35,349 [main:58] - GENERATED VALUE OF TYPE String = "rmbsz"
2021-03-11 21:11:35,349 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:36,246 [main:67] - randomType = Function2<HashSet<Byte>, Char?, Char>
2021-03-11 21:11:36,247 [main:106] - GETTING String from Int?
2021-03-11 21:11:36,279 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:11:36,279 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:11:36,279 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:11:36,403 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:36,405 [main:117] - GENERATED CALL = (i4).compareTo(var iarg2: Int =.toString(-1605232690)
2021-03-11 21:11:36,405 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:11:36,405 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:11:36,406 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:11:36,406 [main:117] - GENERATED CALL = (i4).toChar().lowercase()
2021-03-11 21:11:36,406 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:11:36,406 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:36,406 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:11:36,406 [main:117] - GENERATED CALL = (i4).toInt().toString(var iarg1: Int =
2021-03-11 21:11:36,406 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:11:36,406 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:11:36,406 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:11:36,406 [main:117] - GENERATED CALL = (i4).toChar().titlecase()
2021-03-11 21:11:36,406 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:11:36,406 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:11:36,407 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:11:36,407 [main:117] - GENERATED CALL = (i4).div((0xFDDEFDDEL shl 32)).toString(var iarg1: Int =
2021-03-11 21:11:36,407 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:11:36,407 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:11:36,407 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:11:36,407 [main:117] - GENERATED CALL = (i4).and(var iarg1: Int =.toString(var iarg1: Int =
2021-03-11 21:11:36,407 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:11:36,407 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:11:36,407 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:11:36,408 [main:117] - GENERATED CALL = (i4).toLong().toString(iarg1)
2021-03-11 21:11:36,408 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:11:36,408 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:11:36,408 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:11:36,408 [main:117] - GENERATED CALL = (i4).toChar().uppercase()
2021-03-11 21:11:36,408 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:11:36,408 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:11:36,408 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:11:36,408 [main:117] - GENERATED CALL = (i4).toShort().toString(var iarg1: Int =
2021-03-11 21:11:36,408 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:11:36,408 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:11:36,408 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:11:36,533 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:36,536 [main:117] - GENERATED CALL = (i4).toByte().toString(235189226)
2021-03-11 21:11:36,536 [main:114] - replacement of "resume on root continuation is called" of type String is (i4).toChar().uppercase()
2021-03-11 21:11:36,658 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:36,659 [main:66] - Compilation checking started
2021-03-11 21:11:36,969 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != counter + 1) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return (i4).toChar().uppercase()
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:36,972 [main:107] - replacing (counter, Int)
2021-03-11 21:11:36,972 [main:50] - replacing counter Int
2021-03-11 21:11:36,972 [main:54] - Getting value of type Int
2021-03-11 21:11:37,100 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:37,102 [main:58] - GENERATED VALUE OF TYPE Int = 356361787
2021-03-11 21:11:37,103 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:37,391 [main:67] - randomType = Double?
2021-03-11 21:11:37,514 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:11:37,547 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]
2021-03-11 21:11:37,547 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:11:37,547 [main:78] - Generated call from random type = (0.713817620109778)?.compareTo(barg1).shl(iarg1)
2021-03-11 21:11:37,547 [main:114] - replacement of counter of type Int is (0.713817620109778)?.compareTo(barg1).shl(iarg1)
2021-03-11 21:11:37,671 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:37,671 [main:66] - Compilation checking started
2021-03-11 21:11:38,130 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (0.713817620109778)?.compareTo(barg1).shl(iarg1) + 1) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return "resume on root continuation is not called"
    return prope0
}


2021-03-11 21:11:38,133 [main:107] - replacing ("resume on root continuation is not called", String)
2021-03-11 21:11:38,135 [main:50] - replacing "resume on root continuation is not called" String
2021-03-11 21:11:38,135 [main:54] - Getting value of type String
2021-03-11 21:11:38,276 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:11:38,278 [main:58] - GENERATED VALUE OF TYPE String = "khweh"
2021-03-11 21:11:38,278 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:38,573 [main:67] - randomType = ArrayDeque<Boolean>
2021-03-11 21:11:38,722 [main:302] - generating value of type = ArrayDeque<Boolean> false depth = 0
2021-03-11 21:11:38,851 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<Boolean> = TODO()
2021-03-11 21:11:38,854 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<Boolean> = TODO()
2021-03-11 21:11:39,123 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:11:39,126 [main:95] - GENERATED = ArrayDeque<Boolean>(2060040743)
2021-03-11 21:11:39,247 [main:149] - GENERATING call of type public fun <T> kotlin.collections.Iterable<T>.joinToString(separator: kotlin.CharSequence = ..., prefix: kotlin.CharSequence = ..., postfix: kotlin.CharSequence = ..., limit: kotlin.Int = ..., truncated: kotlin.CharSequence = ..., transform: ((T) -> kotlin.CharSequence)? = ...): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@496037ad]
2021-03-11 21:11:39,370 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:11:39,498 [main:43] - GENERATING CALL OF fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-11 21:11:39,502 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-11 21:11:39,777 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:11:39,780 [main:95] - GENERATED = StringBuilder(1077291104)
2021-03-11 21:11:39,906 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:11:40,037 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:11:40,165 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:40,290 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:11:40,420 [main:302] - generating value of type = Function1<T, CharSequence> false depth = 0
2021-03-11 21:11:40,423 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-11 21:11:40,429 [main:78] - Generated call from random type = (ArrayDeque<Boolean>(2060040743)).joinToString(StringBuilder(1077291104), StringBuilder(), "nkear", -310905881, "emovm", {a: T -> "lcrkc"})
2021-03-11 21:11:40,430 [main:106] - GETTING String from Long
2021-03-11 21:11:40,461 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:11:40,461 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:40,461 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:11:40,462 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toChar().lowercase()
2021-03-11 21:11:40,462 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:11:40,462 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:11:40,462 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:11:40,584 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:40,587 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toByte().toString(-512516963)
2021-03-11 21:11:40,587 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:11:40,587 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:40,587 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:11:40,587 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toChar().uppercase()
2021-03-11 21:11:40,587 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:11:40,587 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:11:40,587 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:11:40,588 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toLong().toString(var iarg2: Int =
2021-03-11 21:11:40,588 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:11:40,588 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:11:40,710 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:40,713 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:11:40,838 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:40,840 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).compareTo(-37).toString(-1933282885)
2021-03-11 21:11:40,841 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:11:40,841 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:40,841 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:11:40,841 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toChar().titlecase()
2021-03-11 21:11:40,841 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:11:40,841 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:40,841 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:11:40,966 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:11:40,968 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toChar().plus("myqlv")
2021-03-11 21:11:40,969 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:11:40,969 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:11:40,969 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:11:40,969 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
2021-03-11 21:11:40,969 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:11:40,969 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:40,969 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:11:41,092 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:41,095 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toInt().toString(-582594121)
2021-03-11 21:11:41,095 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:11:41,095 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:11:41,095 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32)).toString(iarg1)
2021-03-11 21:11:41,095 [main:114] - replacement of "resume on root continuation is not called" of type String is ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
2021-03-11 21:11:41,219 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:41,219 [main:66] - Compilation checking started
2021-03-11 21:11:41,708 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (0.713817620109778)?.compareTo(barg1).shl(iarg1) + 1) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if (!prope2) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:41,710 [main:107] - replacing (!prope2, Boolean)
2021-03-11 21:11:41,711 [main:50] - replacing !prope2 Boolean
2021-03-11 21:11:41,711 [main:54] - Getting value of type Boolean
2021-03-11 21:11:41,835 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:41,838 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:11:41,838 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:41,843 [main:67] - randomType = String
2021-03-11 21:11:41,968 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:11:41,988 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@74fd134f]
2021-03-11 21:11:41,988 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]
2021-03-11 21:11:41,989 [main:78] - Generated call from random type = ("sbwad").get(var iarg1: Int =.isHighSurrogate()
2021-03-11 21:11:41,989 [main:106] - GETTING Boolean from Long
2021-03-11 21:11:42,018 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]]
2021-03-11 21:11:42,018 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:11:42,142 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:42,142 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).equals("volbl")
2021-03-11 21:11:42,142 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]]
2021-03-11 21:11:42,142 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:42,142 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]
2021-03-11 21:11:42,143 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).toChar().isTitleCase()
2021-03-11 21:11:42,143 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:11:42,143 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:11:42,143 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:11:42,143 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).toDouble().isNaN()
2021-03-11 21:11:42,143 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.LongRange.contains(element: kotlin.Long?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7f6dbff5]]
2021-03-11 21:11:42,143 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9]
2021-03-11 21:11:42,143 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.LongRange.contains(element: kotlin.Long?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7f6dbff5]
2021-03-11 21:11:42,143 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).rangeTo(var barg1: Byte =.contains(l3)
2021-03-11 21:11:42,143 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.LongRange[DeserializedSimpleFunctionDescriptor@60d49ff7]]
2021-03-11 21:11:42,143 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.LongRange defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@672e34f9]
2021-03-11 21:11:42,267 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:42,270 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.LongRange[DeserializedSimpleFunctionDescriptor@60d49ff7]
2021-03-11 21:11:42,270 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).rangeTo(-49).isEmpty()
2021-03-11 21:11:42,270 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]]
2021-03-11 21:11:42,270 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:11:42,393 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:42,393 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]
2021-03-11 21:11:42,516 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:42,519 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).equals("dpvyn").or(false)
2021-03-11 21:11:42,519 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:11:42,519 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:11:42,519 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:11:42,519 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).toChar().isLowerCase()
2021-03-11 21:11:42,519 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:11:42,519 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:42,519 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:11:42,642 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:42,643 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).toInt().equals("ebost")
2021-03-11 21:11:42,643 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:11:42,643 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:11:42,643 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:11:42,643 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).toDouble().isInfinite()
2021-03-11 21:11:42,643 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:11:42,643 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:11:42,766 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:11:42,769 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:11:42,769 [main:117] - GENERATED CALL = (0xFDDEFDDEL shl 32).div(0.3778619769499504).isInfinite()
2021-03-11 21:11:42,769 [main:114] - replacement of !prope2 of type Boolean is (0xFDDEFDDEL shl 32).equals("volbl")
2021-03-11 21:11:42,892 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:42,892 [main:66] - Compilation checking started
2021-03-11 21:11:43,322 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (0.713817620109778)?.compareTo(barg1).shl(iarg1) + 1) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:43,324 [main:107] - replacing (prope1 != 10, Boolean)
2021-03-11 21:11:43,325 [main:50] - replacing prope1 != 10 Boolean
2021-03-11 21:11:43,325 [main:54] - Getting value of type Boolean
2021-03-11 21:11:43,449 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:43,452 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:11:43,452 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:43,597 [main:67] - randomType = UShort
2021-03-11 21:11:43,722 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:11:43,759 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun rangeTo(other: kotlin.UShort): kotlin.ranges.UIntRange defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@48e4216c]
2021-03-11 21:11:43,883 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:11:43,886 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.UIntRange[DeserializedSimpleFunctionDescriptor@41ddaeb5]
2021-03-11 21:11:43,886 [main:78] - Generated call from random type = (11892.toUShort()).rangeTo(10467.toUShort()).isEmpty()
2021-03-11 21:11:43,887 [main:106] - GETTING Boolean from Byte?
2021-03-11 21:11:43,919 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4f8c26f], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:11:43,919 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4f8c26f]
2021-03-11 21:11:44,043 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:11:44,045 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:11:44,046 [main:117] - GENERATED CALL = (b1).div(0.24659896229173706).isNaN()
2021-03-11 21:11:44,046 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]]
2021-03-11 21:11:44,046 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c]
2021-03-11 21:11:44,171 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:44,172 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]
2021-03-11 21:11:44,295 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:11:44,298 [main:117] - GENERATED CALL = (b1).equals("alwfr").or(true)
2021-03-11 21:11:44,298 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@77f32f2], public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]]
2021-03-11 21:11:44,298 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@77f32f2]
2021-03-11 21:11:44,298 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5c6b3d5f]
2021-03-11 21:11:44,298 [main:117] - GENERATED CALL = (b1).toChar().isHighSurrogate()
2021-03-11 21:11:44,298 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:11:44,298 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:11:44,298 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:11:44,422 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:44,422 [main:117] - GENERATED CALL = (b1).toDouble().equals("zfvkh")
2021-03-11 21:11:44,422 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@77f32f2], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]]
2021-03-11 21:11:44,422 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@77f32f2]
2021-03-11 21:11:44,422 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]
2021-03-11 21:11:44,422 [main:117] - GENERATED CALL = (b1).toChar().isDigit()
2021-03-11 21:11:44,422 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@77f32f2], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]]
2021-03-11 21:11:44,422 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@77f32f2]
2021-03-11 21:11:44,422 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]
2021-03-11 21:11:44,422 [main:117] - GENERATED CALL = (b1).toChar().isISOControl()
2021-03-11 21:11:44,422 [main:113] - Case = [public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@25847567], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c]]
2021-03-11 21:11:44,422 [main:149] - GENERATING call of type public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@25847567]
2021-03-11 21:11:44,422 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c]
2021-03-11 21:11:44,571 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:44,571 [main:117] - GENERATED CALL = (b1).toByte().equals("kzkgl")
2021-03-11 21:11:44,571 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c]]
2021-03-11 21:11:44,571 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@103c707c]
2021-03-11 21:11:44,698 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:11:44,698 [main:117] - GENERATED CALL = (b1).equals("mhqci")
2021-03-11 21:11:44,698 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4f8c26f], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:11:44,698 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@4f8c26f]
2021-03-11 21:11:44,821 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:11:44,824 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:11:44,824 [main:117] - GENERATED CALL = (b1).div(0.3913621681877808).isFinite()
2021-03-11 21:11:44,824 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]]
2021-03-11 21:11:44,824 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:11:44,824 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]
2021-03-11 21:11:44,824 [main:117] - GENERATED CALL = (b1).toFloat().isNaN()
2021-03-11 21:11:44,825 [main:114] - replacement of prope1 != 10 of type Boolean is (b1).div(0.3913621681877808).isFinite()
2021-03-11 21:11:44,948 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:44,949 [main:66] - Compilation checking started
2021-03-11 21:11:45,273 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (0.713817620109778)?.compareTo(barg1).shl(iarg1) + 1) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if ((b1).div(0.3913621681877808).isFinite()) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:45,275 [main:107] - replacing ((0.713817620109778)?.compareTo(barg1).shl(iarg1) + 1, Int)
2021-03-11 21:11:45,276 [main:50] - replacing (0.713817620109778)?.compareTo(barg1).shl(iarg1) + 1 Int
2021-03-11 21:11:45,276 [main:54] - Getting value of type Int
2021-03-11 21:11:45,401 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:45,404 [main:58] - GENERATED VALUE OF TYPE Int = -1112341944
2021-03-11 21:11:45,404 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:45,411 [main:67] - randomType = Byte
2021-03-11 21:11:45,539 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:45,582 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]
2021-03-11 21:11:45,583 [main:78] - Generated call from random type = (-1).toInt()
2021-03-11 21:11:45,583 [main:114] - replacement of (0.713817620109778)?.compareTo(barg1).shl(iarg1) + 1 of type Int is (-1).toInt()
2021-03-11 21:11:45,708 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:45,708 [main:66] - Compilation checking started
2021-03-11 21:11:46,135 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "resume on root continuation is called"
    { check(true, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:46,137 [main:107] - replacing ("resume on root continuation is called", String)
2021-03-11 21:11:46,138 [main:50] - replacing "resume on root continuation is called" String
2021-03-11 21:11:46,138 [main:54] - Getting value of type String
2021-03-11 21:11:46,261 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:11:46,264 [main:58] - GENERATED VALUE OF TYPE String = "pvtku"
2021-03-11 21:11:46,264 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:46,691 [main:67] - randomType = Sequence<UByte>
2021-03-11 21:11:46,692 [main:106] - GETTING String from Short?
2021-03-11 21:11:46,725 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:11:46,725 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:11:46,725 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:11:46,725 [main:117] - GENERATED CALL = (s4).toChar().titlecase()
2021-03-11 21:11:46,725 [main:113] - Case = [public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:11:46,725 [main:149] - GENERATING call of type public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487]
2021-03-11 21:11:46,725 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:11:46,849 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:46,851 [main:117] - GENERATED CALL = (s4).toShort().toString(439118766)
2021-03-11 21:11:46,851 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:11:46,851 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:11:46,851 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:11:46,852 [main:117] - GENERATED CALL = (s4).compareTo(barg1).toString(iarg1)
2021-03-11 21:11:46,852 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:11:46,852 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:11:46,852 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:11:46,974 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:46,977 [main:117] - GENERATED CALL = (s4).toByte().toString(-593932269)
2021-03-11 21:11:46,977 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@222b24dd], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:11:46,977 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@222b24dd]
2021-03-11 21:11:46,977 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:11:47,105 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:47,108 [main:117] - GENERATED CALL = (s4).div((0xFFFFFFFFL shl 32)).toString(222159305)
2021-03-11 21:11:47,108 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:11:47,108 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:11:47,108 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:11:47,108 [main:117] - GENERATED CALL = (s4).toChar().uppercase()
2021-03-11 21:11:47,108 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:11:47,108 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:47,108 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:11:47,109 [main:117] - GENERATED CALL = (s4).toInt().toString(var iarg2: Int =
2021-03-11 21:11:47,109 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:11:47,109 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:11:47,109 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:11:47,109 [main:117] - GENERATED CALL = (s4).toLong().toString(var iarg2: Int =
2021-03-11 21:11:47,109 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:11:47,109 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:11:47,109 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:11:47,109 [main:117] - GENERATED CALL = (s4).toChar().lowercase()
2021-03-11 21:11:47,109 [main:113] - Case = [public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:11:47,109 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Short defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7cd1e0c4]
2021-03-11 21:11:47,109 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:11:47,236 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:47,238 [main:117] - GENERATED CALL = (s4).dec().toString(625488791)
2021-03-11 21:11:47,239 [main:114] - replacement of "resume on root continuation is called" of type String is "pvtku"
2021-03-11 21:11:47,365 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-11 21:11:47,365 [main:66] - Compilation checking started
2021-03-11 21:11:47,824 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(true, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:47,827 [main:107] - replacing (((0x00000000L shl 32)).toInt().xor(iarg1) + 1, Int)
2021-03-11 21:11:47,829 [main:50] - replacing ((0x00000000L shl 32)).toInt().xor(iarg1) + 1 Int
2021-03-11 21:11:47,829 [main:54] - Getting value of type Int
2021-03-11 21:11:47,972 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:47,975 [main:58] - GENERATED VALUE OF TYPE Int = 1371673241
2021-03-11 21:11:47,975 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:47,982 [main:67] - randomType = Int
2021-03-11 21:11:48,109 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:48,143 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16ed68b8]
2021-03-11 21:11:48,143 [main:78] - Generated call from random type = (-1932814307).dec()
2021-03-11 21:11:48,144 [main:106] - GETTING Int from Byte?
2021-03-11 21:11:48,176 [main:113] - Case = [public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@25847567], public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]]
2021-03-11 21:11:48,176 [main:149] - GENERATING call of type public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@25847567]
2021-03-11 21:11:48,176 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@3e2b1b01]
2021-03-11 21:11:48,176 [main:117] - GENERATED CALL = (b3).toByte().toInt()
2021-03-11 21:11:48,176 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]]
2021-03-11 21:11:48,176 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:48,176 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]
2021-03-11 21:11:48,298 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:48,422 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:48,425 [main:117] - GENERATED CALL = (b3).toInt().coerceIn(496567489, -786320633)
2021-03-11 21:11:48,425 [main:113] - Case = [public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:11:48,425 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]
2021-03-11 21:11:48,547 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:48,549 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:11:48,549 [main:117] - GENERATED CALL = (b3).compareTo(77).inc()
2021-03-11 21:11:48,549 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7de53db8]]
2021-03-11 21:11:48,549 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d]
2021-03-11 21:11:48,550 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7de53db8]
2021-03-11 21:11:48,550 [main:117] - GENERATED CALL = (b3).toShort().rem(var barg1: Byte =
2021-03-11 21:11:48,550 [main:113] - Case = [public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@25847567], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]]
2021-03-11 21:11:48,550 [main:149] - GENERATING call of type public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@25847567]
2021-03-11 21:11:48,550 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@5e4f1dc9]
2021-03-11 21:11:48,550 [main:117] - GENERATED CALL = (b3).toByte().minus(var barg1: Byte =
2021-03-11 21:11:48,550 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]]
2021-03-11 21:11:48,550 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:11:48,550 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fa4fe1f]
2021-03-11 21:11:48,676 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:11:48,678 [main:117] - GENERATED CALL = (b3).toInt().or(-1105838446)
2021-03-11 21:11:48,678 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]]
2021-03-11 21:11:48,678 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@1ca56a1d]
2021-03-11 21:11:48,679 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]
2021-03-11 21:11:48,807 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:11:48,810 [main:117] - GENERATED CALL = (b3).toShort().plus(87)
2021-03-11 21:11:48,810 [main:113] - Case = [public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]]
2021-03-11 21:11:48,810 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]
2021-03-11 21:11:48,810 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:11:48,810 [main:117] - GENERATED CALL = (b3).compareTo(barg1).shl(iarg1)
2021-03-11 21:11:48,810 [main:113] - Case = [public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]]
2021-03-11 21:11:48,810 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]
2021-03-11 21:11:48,810 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]
2021-03-11 21:11:48,810 [main:117] - GENERATED CALL = (b3).compareTo(barg1).unaryMinus()
2021-03-11 21:11:48,811 [main:113] - Case = [public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]]
2021-03-11 21:11:48,811 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@6a04f7c6]
2021-03-11 21:11:48,811 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@29a8c90]
2021-03-11 21:11:48,811 [main:117] - GENERATED CALL = (b3).compareTo(var barg2: Byte =.countOneBits()
2021-03-11 21:11:48,811 [main:114] - replacement of ((0x00000000L shl 32)).toInt().xor(iarg1) + 1 of type Int is (b3).compareTo(barg1).shl(iarg1)
2021-03-11 21:11:48,935 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:11:48,935 [main:66] - Compilation checking started
2021-03-11 21:11:49,231 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
r.getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${(b3).compareTo(barg1).shl(iarg1)}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(true, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:49,233 [main:107] - replacing (r, Result<Unit>)
2021-03-11 21:11:49,233 [main:50] - replacing r Result<Unit>
2021-03-11 21:11:49,233 [main:54] - Getting value of type Result<Unit>
2021-03-11 21:11:49,357 [main:302] - generating value of type = Result<Unit> false depth = 0
2021-03-11 21:11:49,485 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Unit): Result<Unit> = TODO()
2021-03-11 21:11:49,489 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Unit): Result<Unit> = TODO()
2021-03-11 21:11:49,764 [main:302] - generating value of type = Function0<Unit> false depth = 3
2021-03-11 21:11:49,766 [main:302] - generating value of type = Unit false depth = 4
2021-03-11 21:11:49,897 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-11 21:11:49,901 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-11 21:11:50,169 [main:302] - generating value of type = Any false depth = 7
2021-03-11 21:11:50,170 [main:95] - GENERATED = print("cphxq")
2021-03-11 21:11:50,170 [main:95] - GENERATED = runCatching<Unit>({ print("cphxq")})
2021-03-11 21:11:50,170 [main:58] - GENERATED VALUE OF TYPE Result<Unit> = runCatching<Unit>({ print("cphxq")})
2021-03-11 21:11:50,170 [main:61] - GENERATED IS CALL =true
2021-03-11 21:11:50,312 [main:67] - randomType = ULong
2021-03-11 21:11:50,464 [main:302] - generating value of type = ULong true depth = 0
2021-03-11 21:11:50,499 [main:106] - GETTING Result<Unit> from Byte?
2021-03-11 21:11:50,532 [main:106] - GETTING Result<Unit> from Short?
2021-03-11 21:11:50,566 [main:106] - GETTING Result<Unit> from Short?
2021-03-11 21:11:50,567 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,597 [main:106] - GETTING Result<Unit> from Byte?
2021-03-11 21:11:50,598 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,600 [main:106] - GETTING Result<Unit> from Long?
2021-03-11 21:11:50,632 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,634 [main:106] - GETTING Result<Unit> from Long?
2021-03-11 21:11:50,635 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,636 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,637 [main:106] - GETTING Result<Unit> from Short?
2021-03-11 21:11:50,638 [main:106] - GETTING Result<Unit> from Int?
2021-03-11 21:11:50,679 [main:106] - GETTING Result<Unit> from Int?
2021-03-11 21:11:50,681 [main:106] - GETTING Result<Unit> from Long?
2021-03-11 21:11:50,682 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,683 [main:106] - GETTING Result<Unit> from Short
2021-03-11 21:11:50,715 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,716 [main:106] - GETTING Result<Unit> from Int?
2021-03-11 21:11:50,717 [main:106] - GETTING Result<Unit> from Short?
2021-03-11 21:11:50,719 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,720 [main:106] - GETTING Result<Unit> from Int?
2021-03-11 21:11:50,721 [main:106] - GETTING Result<Unit> from Long?
2021-03-11 21:11:50,722 [main:106] - GETTING Result<Unit> from Int
2021-03-11 21:11:50,754 [main:106] - GETTING Result<Unit> from Byte?
2021-03-11 21:11:50,755 [main:106] - GETTING Result<Unit> from Byte?
2021-03-11 21:11:50,756 [main:106] - GETTING Result<Unit> from Int?
2021-03-11 21:11:50,757 [main:106] - GETTING Result<Unit> from Long?
2021-03-11 21:11:50,758 [main:106] - GETTING Result<Unit> from Int?
2021-03-11 21:11:50,760 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,761 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,762 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,763 [main:106] - GETTING Result<Unit> from Long?
2021-03-11 21:11:50,764 [main:106] - GETTING Result<Unit> from Long
2021-03-11 21:11:50,765 [main:106] - GETTING Result<Unit> from Byte
2021-03-11 21:11:50,800 [main:106] - GETTING Result<Unit> from Long?
2021-03-11 21:11:50,801 [main:106] - GETTING Result<Unit> from Int?
2021-03-11 21:11:50,801 [main:114] - replacement of r of type Result<Unit> is runCatching<Unit>({ print("cphxq")})
2021-03-11 21:11:50,922 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:11:50,923 [main:66] - Compilation checking started
2021-03-11 21:11:51,412 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(true, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:51,415 [main:107] - replacing (prope3, Function0<Unit>)
2021-03-11 21:11:51,415 [main:50] - replacing prope3 Function0<Unit>
2021-03-11 21:11:51,415 [main:54] - Getting value of type Function0<Unit>
2021-03-11 21:11:51,543 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-11 21:11:51,546 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:11:51,678 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:11:51,682 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:11:52,106 [main:302] - generating value of type = Boolean true depth = 4
2021-03-11 21:11:52,109 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-11 21:11:52,112 [main:302] - generating value of type = Any false depth = 5
2021-03-11 21:11:52,113 [main:95] - GENERATED = check(false, { "ubrkx"})
2021-03-11 21:11:52,113 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { check(false, { "ubrkx"})}
2021-03-11 21:11:52,113 [main:61] - GENERATED IS CALL =false
2021-03-11 21:11:52,400 [main:67] - randomType = UByte?
2021-03-11 21:11:52,524 [main:302] - generating value of type = UByte true depth = 0
2021-03-11 21:11:52,560 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:52,603 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:52,642 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,675 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:52,676 [main:106] - GETTING Function0<Unit> from Byte
2021-03-11 21:11:52,711 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:52,747 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,748 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:52,749 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:52,750 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,751 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:52,752 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,753 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:52,754 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:52,755 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,756 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:52,757 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,758 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,759 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:52,807 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:52,808 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:52,809 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,810 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:52,811 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,812 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:52,814 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:52,815 [main:106] - GETTING Function0<Unit> from Short?
2021-03-11 21:11:52,816 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:11:52,862 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:52,863 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,864 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:11:52,865 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:11:52,866 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:52,867 [main:106] - GETTING Function0<Unit> from Short
2021-03-11 21:11:52,899 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:11:52,900 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,901 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:11:52,901 [main:114] - replacement of prope3 of type Function0<Unit> is { check(false, { "ubrkx"})}
2021-03-11 21:11:53,025 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-11 21:11:53,026 [main:66] - Compilation checking started
2021-03-11 21:11:53,387 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            { check(false, { "ubrkx"})} = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(true, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:53,521 [main:141] - TRYING TO REPLACE CONSTANT true
2021-03-11 21:11:53,649 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:53,649 [main:66] - Compilation checking started
2021-03-11 21:11:54,144 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:54,144 [main:141] - TRYING TO REPLACE CONSTANT 0x00000000L
2021-03-11 21:11:54,274 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(BINARY_EXPRESSION)
2021-03-11 21:11:54,275 [main:66] - Compilation checking started
2021-03-11 21:11:54,717 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 32).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:54,717 [main:141] - TRYING TO REPLACE CONSTANT 32
2021-03-11 21:11:54,843 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:54,844 [main:66] - Compilation checking started
2021-03-11 21:11:55,304 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((0x00000000L shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:55,304 [main:141] - TRYING TO REPLACE CONSTANT 0x00000000L
2021-03-11 21:11:55,433 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:55,433 [main:66] - Compilation checking started
2021-03-11 21:11:55,903 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xDC56DC56L shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:55,904 [main:141] - TRYING TO REPLACE CONSTANT 32
2021-03-11 21:11:56,031 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:56,032 [main:141] - TRYING TO REPLACE CONSTANT 0xDC56DC56L
2021-03-11 21:11:56,156 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(BINARY_EXPRESSION)
2021-03-11 21:11:56,156 [main:66] - Compilation checking started
2021-03-11 21:11:56,649 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl 32)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:56,649 [main:141] - TRYING TO REPLACE CONSTANT 32
2021-03-11 21:11:56,772 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:11:56,773 [main:66] - Compilation checking started
2021-03-11 21:11:57,211 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if ((0xFDDEFDDEL shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:57,212 [main:141] - TRYING TO REPLACE CONSTANT 0xFDDEFDDEL
2021-03-11 21:11:57,350 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PARENTHESIZED)
2021-03-11 21:11:57,351 [main:66] - Compilation checking started
2021-03-11 21:11:57,803 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:57,803 [main:141] - TRYING TO REPLACE CONSTANT 32
2021-03-11 21:11:57,935 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-11 21:11:57,936 [main:66] - Compilation checking started
2021-03-11 21:11:58,244 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (-1).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl toInt()).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:58,245 [main:141] - TRYING TO REPLACE CONSTANT 1
2021-03-11 21:11:58,368 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-11 21:11:58,369 [main:66] - Compilation checking started
2021-03-11 21:11:58,799 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:58,799 [main:41] - AFTER TRY 2 res = import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}


2021-03-11 21:11:59,053 [main:112] - generating klass null text = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
2021-03-11 21:11:59,337 [main:43] - GENERATING CALL OF fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}
2021-03-11 21:11:59,340 [main:61] - WITHOUT TYPE PARAMS = fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}
2021-03-11 21:11:59,654 [main:302] - generating value of type = SuspendFunction0<Unit> false depth = 1
2021-03-11 21:11:59,657 [main:302] - generating value of type = Unit false depth = 2
2021-03-11 21:11:59,787 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:11:59,791 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:12:00,065 [main:302] - generating value of type = Boolean true depth = 5
2021-03-11 21:12:00,068 [main:95] - GENERATED = require(false)
2021-03-11 21:12:00,068 [main:95] - GENERATED = fu2({ require(false)})
2021-03-11 21:12:00,214 [main:43] - Try №2
2021-03-11 21:12:09,623 [main:48] - Already checked
2021-03-11 21:12:13,099 [main:69] - Trying to insert abstract fun fu11(exception: Throwable)
2021-03-11 21:12:13,199 [main:66] - Compilation checking started
2021-03-11 21:12:14,460 [main:103] - Trying to change 185 nodes
2021-03-11 21:12:14,461 [main:107] - replacing (getOrThrow(), Any?)
2021-03-11 21:12:14,472 [main:50] - replacing getOrThrow() Any?
2021-03-11 21:12:14,472 [main:54] - Getting value of type Any?
2021-03-11 21:12:14,677 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:12:14,677 [main:58] - GENERATED VALUE OF TYPE Any? = "tuivj"
2021-03-11 21:12:14,677 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:14,689 [main:67] - randomType = Boolean
2021-03-11 21:12:14,882 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:12:14,900 [main:106] - GETTING Any? from Int
2021-03-11 21:12:14,956 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,007 [main:106] - GETTING Any? from Function0<Unit>
2021-03-11 21:12:15,021 [main:106] - GETTING Any? from Int
2021-03-11 21:12:15,022 [main:106] - GETTING Any? from Int
2021-03-11 21:12:15,023 [main:106] - GETTING Any? from Long?
2021-03-11 21:12:15,057 [main:106] - GETTING Any? from Int?
2021-03-11 21:12:15,089 [main:106] - GETTING Any? from Int
2021-03-11 21:12:15,090 [main:106] - GETTING Any? from Short?
2021-03-11 21:12:15,123 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,124 [main:106] - GETTING Any? from Byte?
2021-03-11 21:12:15,157 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,158 [main:106] - GETTING Any? from Int?
2021-03-11 21:12:15,159 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,160 [main:106] - GETTING Any? from Short
2021-03-11 21:12:15,191 [main:106] - GETTING Any? from Byte?
2021-03-11 21:12:15,192 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,193 [main:106] - GETTING Any? from Short?
2021-03-11 21:12:15,194 [main:106] - GETTING Any? from Int?
2021-03-11 21:12:15,195 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,196 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,197 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,198 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,199 [main:106] - GETTING Any? from Int
2021-03-11 21:12:15,200 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,201 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,202 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,203 [main:106] - GETTING Any? from Short
2021-03-11 21:12:15,204 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,205 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,206 [main:106] - GETTING Any? from Short?
2021-03-11 21:12:15,207 [main:106] - GETTING Any? from Int
2021-03-11 21:12:15,208 [main:106] - GETTING Any? from Function0<Unit>
2021-03-11 21:12:15,209 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,210 [main:106] - GETTING Any? from Long?
2021-03-11 21:12:15,211 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,212 [main:106] - GETTING Any? from Int?
2021-03-11 21:12:15,213 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,214 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,215 [main:106] - GETTING Any? from Int?
2021-03-11 21:12:15,216 [main:106] - GETTING Any? from Int?
2021-03-11 21:12:15,217 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,218 [main:106] - GETTING Any? from Long?
2021-03-11 21:12:15,218 [main:106] - GETTING Any? from Long?
2021-03-11 21:12:15,219 [main:106] - GETTING Any? from Int
2021-03-11 21:12:15,220 [main:106] - GETTING Any? from Byte?
2021-03-11 21:12:15,221 [main:106] - GETTING Any? from Long?
2021-03-11 21:12:15,222 [main:106] - GETTING Any? from Byte
2021-03-11 21:12:15,254 [main:106] - GETTING Any? from Byte?
2021-03-11 21:12:15,255 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,256 [main:106] - GETTING Any? from Short?
2021-03-11 21:12:15,257 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,258 [main:106] - GETTING Any? from Long?
2021-03-11 21:12:15,259 [main:106] - GETTING Any? from Int
2021-03-11 21:12:15,260 [main:106] - GETTING Any? from Long
2021-03-11 21:12:15,261 [main:106] - GETTING Any? from Long?
2021-03-11 21:12:15,262 [main:106] - GETTING Any? from Int?
2021-03-11 21:12:15,262 [main:114] - replacement of getOrThrow() of type Any? is "tuivj"
2021-03-11 21:12:15,456 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-11 21:12:15,456 [main:66] - Compilation checking started
2021-03-11 21:12:15,975 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        val prope13: Kla1 = this
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        prope8.exceptionOrNull()?.let(x)
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8."tuivj"
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if (checkFinished && !prope11) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:15,978 [main:107] - replacing (checkFinished && !prope11, Boolean)
2021-03-11 21:12:15,988 [main:50] - replacing checkFinished && !prope11 Boolean
2021-03-11 21:12:15,988 [main:54] - Getting value of type Boolean
2021-03-11 21:12:16,193 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:12:16,199 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-11 21:12:16,199 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:16,464 [main:67] - randomType = UShort
2021-03-11 21:12:16,661 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:12:16,694 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@5777edb7]
2021-03-11 21:12:16,902 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:12:16,902 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5a9ddc78]
2021-03-11 21:12:17,096 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:12:17,102 [main:78] - Generated call from random type = (12484.toUShort()).equals("psktq").and(true)
2021-03-11 21:12:17,102 [main:114] - replacement of checkFinished && !prope11 of type Boolean is (12484.toUShort()).equals("psktq").and(true)
2021-03-11 21:12:17,299 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:12:17,299 [main:66] - Compilation checking started
2021-03-11 21:12:18,129 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        val prope13: Kla1 = this
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        prope8.exceptionOrNull()?.let(x)
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:18,132 [main:107] - replacing (x, Function1<Throwable, Unit>)
2021-03-11 21:12:18,141 [main:50] - replacing x Function1<Throwable, Unit>
2021-03-11 21:12:18,141 [main:54] - Getting value of type Function1<Throwable, Unit>
2021-03-11 21:12:18,354 [main:302] - generating value of type = Function1<Throwable, Unit> false depth = 0
2021-03-11 21:12:18,360 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:12:18,582 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:12:18,590 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:12:19,053 [main:302] - generating value of type = Boolean true depth = 4
2021-03-11 21:12:19,059 [main:95] - GENERATED = check(true)
2021-03-11 21:12:19,059 [main:58] - GENERATED VALUE OF TYPE Function1<Throwable, Unit> = {a: Throwable -> check(true)}
2021-03-11 21:12:19,060 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:19,305 [main:67] - randomType = UInt
2021-03-11 21:12:19,509 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:12:19,547 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,577 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,609 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,610 [main:106] - GETTING Function1<Throwable, Unit> from Long?
2021-03-11 21:12:19,643 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,644 [main:106] - GETTING Function1<Throwable, Unit> from Long?
2021-03-11 21:12:19,645 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,646 [main:106] - GETTING Function1<Throwable, Unit> from Function0<Unit>
2021-03-11 21:12:19,656 [main:106] - GETTING Function1<Throwable, Unit> from Byte?
2021-03-11 21:12:19,689 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,690 [main:106] - GETTING Function1<Throwable, Unit> from Byte?
2021-03-11 21:12:19,691 [main:106] - GETTING Function1<Throwable, Unit> from Int?
2021-03-11 21:12:19,724 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,726 [main:106] - GETTING Function1<Throwable, Unit> from Long?
2021-03-11 21:12:19,727 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,728 [main:106] - GETTING Function1<Throwable, Unit> from Byte?
2021-03-11 21:12:19,729 [main:106] - GETTING Function1<Throwable, Unit> from Int?
2021-03-11 21:12:19,730 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,731 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,732 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,733 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,734 [main:106] - GETTING Function1<Throwable, Unit> from Short?
2021-03-11 21:12:19,768 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,769 [main:106] - GETTING Function1<Throwable, Unit> from Int?
2021-03-11 21:12:19,770 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,771 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,772 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,774 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,775 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,776 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,777 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,778 [main:106] - GETTING Function1<Throwable, Unit> from Long?
2021-03-11 21:12:19,779 [main:106] - GETTING Function1<Throwable, Unit> from Short?
2021-03-11 21:12:19,780 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,781 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,783 [main:106] - GETTING Function1<Throwable, Unit> from Byte
2021-03-11 21:12:19,822 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,824 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,825 [main:106] - GETTING Function1<Throwable, Unit> from Int?
2021-03-11 21:12:19,826 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,827 [main:106] - GETTING Function1<Throwable, Unit> from Int?
2021-03-11 21:12:19,828 [main:106] - GETTING Function1<Throwable, Unit> from Int
2021-03-11 21:12:19,829 [main:106] - GETTING Function1<Throwable, Unit> from Byte?
2021-03-11 21:12:19,830 [main:106] - GETTING Function1<Throwable, Unit> from Int?
2021-03-11 21:12:19,831 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,833 [main:106] - GETTING Function1<Throwable, Unit> from Long?
2021-03-11 21:12:19,834 [main:106] - GETTING Function1<Throwable, Unit> from Int?
2021-03-11 21:12:19,835 [main:106] - GETTING Function1<Throwable, Unit> from Long?
2021-03-11 21:12:19,836 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,837 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,838 [main:106] - GETTING Function1<Throwable, Unit> from Function0<Unit>
2021-03-11 21:12:19,839 [main:106] - GETTING Function1<Throwable, Unit> from Short?
2021-03-11 21:12:19,840 [main:106] - GETTING Function1<Throwable, Unit> from Short?
2021-03-11 21:12:19,842 [main:106] - GETTING Function1<Throwable, Unit> from Short
2021-03-11 21:12:19,906 [main:106] - GETTING Function1<Throwable, Unit> from Long?
2021-03-11 21:12:19,907 [main:106] - GETTING Function1<Throwable, Unit> from Long
2021-03-11 21:12:19,908 [main:106] - GETTING Function1<Throwable, Unit> from Short
2021-03-11 21:12:19,908 [main:114] - replacement of x of type Function1<Throwable, Unit> is {a: Throwable -> check(true)}
2021-03-11 21:12:20,123 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-11 21:12:20,124 [main:66] - Compilation checking started
2021-03-11 21:12:20,976 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        val prope13: Kla1 = this
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:20,979 [main:107] - replacing (Kla7(), Kla7)
2021-03-11 21:12:20,979 [main:50] - replacing Kla7() Kla7
2021-03-11 21:12:20,979 [main:54] - Getting value of type Kla7
2021-03-11 21:12:21,179 [main:302] - generating value of type = Kla7 false depth = 0
2021-03-11 21:12:21,185 [main:112] - generating klass Kla7 text = class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-11 21:12:21,186 [main:58] - GENERATED VALUE OF TYPE Kla7 = Kla7()
2021-03-11 21:12:21,186 [main:61] - GENERATED IS CALL =true
2021-03-11 21:12:21,198 [main:67] - randomType = String
2021-03-11 21:12:21,404 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:12:21,432 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:12:21,467 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:12:21,468 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,500 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,532 [main:106] - GETTING Kla7 from Function0<Unit>
2021-03-11 21:12:21,542 [main:106] - GETTING Kla7 from Byte
2021-03-11 21:12:21,576 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:12:21,618 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:12:21,669 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,670 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,670 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:12:21,671 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:12:21,672 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,672 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:12:21,673 [main:106] - GETTING Kla7 from Short
2021-03-11 21:12:21,720 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,721 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,721 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:12:21,722 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:12:21,723 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,723 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,724 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:12:21,762 [main:106] - GETTING Kla7 from Function0<Unit>
2021-03-11 21:12:21,762 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:12:21,763 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,764 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:12:21,764 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,765 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,765 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,766 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,767 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,767 [main:106] - GETTING Kla7 from Short
2021-03-11 21:12:21,768 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,768 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,769 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,770 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:12:21,770 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,771 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:12:21,771 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,772 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,773 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,773 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,774 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,774 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,775 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:12:21,776 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:12:21,776 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:12:21,777 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,777 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,778 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:12:21,778 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:12:21,779 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:12:21,780 [main:106] - GETTING Kla7 from Int
2021-03-11 21:12:21,780 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:12:21,781 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,782 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:12:21,782 [main:106] - GETTING Kla7 from Long
2021-03-11 21:12:21,782 [main:114] - replacement of Kla7() of type Kla7 is Kla7()
2021-03-11 21:12:21,984 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:12:21,987 [main:107] - replacing (method, String)
2021-03-11 21:12:21,996 [main:50] - replacing method String
2021-03-11 21:12:21,996 [main:54] - Getting value of type String
2021-03-11 21:12:22,211 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:12:22,218 [main:58] - GENERATED VALUE OF TYPE String = "ljntb"
2021-03-11 21:12:22,218 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:22,503 [main:67] - randomType = Set<Kla4>
2021-03-11 21:12:22,504 [main:106] - GETTING String from Long
2021-03-11 21:12:22,541 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:12:22,541 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:12:22,541 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:12:22,542 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toShort().toString(var iarg1: Int =
2021-03-11 21:12:22,542 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:12:22,542 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:12:22,542 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toString(var prope1 =
2021-03-11 21:12:22,542 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:12:22,542 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:22,542 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:12:22,758 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:12:22,765 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toChar().plus("ztbwm")
2021-03-11 21:12:22,765 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:12:22,765 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:12:22,765 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:12:22,979 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:22,985 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toLong().toString(-1608377919)
2021-03-11 21:12:22,986 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:22,986 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:12:22,986 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:23,195 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:23,202 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toInt().toString(-707769558)
2021-03-11 21:12:23,202 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:12:23,202 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:23,202 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:12:23,202 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toChar().uppercase()
2021-03-11 21:12:23,202 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:12:23,202 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:23,202 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:12:23,203 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toChar().titlecase()
2021-03-11 21:12:23,203 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:12:23,203 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:12:23,203 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:12:23,203 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toByte().toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1))
2021-03-11 21:12:23,203 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:23,203 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:12:23,203 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:23,412 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:23,419 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).compareTo(var barg1: Byte =.toString(401530588)
2021-03-11 21:12:23,419 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:12:23,419 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:23,419 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:12:23,419 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toChar().lowercase()
2021-03-11 21:12:23,419 [main:114] - replacement of method of type String is (((larg2 shl 32) shl 32)).toChar().lowercase()
2021-03-11 21:12:23,666 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:12:23,667 [main:66] - Compilation checking started
2021-03-11 21:12:24,545 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        val prope13: Kla1 = this
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:24,549 [main:107] - replacing (exceptionOrNull(), Throwable?)
2021-03-11 21:12:24,559 [main:50] - replacing exceptionOrNull() Throwable?
2021-03-11 21:12:24,559 [main:54] - Getting value of type Throwable?
2021-03-11 21:12:24,797 [main:302] - generating value of type = Throwable false depth = 0
2021-03-11 21:12:25,028 [main:43] - GENERATING CALL OF fun ConcurrentModificationException(cause: kotlin.Throwable?): Throwable = TODO()
2021-03-11 21:12:25,039 [main:61] - WITHOUT TYPE PARAMS = fun ConcurrentModificationException(cause: kotlin.Throwable?): Throwable = TODO()
2021-03-11 21:12:25,542 [main:95] - GENERATED = ConcurrentModificationException(null)
2021-03-11 21:12:25,542 [main:58] - GENERATED VALUE OF TYPE Throwable? = ConcurrentModificationException(null)
2021-03-11 21:12:25,542 [main:61] - GENERATED IS CALL =true
2021-03-11 21:12:25,557 [main:67] - randomType = UShort
2021-03-11 21:12:25,777 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:12:25,811 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:25,841 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:25,871 [main:106] - GETTING Throwable? from Byte?
2021-03-11 21:12:25,903 [main:106] - GETTING Throwable? from Int?
2021-03-11 21:12:25,936 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:25,936 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:25,937 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:25,938 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:25,938 [main:106] - GETTING Throwable? from Byte?
2021-03-11 21:12:25,939 [main:106] - GETTING Throwable? from Int?
2021-03-11 21:12:25,940 [main:106] - GETTING Throwable? from Short?
2021-03-11 21:12:25,974 [main:106] - GETTING Throwable? from Int?
2021-03-11 21:12:25,974 [main:106] - GETTING Throwable? from Short
2021-03-11 21:12:26,005 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,005 [main:106] - GETTING Throwable? from Long?
2021-03-11 21:12:26,037 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,038 [main:106] - GETTING Throwable? from Function0<Unit>
2021-03-11 21:12:26,048 [main:106] - GETTING Throwable? from Long?
2021-03-11 21:12:26,048 [main:106] - GETTING Throwable? from Short?
2021-03-11 21:12:26,049 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,050 [main:106] - GETTING Throwable? from Short?
2021-03-11 21:12:26,051 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,051 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,052 [main:106] - GETTING Throwable? from Byte?
2021-03-11 21:12:26,053 [main:106] - GETTING Throwable? from Byte
2021-03-11 21:12:26,092 [main:106] - GETTING Throwable? from Function0<Unit>
2021-03-11 21:12:26,093 [main:106] - GETTING Throwable? from Short
2021-03-11 21:12:26,093 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,094 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:26,095 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,095 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,096 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,097 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:26,097 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:26,098 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,099 [main:106] - GETTING Throwable? from Short?
2021-03-11 21:12:26,099 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,100 [main:106] - GETTING Throwable? from Long?
2021-03-11 21:12:26,100 [main:106] - GETTING Throwable? from Int?
2021-03-11 21:12:26,101 [main:106] - GETTING Throwable? from Int?
2021-03-11 21:12:26,102 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,102 [main:106] - GETTING Throwable? from Int?
2021-03-11 21:12:26,103 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,104 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,104 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,105 [main:106] - GETTING Throwable? from Long?
2021-03-11 21:12:26,105 [main:106] - GETTING Throwable? from Long?
2021-03-11 21:12:26,106 [main:106] - GETTING Throwable? from Long?
2021-03-11 21:12:26,107 [main:106] - GETTING Throwable? from Byte?
2021-03-11 21:12:26,107 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,108 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,109 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:26,109 [main:106] - GETTING Throwable? from Long?
2021-03-11 21:12:26,110 [main:106] - GETTING Throwable? from Int?
2021-03-11 21:12:26,111 [main:106] - GETTING Throwable? from Int
2021-03-11 21:12:26,111 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,112 [main:106] - GETTING Throwable? from Long
2021-03-11 21:12:26,112 [main:114] - replacement of exceptionOrNull() of type Throwable? is ConcurrentModificationException(null)
2021-03-11 21:12:26,340 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:12:26,341 [main:66] - Compilation checking started
2021-03-11 21:12:26,992 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        val prope13: Kla1 = this
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.ConcurrentModificationException(null)!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:26,996 [main:107] - replacing (this, Kla2)
2021-03-11 21:12:27,005 [main:50] - replacing this Kla2
2021-03-11 21:12:27,005 [main:54] - Getting value of type Kla2
2021-03-11 21:12:27,244 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-11 21:12:27,283 [main:112] - generating klass Kla2 text = class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = this
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}
2021-03-11 21:12:27,515 [main:194] - Type params = []
2021-03-11 21:12:27,747 [main:58] - GENERATED VALUE OF TYPE Kla2 = Kla2()
2021-03-11 21:12:27,747 [main:61] - GENERATED IS CALL =true
2021-03-11 21:12:28,064 [main:67] - randomType = Kla5<Int>
2021-03-11 21:12:28,296 [main:302] - generating value of type = Kla5<Int> false depth = 0
2021-03-11 21:12:28,304 [main:112] - generating klass Kla5 text = abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-11 21:12:29,691 [main:302] - generating value of type = Kla8 false depth = 2
2021-03-11 21:12:29,699 [main:112] - generating klass Kla8 text = object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}
2021-03-11 21:12:29,713 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,741 [main:106] - GETTING Kla2 from Byte?
2021-03-11 21:12:29,772 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:29,800 [main:106] - GETTING Kla2 from Function0<Unit>
2021-03-11 21:12:29,808 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,809 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,810 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,810 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,811 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:29,811 [main:106] - GETTING Kla2 from Short
2021-03-11 21:12:29,848 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:29,848 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:29,849 [main:106] - GETTING Kla2 from Function0<Unit>
2021-03-11 21:12:29,849 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:29,850 [main:106] - GETTING Kla2 from Long?
2021-03-11 21:12:29,887 [main:106] - GETTING Kla2 from Byte?
2021-03-11 21:12:29,888 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,888 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,889 [main:106] - GETTING Kla2 from Short?
2021-03-11 21:12:29,934 [main:106] - GETTING Kla2 from Long?
2021-03-11 21:12:29,935 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,936 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,936 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,937 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,937 [main:106] - GETTING Kla2 from Short?
2021-03-11 21:12:29,938 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:29,939 [main:106] - GETTING Kla2 from Int?
2021-03-11 21:12:29,983 [main:106] - GETTING Kla2 from Short?
2021-03-11 21:12:29,984 [main:106] - GETTING Kla2 from Int?
2021-03-11 21:12:29,984 [main:106] - GETTING Kla2 from Short?
2021-03-11 21:12:29,985 [main:106] - GETTING Kla2 from Byte
2021-03-11 21:12:30,020 [main:106] - GETTING Kla2 from Long?
2021-03-11 21:12:30,021 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,021 [main:106] - GETTING Kla2 from Long?
2021-03-11 21:12:30,022 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:30,023 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,023 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,024 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,024 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,025 [main:106] - GETTING Kla2 from Int?
2021-03-11 21:12:30,025 [main:106] - GETTING Kla2 from Int?
2021-03-11 21:12:30,026 [main:106] - GETTING Kla2 from Short
2021-03-11 21:12:30,027 [main:106] - GETTING Kla2 from Int?
2021-03-11 21:12:30,027 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,028 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,028 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,029 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:30,030 [main:106] - GETTING Kla2 from Long?
2021-03-11 21:12:30,030 [main:106] - GETTING Kla2 from Byte?
2021-03-11 21:12:30,031 [main:106] - GETTING Kla2 from Long?
2021-03-11 21:12:30,032 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,032 [main:106] - GETTING Kla2 from Int?
2021-03-11 21:12:30,033 [main:106] - GETTING Kla2 from Long?
2021-03-11 21:12:30,033 [main:106] - GETTING Kla2 from Int
2021-03-11 21:12:30,034 [main:106] - GETTING Kla2 from Long
2021-03-11 21:12:30,035 [main:106] - GETTING Kla2 from Int?
2021-03-11 21:12:30,035 [main:106] - GETTING Kla2 from Byte?
2021-03-11 21:12:30,035 [main:114] - replacement of this of type Kla2 is Kla2()
2021-03-11 21:12:30,262 [main:33] - Trying to replace Element(THIS_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:12:30,262 [main:66] - Compilation checking started
2021-03-11 21:12:31,430 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:31,435 [main:107] - replacing (prope5, Continuation<*>)
2021-03-11 21:12:31,449 [main:50] - replacing prope5 Continuation<*>
2021-03-11 21:12:31,449 [main:54] - Getting value of type Continuation<*>
2021-03-11 21:12:31,697 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-11 21:12:31,945 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-11 21:12:31,956 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-11 21:12:32,862 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-11 21:12:33,123 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:12:33,134 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:12:33,742 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-11 21:12:34,005 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:12:34,016 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:12:34,918 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:12:34,918 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:12:34,918 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-11 21:12:34,918 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-11 21:12:35,881 [main:67] - randomType = Function1<Array<Char>, UInt>
2021-03-11 21:12:35,883 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:35,921 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:12:35,950 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:12:35,951 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:35,952 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:35,953 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:35,982 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:35,983 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:35,984 [main:106] - GETTING Continuation<*> from Function0<Unit>
2021-03-11 21:12:35,992 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:12:36,023 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,024 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,025 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,025 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,026 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:12:36,027 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:12:36,028 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:12:36,029 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,030 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:12:36,030 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,031 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,032 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:12:36,033 [main:106] - GETTING Continuation<*> from Function0<Unit>
2021-03-11 21:12:36,034 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:12:36,065 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,066 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,067 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:12:36,068 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:36,069 [main:106] - GETTING Continuation<*> from Short
2021-03-11 21:12:36,098 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:12:36,130 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:36,130 [main:106] - GETTING Continuation<*> from Short
2021-03-11 21:12:36,131 [main:106] - GETTING Continuation<*> from Byte
2021-03-11 21:12:36,160 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,161 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,162 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:12:36,163 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:36,164 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:12:36,165 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:12:36,165 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,166 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:12:36,167 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:12:36,168 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,169 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:36,169 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:12:36,170 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:36,171 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:12:36,172 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:12:36,173 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:12:36,174 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,174 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,175 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:12:36,176 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,177 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:12:36,178 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,178 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:12:36,179 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:12:36,179 [main:111] - Cant find and generate replacement for prope5 type Continuation<*>
2021-03-11 21:12:36,179 [main:107] - replacing ("UNSUPPORTED_FEATURE", String)
2021-03-11 21:12:36,179 [main:50] - replacing "UNSUPPORTED_FEATURE" String
2021-03-11 21:12:36,179 [main:54] - Getting value of type String
2021-03-11 21:12:36,421 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:12:36,464 [main:58] - GENERATED VALUE OF TYPE String = "mftao"
2021-03-11 21:12:36,464 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:37,146 [main:67] - randomType = Function2<Kla3?, Long, Kla0>
2021-03-11 21:12:37,147 [main:106] - GETTING String from Int?
2021-03-11 21:12:37,178 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:37,179 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:12:37,179 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:37,179 [main:117] - GENERATED CALL = (i3).compareTo(var iarg2: Int =.toString(((larg2 shl 32)).toInt().xor(iarg1))
2021-03-11 21:12:37,179 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:37,179 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:12:37,179 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:37,180 [main:117] - GENERATED CALL = (i3).and(((larg2 shl 32)).toInt()).toString(var iarg2: Int =
2021-03-11 21:12:37,180 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:12:37,180 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:12:37,180 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:12:37,180 [main:117] - GENERATED CALL = (i3).toShort().toString(var iarg2: Int =
2021-03-11 21:12:37,180 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:12:37,180 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:12:37,180 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:12:37,180 [main:117] - GENERATED CALL = (i3).toByte().toString(var iarg2: Int =
2021-03-11 21:12:37,181 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:12:37,181 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:12:37,181 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:12:37,181 [main:117] - GENERATED CALL = (i3).div((0xB98AB98AL shl 32)).toString(iarg1)
2021-03-11 21:12:37,181 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:12:37,181 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:12:37,181 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:12:37,417 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:37,426 [main:117] - GENERATED CALL = (i3).toLong().toString(823552208)
2021-03-11 21:12:37,426 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:12:37,426 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:12:37,426 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:12:37,426 [main:117] - GENERATED CALL = (i3).toChar().titlecase()
2021-03-11 21:12:37,426 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:12:37,426 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:12:37,426 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:12:37,426 [main:117] - GENERATED CALL = (i3).toChar().lowercase()
2021-03-11 21:12:37,426 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:12:37,426 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:12:37,426 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:12:37,427 [main:117] - GENERATED CALL = (i3).toChar().plus(var prope0 =
2021-03-11 21:12:37,427 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:37,427 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:12:37,427 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:37,427 [main:117] - GENERATED CALL = (i3).toInt().toString(var iarg2: Int =
2021-03-11 21:12:37,427 [main:114] - replacement of "UNSUPPORTED_FEATURE" of type String is (i3).toChar().titlecase()
2021-03-11 21:12:37,664 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:12:37,664 [main:66] - Compilation checking started
2021-03-11 21:12:38,316 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress((i3).toChar().titlecase())
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        prope9.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:38,321 [main:107] - replacing ("tail-call optimization miss: method at ", String)
2021-03-11 21:12:38,331 [main:50] - replacing "tail-call optimization miss: method at " String
2021-03-11 21:12:38,331 [main:54] - Getting value of type String
2021-03-11 21:12:38,581 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:12:38,589 [main:58] - GENERATED VALUE OF TYPE String = "oxjkf"
2021-03-11 21:12:38,589 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:38,607 [main:67] - randomType = Int
2021-03-11 21:12:38,885 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:38,923 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:12:38,924 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:38,924 [main:78] - Generated call from random type = (-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1))
2021-03-11 21:12:38,925 [main:106] - GETTING String from Short
2021-03-11 21:12:38,955 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:12:38,955 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:12:38,955 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:12:38,955 [main:117] - GENERATED CALL = (sarg1).toChar().plus(var prope0 =
2021-03-11 21:12:38,955 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:38,955 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:12:38,955 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:38,956 [main:117] - GENERATED CALL = (sarg1).toInt().toString((0x00000000L shl 32 shl 1).compareTo(barg1))
2021-03-11 21:12:38,956 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:38,956 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@56bc1039]
2021-03-11 21:12:39,204 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:12:39,212 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:39,460 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:39,468 [main:117] - GENERATED CALL = (sarg1).compareTo(-97).toString(1731245193)
2021-03-11 21:12:39,469 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:12:39,469 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:12:39,469 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:12:39,469 [main:117] - GENERATED CALL = (sarg1).toChar().titlecase()
2021-03-11 21:12:39,469 [main:113] - Case = [public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:12:39,469 [main:149] - GENERATING call of type public abstract fun toShort(): kotlin.Short defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7d6ac487]
2021-03-11 21:12:39,469 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:12:39,469 [main:117] - GENERATED CALL = (sarg1).toShort().toString((0x00000000L shl 32 shl 1).compareTo(barg1))
2021-03-11 21:12:39,469 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:12:39,469 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:12:39,469 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:12:39,470 [main:117] - GENERATED CALL = (sarg1).toLong().toString((0x00000000L shl 32 shl 1).compareTo(barg1))
2021-03-11 21:12:39,470 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:12:39,470 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1322eeeb]
2021-03-11 21:12:39,470 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:12:39,470 [main:117] - GENERATED CALL = (sarg1).toByte().toString(var iarg1: Int =
2021-03-11 21:12:39,470 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:12:39,470 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:12:39,470 [main:117] - GENERATED CALL = (sarg1).toString(var iarg1: Int =
2021-03-11 21:12:39,470 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:12:39,470 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:12:39,470 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:12:39,470 [main:117] - GENERATED CALL = (sarg1).toChar().uppercase()
2021-03-11 21:12:39,470 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:12:39,471 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@493f323d]
2021-03-11 21:12:39,471 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:12:39,471 [main:117] - GENERATED CALL = (sarg1).toChar().lowercase()
2021-03-11 21:12:39,471 [main:114] - replacement of "tail-call optimization miss: method at " of type String is (-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1))
2021-03-11 21:12:39,716 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:12:39,717 [main:66] - Compilation checking started
2021-03-11 21:12:40,735 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:40,742 [main:107] - replacing ({
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}, Function1<Continuation<Ty0>, Unit>)
2021-03-11 21:12:40,742 [main:50] - replacing {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
} Function1<Continuation<Ty0>, Unit>
2021-03-11 21:12:40,742 [main:54] - Getting value of type Function1<Continuation<Ty0>, Unit>
2021-03-11 21:12:40,995 [main:302] - generating value of type = Function1<Continuation<Ty0>, Unit> false depth = 0
2021-03-11 21:12:41,006 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:12:41,275 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:12:41,289 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:12:41,894 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 4
2021-03-11 21:12:41,906 [main:302] - generating value of type = Unit false depth = 5
2021-03-11 21:12:42,171 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:12:42,185 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:12:43,147 [main:302] - generating value of type = Boolean true depth = 8
2021-03-11 21:12:43,158 [main:302] - generating value of type = Function0<Any> false depth = 8
2021-03-11 21:12:43,169 [main:302] - generating value of type = Any false depth = 9
2021-03-11 21:12:43,169 [main:95] - GENERATED = require(false, { "sdnmc"})
2021-03-11 21:12:43,170 [main:95] - GENERATED = contract({ require(false, { "sdnmc"})})
2021-03-11 21:12:43,170 [main:58] - GENERATED VALUE OF TYPE Function1<Continuation<Ty0>, Unit> = {a: Continuation<Ty0> -> contract({ require(false, { "sdnmc"})})}
2021-03-11 21:12:43,170 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:43,216 [main:67] - randomType = Long?
2021-03-11 21:12:43,462 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:12:43,505 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:12:43,537 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:12:43,568 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:12:43,600 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,628 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:12:43,658 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,660 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,689 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,691 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,692 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,694 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,695 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,697 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,698 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,699 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,701 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,702 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,704 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,705 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,706 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,708 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,709 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:12:43,711 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:12:43,712 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short
2021-03-11 21:12:43,743 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,745 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:12:43,746 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:12:43,747 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short
2021-03-11 21:12:43,749 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Function0<Unit>
2021-03-11 21:12:43,758 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,760 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:12:43,761 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:12:43,763 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,764 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,766 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,767 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,769 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:12:43,770 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,771 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,773 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:12:43,774 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,776 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:12:43,777 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,778 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:12:43,780 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:12:43,781 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:12:43,783 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,784 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:12:43,785 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:12:43,787 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Function0<Unit>
2021-03-11 21:12:43,788 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte
2021-03-11 21:12:43,819 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:12:43,820 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:12:43,822 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:12:43,823 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:12:43,824 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:12:43,826 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:12:43,826 [main:114] - replacement of {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
} of type Function1<Continuation<Ty0>, Unit> is {a: Continuation<Ty0> -> contract({ require(false, { "sdnmc"})})}
2021-03-11 21:12:44,076 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-11 21:12:44,077 [main:66] - Compilation checking started
2021-03-11 21:12:44,747 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {a: Continuation<Ty0> -> contract({ require(false, { "sdnmc"})})}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope12 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:44,753 [main:107] - replacing (prope12, Function0<Unit>)
2021-03-11 21:12:44,753 [main:50] - replacing prope12 Function0<Unit>
2021-03-11 21:12:44,753 [main:54] - Getting value of type Function0<Unit>
2021-03-11 21:12:45,000 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-11 21:12:45,011 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:12:45,270 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:12:45,284 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:12:45,887 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 4
2021-03-11 21:12:45,898 [main:302] - generating value of type = Unit false depth = 5
2021-03-11 21:12:46,160 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:12:46,173 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:12:47,145 [main:302] - generating value of type = Boolean true depth = 8
2021-03-11 21:12:47,156 [main:302] - generating value of type = Function0<Any> false depth = 8
2021-03-11 21:12:47,168 [main:302] - generating value of type = Any false depth = 9
2021-03-11 21:12:47,168 [main:95] - GENERATED = check(false, { "zywip"})
2021-03-11 21:12:47,168 [main:95] - GENERATED = contract({ check(false, { "zywip"})})
2021-03-11 21:12:47,168 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { contract({ check(false, { "zywip"})})}
2021-03-11 21:12:47,169 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:47,215 [main:67] - randomType = Kla2
2021-03-11 21:12:47,465 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-11 21:12:47,476 [main:112] - generating klass Kla2 text = class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}
2021-03-11 21:12:47,721 [main:194] - Type params = []
2021-03-11 21:12:47,976 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,008 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,009 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:12:48,045 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,046 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,047 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:12:48,098 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:12:48,129 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:12:48,130 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:12:48,131 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:12:48,132 [main:106] - GETTING Function0<Unit> from Byte
2021-03-11 21:12:48,161 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,162 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,163 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:12:48,164 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:12:48,165 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,166 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,167 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,168 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,169 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,170 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:12:48,171 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:12:48,172 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:12:48,204 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,205 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:12:48,206 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,207 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:12:48,207 [main:106] - GETTING Function0<Unit> from Function0<Unit>
2021-03-11 21:12:48,215 [main:114] - replacement of prope12 of type Function0<Unit> is prope3
2021-03-11 21:12:48,458 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:12:48,458 [main:66] - Compilation checking started
2021-03-11 21:12:49,511 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:49,517 [main:107] - replacing ("OK", String)
2021-03-11 21:12:49,527 [main:50] - replacing "OK" String
2021-03-11 21:12:49,527 [main:54] - Getting value of type String
2021-03-11 21:12:49,791 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:12:49,803 [main:58] - GENERATED VALUE OF TYPE String = "gvgoy"
2021-03-11 21:12:49,803 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:49,828 [main:67] - randomType = Boolean
2021-03-11 21:12:50,119 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:12:50,140 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@538d4716]
2021-03-11 21:12:50,140 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:50,140 [main:78] - Generated call from random type = (true).compareTo(var prope2 =.toString(((larg2 shl 32)).toInt().xor(iarg1))
2021-03-11 21:12:50,141 [main:106] - GETTING String from Long
2021-03-11 21:12:50,175 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:50,175 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:12:50,175 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:50,176 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toInt().toString(var iarg1: Int =
2021-03-11 21:12:50,176 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:12:50,176 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:12:50,176 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:12:50,440 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:50,452 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toByte().toString(-120893173)
2021-03-11 21:12:50,453 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:12:50,453 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:12:50,453 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:12:50,453 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).compareTo(var barg2: Byte =.toString(iarg1)
2021-03-11 21:12:50,453 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:12:50,453 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:50,453 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:12:50,453 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toChar().plus(var prope0 =
2021-03-11 21:12:50,453 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:12:50,453 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:12:50,454 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:12:50,454 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toLong().toString(var iarg1: Int =
2021-03-11 21:12:50,454 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:12:50,454 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:12:50,454 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toString(var prope1 =
2021-03-11 21:12:50,454 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:12:50,454 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:50,454 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:12:50,454 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toChar().uppercase()
2021-03-11 21:12:50,454 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:12:50,454 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:50,454 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:12:50,454 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toChar().titlecase()
2021-03-11 21:12:50,455 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:12:50,455 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:12:50,455 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:12:50,455 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toShort().toString((0x00000000L shl 32 shl 1).compareTo(barg1))
2021-03-11 21:12:50,455 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:12:50,455 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:12:50,455 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:12:50,455 [main:117] - GENERATED CALL = (0xB98AB98AL shl 32).toChar().lowercase()
2021-03-11 21:12:50,455 [main:114] - replacement of "OK" of type String is (0xB98AB98AL shl 32).toChar().plus(var prope0 =
2021-03-11 21:12:50,707 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(BINARY_EXPRESSION)
2021-03-11 21:12:50,708 [main:66] - Compilation checking started
2021-03-11 21:12:50,729 [main:71] - Wrong syntax or breaks conditions
2021-03-11 21:12:50,729 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0((0xB98AB98AL shl 32).toChar().plus(var prope0 =))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:50,736 [main:107] - replacing (it as Continuation<Any>, Continuation<Any>)
2021-03-11 21:12:50,736 [main:50] - replacing it as Continuation<Any> Continuation<Any>
2021-03-11 21:12:50,736 [main:54] - Getting value of type Continuation<Any>
2021-03-11 21:12:50,990 [main:302] - generating value of type = Continuation<Any> false depth = 0
2021-03-11 21:12:51,259 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-11 21:12:51,274 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-11 21:12:52,264 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-11 21:12:52,532 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:12:52,547 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:12:53,198 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-11 21:12:53,483 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:12:53,498 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:12:54,564 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:12:54,564 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:12:54,564 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-11 21:12:54,564 [main:58] - GENERATED VALUE OF TYPE Continuation<Any> = 
2021-03-11 21:12:54,614 [main:67] - randomType = Kla1
2021-03-11 21:12:54,615 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,644 [main:106] - GETTING Continuation<Any> from Long?
2021-03-11 21:12:54,675 [main:106] - GETTING Continuation<Any> from Long?
2021-03-11 21:12:54,676 [main:106] - GETTING Continuation<Any> from Byte?
2021-03-11 21:12:54,707 [main:106] - GETTING Continuation<Any> from Int?
2021-03-11 21:12:54,737 [main:106] - GETTING Continuation<Any> from Int?
2021-03-11 21:12:54,738 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,739 [main:106] - GETTING Continuation<Any> from Short
2021-03-11 21:12:54,768 [main:106] - GETTING Continuation<Any> from Short
2021-03-11 21:12:54,769 [main:106] - GETTING Continuation<Any> from Int?
2021-03-11 21:12:54,770 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,771 [main:106] - GETTING Continuation<Any> from Byte
2021-03-11 21:12:54,801 [main:106] - GETTING Continuation<Any> from Int?
2021-03-11 21:12:54,801 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,830 [main:106] - GETTING Continuation<Any> from Long?
2021-03-11 21:12:54,831 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,832 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,833 [main:106] - GETTING Continuation<Any> from Function0<Unit>
2021-03-11 21:12:54,842 [main:106] - GETTING Continuation<Any> from Byte?
2021-03-11 21:12:54,843 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,844 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,845 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,846 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,847 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,848 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,849 [main:106] - GETTING Continuation<Any> from Function0<Unit>
2021-03-11 21:12:54,850 [main:106] - GETTING Continuation<Any> from Byte?
2021-03-11 21:12:54,850 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,851 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,852 [main:106] - GETTING Continuation<Any> from Int?
2021-03-11 21:12:54,853 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,854 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,855 [main:106] - GETTING Continuation<Any> from Short?
2021-03-11 21:12:54,887 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,888 [main:106] - GETTING Continuation<Any> from Long?
2021-03-11 21:12:54,889 [main:106] - GETTING Continuation<Any> from Long?
2021-03-11 21:12:54,890 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,890 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,891 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,892 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,893 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,894 [main:106] - GETTING Continuation<Any> from Int?
2021-03-11 21:12:54,895 [main:106] - GETTING Continuation<Any> from Short?
2021-03-11 21:12:54,896 [main:106] - GETTING Continuation<Any> from Int?
2021-03-11 21:12:54,897 [main:106] - GETTING Continuation<Any> from Byte?
2021-03-11 21:12:54,898 [main:106] - GETTING Continuation<Any> from Short?
2021-03-11 21:12:54,899 [main:106] - GETTING Continuation<Any> from Long?
2021-03-11 21:12:54,900 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,900 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,901 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,902 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,903 [main:106] - GETTING Continuation<Any> from Long?
2021-03-11 21:12:54,904 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,905 [main:106] - GETTING Continuation<Any> from Short?
2021-03-11 21:12:54,906 [main:106] - GETTING Continuation<Any> from Long
2021-03-11 21:12:54,907 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,908 [main:106] - GETTING Continuation<Any> from Int
2021-03-11 21:12:54,908 [main:111] - Cant find and generate replacement for it as Continuation<Any> type Continuation<Any>
2021-03-11 21:12:54,908 [main:107] - replacing (resume(Kla0("OK")), Unit?)
2021-03-11 21:12:54,908 [main:50] - replacing resume(Kla0("OK")) Unit?
2021-03-11 21:12:54,908 [main:54] - Getting value of type Unit?
2021-03-11 21:12:55,164 [main:302] - generating value of type = Unit false depth = 0
2021-03-11 21:12:55,432 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-11 21:12:55,446 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-11 21:12:56,050 [main:302] - generating value of type = Any false depth = 3
2021-03-11 21:12:56,050 [main:95] - GENERATED = println("kmegc")
2021-03-11 21:12:56,050 [main:58] - GENERATED VALUE OF TYPE Unit? = println("kmegc")
2021-03-11 21:12:56,050 [main:61] - GENERATED IS CALL =true
2021-03-11 21:12:56,406 [main:67] - randomType = Kla8
2021-03-11 21:12:56,661 [main:302] - generating value of type = Kla8 false depth = 0
2021-03-11 21:12:56,673 [main:112] - generating klass Kla8 text = object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}
2021-03-11 21:12:56,690 [main:149] - GENERATING call of type public open fun resume(value: kotlin.Unit): kotlin.Unit defined in Kla8[SimpleFunctionDescriptorImpl@16e83e36]
2021-03-11 21:12:56,690 [main:78] - Generated call from random type = (Kla8).resume(fu2 {
        fu3()
    })
2021-03-11 21:12:56,695 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,724 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,724 [main:106] - GETTING Unit? from Short
2021-03-11 21:12:56,753 [main:106] - GETTING Unit? from Long?
2021-03-11 21:12:56,784 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,785 [main:106] - GETTING Unit? from Long?
2021-03-11 21:12:56,786 [main:106] - GETTING Unit? from Int?
2021-03-11 21:12:56,819 [main:106] - GETTING Unit? from Byte?
2021-03-11 21:12:56,852 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,853 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,854 [main:106] - GETTING Unit? from Long?
2021-03-11 21:12:56,854 [main:106] - GETTING Unit? from Int?
2021-03-11 21:12:56,855 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:56,891 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,891 [main:106] - GETTING Unit? from Int?
2021-03-11 21:12:56,892 [main:106] - GETTING Unit? from Long?
2021-03-11 21:12:56,893 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:56,894 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,895 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,896 [main:106] - GETTING Unit? from Short?
2021-03-11 21:12:56,946 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,948 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,949 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,950 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:56,951 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,951 [main:106] - GETTING Unit? from Int?
2021-03-11 21:12:56,952 [main:106] - GETTING Unit? from Byte?
2021-03-11 21:12:56,953 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,954 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:56,955 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,956 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,957 [main:106] - GETTING Unit? from Int?
2021-03-11 21:12:56,958 [main:106] - GETTING Unit? from Int?
2021-03-11 21:12:56,959 [main:106] - GETTING Unit? from Long?
2021-03-11 21:12:56,960 [main:106] - GETTING Unit? from Short?
2021-03-11 21:12:56,961 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,962 [main:106] - GETTING Unit? from Long?
2021-03-11 21:12:56,963 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,964 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:56,964 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:56,965 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:56,966 [main:106] - GETTING Unit? from Byte
2021-03-11 21:12:57,011 [main:106] - GETTING Unit? from Long
2021-03-11 21:12:57,012 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:57,013 [main:106] - GETTING Unit? from Short
2021-03-11 21:12:57,014 [main:106] - GETTING Unit? from Int
2021-03-11 21:12:57,015 [main:106] - GETTING Unit? from Long?
2021-03-11 21:12:57,016 [main:106] - GETTING Unit? from Function0<Unit>
2021-03-11 21:12:57,027 [main:113] - Case = [public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@6f0b9843]]
2021-03-11 21:12:57,027 [main:149] - GENERATING call of type public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@6f0b9843]
2021-03-11 21:12:57,027 [main:117] - GENERATED CALL = ({ check(prope2, { "csrij"})})?.invoke()
2021-03-11 21:12:57,027 [main:114] - replacement of resume(Kla0("OK")) of type Unit? is ({ check(prope2, { "csrij"})})?.invoke()
2021-03-11 21:12:57,311 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-11 21:12:57,311 [main:66] - Compilation checking started
2021-03-11 21:12:57,996 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.({ check(prope2, { "csrij"})})?.invoke()
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in 1..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:12:58,003 [main:107] - replacing (1, Int)
2021-03-11 21:12:58,004 [main:50] - replacing 1 Int
2021-03-11 21:12:58,004 [main:54] - Getting value of type Int
2021-03-11 21:12:58,261 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:12:58,273 [main:58] - GENERATED VALUE OF TYPE Int = -821258249
2021-03-11 21:12:58,273 [main:61] - GENERATED IS CALL =false
2021-03-11 21:12:58,299 [main:67] - randomType = UShort
2021-03-11 21:12:58,550 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:12:58,589 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@459391b9]
2021-03-11 21:12:58,589 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@466e45bd]
2021-03-11 21:12:58,589 [main:78] - Generated call from random type = (27647.toUShort()).toByte().times(barg1)
2021-03-11 21:12:58,590 [main:106] - GETTING Int from Long
2021-03-11 21:12:58,617 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]]
2021-03-11 21:12:58,617 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:12:58,869 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:12:58,881 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4df01ae3]
2021-03-11 21:12:58,882 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).compareTo(102).takeLowestOneBit()
2021-03-11 21:12:58,882 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4a848b8e]]
2021-03-11 21:12:58,882 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:12:59,134 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:12:59,146 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4a848b8e]
2021-03-11 21:12:59,146 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).compareTo(-69).compareTo(var barg2: Byte =
2021-03-11 21:12:59,146 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@46fab768]]
2021-03-11 21:12:59,146 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:12:59,146 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@46fab768]
2021-03-11 21:12:59,400 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:12:59,412 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).toFloat().compareTo(68)
2021-03-11 21:12:59,412 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3aff343b]]
2021-03-11 21:12:59,412 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:12:59,412 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@3aff343b]
2021-03-11 21:12:59,412 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).toByte().countTrailingZeroBits()
2021-03-11 21:12:59,412 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f], public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]]
2021-03-11 21:12:59,413 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@594d3c8f]
2021-03-11 21:12:59,665 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:12:59,677 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@14e960c0]
2021-03-11 21:12:59,677 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).div(0.8483686043166423).toInt()
2021-03-11 21:12:59,677 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]]
2021-03-11 21:12:59,677 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:12:59,677 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@150fb7be]
2021-03-11 21:12:59,929 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:12:59,942 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)
2021-03-11 21:12:59,942 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:12:59,942 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:12:59,942 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:12:59,942 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).compareTo(var barg1: Byte =.shr(var iarg2: Int =
2021-03-11 21:12:59,942 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], @kotlin.SinceKotlin public fun kotlin.Double.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@5645a0d]]
2021-03-11 21:12:59,942 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:12:59,942 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Double.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@5645a0d]
2021-03-11 21:12:59,942 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).toDouble().roundToInt()
2021-03-11 21:12:59,942 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@adba42a]]
2021-03-11 21:12:59,942 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:12:59,942 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@adba42a]
2021-03-11 21:12:59,943 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).toFloat().toRawBits()
2021-03-11 21:12:59,943 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]]
2021-03-11 21:12:59,943 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:12:59,943 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]
2021-03-11 21:12:59,943 [main:117] - GENERATED CALL = ((0xDC56DC56L shl 32) + 0xDC56DC56).toShort().div(var barg2: Byte =
2021-03-11 21:12:59,943 [main:114] - replacement of 1 of type Int is ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)
2021-03-11 21:13:00,196 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:00,197 [main:66] - Compilation checking started
2021-03-11 21:13:01,207 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:01,214 [main:107] - replacing (let({a: Throwable -> check(true)}), Unit?)
2021-03-11 21:13:01,214 [main:50] - replacing let({a: Throwable -> check(true)}) Unit?
2021-03-11 21:13:01,214 [main:54] - Getting value of type Unit?
2021-03-11 21:13:01,481 [main:302] - generating value of type = Unit false depth = 0
2021-03-11 21:13:01,757 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-11 21:13:01,773 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-11 21:13:02,371 [main:302] - generating value of type = Any false depth = 3
2021-03-11 21:13:02,372 [main:95] - GENERATED = print("foggl")
2021-03-11 21:13:02,376 [main:58] - GENERATED VALUE OF TYPE Unit? = print("foggl")
2021-03-11 21:13:02,376 [main:61] - GENERATED IS CALL =true
2021-03-11 21:13:02,425 [main:67] - randomType = Kla0
2021-03-11 21:13:02,688 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-11 21:13:02,700 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-11 21:13:02,951 [main:194] - Type params = []
2021-03-11 21:13:03,204 [main:302] - generating value of type = String true depth = 2
2021-03-11 21:13:03,222 [main:106] - GETTING Unit? from Function0<Unit>
2021-03-11 21:13:03,230 [main:113] - Case = [public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@6f0b9843]]
2021-03-11 21:13:03,230 [main:149] - GENERATING call of type public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@6f0b9843]
2021-03-11 21:13:03,230 [main:117] - GENERATED CALL = ({ check(prope2, { "csrij"})})?.invoke()
2021-03-11 21:13:03,230 [main:114] - replacement of let({a: Throwable -> check(true)}) of type Unit? is print("foggl")
2021-03-11 21:13:03,490 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:13:03,491 [main:66] - Compilation checking started
2021-03-11 21:13:04,159 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.print("foggl")
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope7.prope12 = {
            prope7.prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:04,165 [main:107] - replacing (prope7, Kla7)
2021-03-11 21:13:04,173 [main:50] - replacing prope7 Kla7
2021-03-11 21:13:04,173 [main:54] - Getting value of type Kla7
2021-03-11 21:13:04,435 [main:302] - generating value of type = Kla7 false depth = 0
2021-03-11 21:13:04,448 [main:112] - generating klass Kla7 text = class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-11 21:13:04,449 [main:58] - GENERATED VALUE OF TYPE Kla7 = Kla7()
2021-03-11 21:13:04,449 [main:61] - GENERATED IS CALL =true
2021-03-11 21:13:04,476 [main:67] - randomType = Boolean
2021-03-11 21:13:04,743 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:13:04,769 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:04,806 [main:106] - GETTING Kla7 from Function0<Unit>
2021-03-11 21:13:04,816 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:04,816 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:13:04,852 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:13:04,885 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:13:04,886 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:13:04,917 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:04,917 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:04,946 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:13:04,947 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:13:04,947 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:13:04,948 [main:106] - GETTING Kla7 from Byte
2021-03-11 21:13:04,977 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:13:05,008 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:05,009 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,010 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:13:05,010 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:13:05,011 [main:106] - GETTING Kla7 from Function0<Unit>
2021-03-11 21:13:05,011 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:13:05,012 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:13:05,013 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:05,013 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:05,014 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:05,014 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,015 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:13:05,016 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,016 [main:106] - GETTING Kla7 from Short
2021-03-11 21:13:05,046 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,047 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,047 [main:106] - GETTING Kla7 from Short
2021-03-11 21:13:05,048 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,048 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,049 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:13:05,050 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:13:05,050 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:13:05,051 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:05,052 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:13:05,052 [main:106] - GETTING Kla7 from Int?
2021-03-11 21:13:05,053 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,053 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:13:05,054 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:05,055 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,055 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,056 [main:106] - GETTING Kla7 from Long?
2021-03-11 21:13:05,056 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,057 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,058 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,058 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,059 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,059 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,060 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,061 [main:106] - GETTING Kla7 from Short?
2021-03-11 21:13:05,061 [main:106] - GETTING Kla7 from Byte?
2021-03-11 21:13:05,062 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,062 [main:106] - GETTING Kla7 from Long
2021-03-11 21:13:05,063 [main:106] - GETTING Kla7 from Int
2021-03-11 21:13:05,063 [main:114] - replacement of prope7 of type Kla7 is Kla7()
2021-03-11 21:13:05,337 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:13:05,338 [main:66] - Compilation checking started
2021-03-11 21:13:06,442 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:06,449 [main:107] - replacing (Kla0("OK"), Kla0)
2021-03-11 21:13:06,450 [main:50] - replacing Kla0("OK") Kla0
2021-03-11 21:13:06,450 [main:54] - Getting value of type Kla0
2021-03-11 21:13:06,722 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-11 21:13:06,735 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-11 21:13:07,011 [main:194] - Type params = []
2021-03-11 21:13:07,272 [main:302] - generating value of type = String true depth = 2
2021-03-11 21:13:07,285 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla0("oelcd")
2021-03-11 21:13:07,285 [main:61] - GENERATED IS CALL =true
2021-03-11 21:13:07,311 [main:67] - randomType = Char
2021-03-11 21:13:07,579 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:13:07,610 [main:106] - GETTING Kla0 from Byte?
2021-03-11 21:13:07,640 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,668 [main:106] - GETTING Kla0 from Int?
2021-03-11 21:13:07,698 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,726 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,727 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,727 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,728 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,728 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,729 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,730 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,730 [main:106] - GETTING Kla0 from Byte?
2021-03-11 21:13:07,731 [main:106] - GETTING Kla0 from Byte
2021-03-11 21:13:07,760 [main:106] - GETTING Kla0 from Byte?
2021-03-11 21:13:07,761 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,761 [main:106] - GETTING Kla0 from Short?
2021-03-11 21:13:07,791 [main:106] - GETTING Kla0 from Int?
2021-03-11 21:13:07,792 [main:106] - GETTING Kla0 from Int?
2021-03-11 21:13:07,793 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,793 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,794 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,794 [main:106] - GETTING Kla0 from Int?
2021-03-11 21:13:07,795 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,796 [main:106] - GETTING Kla0 from Long?
2021-03-11 21:13:07,836 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,836 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,837 [main:106] - GETTING Kla0 from Short?
2021-03-11 21:13:07,837 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,838 [main:106] - GETTING Kla0 from Int?
2021-03-11 21:13:07,839 [main:106] - GETTING Kla0 from Byte?
2021-03-11 21:13:07,839 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,840 [main:106] - GETTING Kla0 from Long?
2021-03-11 21:13:07,840 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,841 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,841 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,842 [main:106] - GETTING Kla0 from Short
2021-03-11 21:13:07,872 [main:106] - GETTING Kla0 from Short?
2021-03-11 21:13:07,872 [main:106] - GETTING Kla0 from Long?
2021-03-11 21:13:07,873 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,874 [main:106] - GETTING Kla0 from Short?
2021-03-11 21:13:07,874 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,875 [main:106] - GETTING Kla0 from Long?
2021-03-11 21:13:07,875 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,876 [main:106] - GETTING Kla0 from Short
2021-03-11 21:13:07,877 [main:106] - GETTING Kla0 from Long?
2021-03-11 21:13:07,877 [main:106] - GETTING Kla0 from Long?
2021-03-11 21:13:07,878 [main:106] - GETTING Kla0 from Long?
2021-03-11 21:13:07,878 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,879 [main:106] - GETTING Kla0 from Int
2021-03-11 21:13:07,879 [main:106] - GETTING Kla0 from Int?
2021-03-11 21:13:07,880 [main:106] - GETTING Kla0 from Int?
2021-03-11 21:13:07,881 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,881 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,882 [main:106] - GETTING Kla0 from Function0<Unit>
2021-03-11 21:13:07,891 [main:106] - GETTING Kla0 from Function0<Unit>
2021-03-11 21:13:07,892 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,892 [main:106] - GETTING Kla0 from Long
2021-03-11 21:13:07,892 [main:114] - replacement of Kla0("OK") of type Kla0 is Kla0("oelcd")
2021-03-11 21:13:08,153 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:13:08,153 [main:66] - Compilation checking started
2021-03-11 21:13:09,206 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:09,213 [main:107] - replacing (method, String)
2021-03-11 21:13:09,214 [main:50] - replacing method String
2021-03-11 21:13:09,214 [main:54] - Getting value of type String
2021-03-11 21:13:09,499 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:13:09,513 [main:58] - GENERATED VALUE OF TYPE String = "jmciu"
2021-03-11 21:13:09,513 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:09,540 [main:67] - randomType = Int
2021-03-11 21:13:09,803 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:09,846 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:13:09,846 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:13:09,846 [main:78] - Generated call from random type = (-1821977692).toLong().toString(((larg2 shl 32)).toInt())
2021-03-11 21:13:09,847 [main:106] - GETTING String from Int
2021-03-11 21:13:09,876 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:13:09,876 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:09,876 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:13:09,876 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toChar().plus(var prope0 =
2021-03-11 21:13:09,876 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:13:09,876 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:13:09,876 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:13:09,877 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())
2021-03-11 21:13:09,877 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:13:09,877 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:09,877 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:13:09,877 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toChar().lowercase()
2021-03-11 21:13:09,877 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:13:09,877 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:09,877 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:13:09,877 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toChar().titlecase()
2021-03-11 21:13:09,877 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:13:09,877 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:09,877 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:13:09,877 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toChar().uppercase()
2021-03-11 21:13:09,877 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:09,877 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:13:09,878 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:09,878 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).compareTo(var iarg2: Int =.toString(iarg1)
2021-03-11 21:13:09,878 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:13:09,878 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:13:09,878 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:13:09,878 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toShort().toString(prope1)
2021-03-11 21:13:09,878 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:09,878 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:10,142 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:10,155 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toString(312070047)
2021-03-11 21:13:10,155 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:13:10,155 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:13:10,155 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:13:10,156 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).div((0xB98AB98AL shl 32)).toString(((larg2 shl 32)).toInt().xor(iarg1))
2021-03-11 21:13:10,156 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:13:10,156 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:13:10,156 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:13:10,156 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toLong().toString(var iarg1: Int =
2021-03-11 21:13:10,156 [main:114] - replacement of method of type String is (((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())
2021-03-11 21:13:10,418 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:10,418 [main:66] - Compilation checking started
2021-03-11 21:13:11,486 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..numberOfSuspensions) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:11,493 [main:107] - replacing (prope8, Result<Ty0>)
2021-03-11 21:13:11,493 [main:50] - replacing prope8 Result<Ty0>
2021-03-11 21:13:11,493 [main:54] - Getting value of type Result<Ty0>
2021-03-11 21:13:11,757 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-11 21:13:12,035 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-11 21:13:12,051 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-11 21:13:12,694 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-11 21:13:12,694 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-11 21:13:12,721 [main:67] - randomType = Char
2021-03-11 21:13:13,005 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:13:13,037 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,065 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,094 [main:106] - GETTING Result<Ty0> from Int?
2021-03-11 21:13:13,125 [main:106] - GETTING Result<Ty0> from Int?
2021-03-11 21:13:13,126 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,127 [main:106] - GETTING Result<Ty0> from Byte
2021-03-11 21:13:13,157 [main:106] - GETTING Result<Ty0> from Byte?
2021-03-11 21:13:13,188 [main:106] - GETTING Result<Ty0> from Short?
2021-03-11 21:13:13,219 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,220 [main:106] - GETTING Result<Ty0> from Byte?
2021-03-11 21:13:13,221 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,222 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,223 [main:106] - GETTING Result<Ty0> from Short?
2021-03-11 21:13:13,224 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,226 [main:106] - GETTING Result<Ty0> from Int?
2021-03-11 21:13:13,227 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,228 [main:106] - GETTING Result<Ty0> from Short
2021-03-11 21:13:13,258 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,259 [main:106] - GETTING Result<Ty0> from Long?
2021-03-11 21:13:13,289 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,290 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,291 [main:106] - GETTING Result<Ty0> from Long?
2021-03-11 21:13:13,292 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,294 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,295 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,296 [main:106] - GETTING Result<Ty0> from Short?
2021-03-11 21:13:13,297 [main:106] - GETTING Result<Ty0> from Int?
2021-03-11 21:13:13,298 [main:106] - GETTING Result<Ty0> from Short
2021-03-11 21:13:13,299 [main:106] - GETTING Result<Ty0> from Long?
2021-03-11 21:13:13,300 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,301 [main:106] - GETTING Result<Ty0> from Byte?
2021-03-11 21:13:13,302 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,304 [main:106] - GETTING Result<Ty0> from Long?
2021-03-11 21:13:13,305 [main:106] - GETTING Result<Ty0> from Byte?
2021-03-11 21:13:13,306 [main:106] - GETTING Result<Ty0> from Long?
2021-03-11 21:13:13,307 [main:106] - GETTING Result<Ty0> from Function0<Unit>
2021-03-11 21:13:13,317 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,318 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,319 [main:106] - GETTING Result<Ty0> from Long?
2021-03-11 21:13:13,320 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,321 [main:106] - GETTING Result<Ty0> from Short?
2021-03-11 21:13:13,322 [main:106] - GETTING Result<Ty0> from Long?
2021-03-11 21:13:13,323 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,324 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,325 [main:106] - GETTING Result<Ty0> from Function0<Unit>
2021-03-11 21:13:13,327 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,328 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,329 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,330 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,331 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,332 [main:106] - GETTING Result<Ty0> from Int
2021-03-11 21:13:13,333 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,334 [main:106] - GETTING Result<Ty0> from Int?
2021-03-11 21:13:13,335 [main:106] - GETTING Result<Ty0> from Int?
2021-03-11 21:13:13,336 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,338 [main:106] - GETTING Result<Ty0> from Long
2021-03-11 21:13:13,339 [main:106] - GETTING Result<Ty0> from Int?
2021-03-11 21:13:13,339 [main:111] - Cant find and generate replacement for prope8 type Result<Ty0>
2021-03-11 21:13:13,339 [main:107] - replacing ("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i, String)
2021-03-11 21:13:13,340 [main:50] - replacing "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i String
2021-03-11 21:13:13,340 [main:54] - Getting value of type String
2021-03-11 21:13:13,604 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:13:13,617 [main:58] - GENERATED VALUE OF TYPE String = "idnhb"
2021-03-11 21:13:13,618 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:13,644 [main:67] - randomType = Long
2021-03-11 21:13:13,922 [main:302] - generating value of type = Long true depth = 0
2021-03-11 21:13:13,963 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:13:13,964 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:13:13,964 [main:78] - Generated call from random type = (-4779496481192776873).toChar().uppercase()
2021-03-11 21:13:13,964 [main:106] - GETTING String from Int?
2021-03-11 21:13:13,994 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:13:13,994 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:13:13,994 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:13:13,994 [main:117] - GENERATED CALL = (i1).toByte().toString(((larg2 shl 32)).toInt())
2021-03-11 21:13:13,994 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:13:13,994 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:13:13,995 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:13:14,259 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:14,272 [main:117] - GENERATED CALL = (i1).toLong().toString(1859307593)
2021-03-11 21:13:14,272 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:13:14,272 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:14,272 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:13:14,272 [main:117] - GENERATED CALL = (i1).toChar().lowercase()
2021-03-11 21:13:14,272 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:14,272 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:13:14,272 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:14,273 [main:117] - GENERATED CALL = (i1).compareTo(var iarg1: Int =.toString(prope1)
2021-03-11 21:13:14,273 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:13:14,273 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:13:14,273 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:13:14,273 [main:117] - GENERATED CALL = (i1).toShort().toString(prope1)
2021-03-11 21:13:14,273 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:13:14,273 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@34b3a7c9]
2021-03-11 21:13:14,273 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:13:14,537 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:14,550 [main:117] - GENERATED CALL = (i1).div((larg2 shl 32)).toString(-1506798793)
2021-03-11 21:13:14,550 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:13:14,550 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:14,550 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:13:14,551 [main:117] - GENERATED CALL = (i1).toChar().plus(var prope0 =
2021-03-11 21:13:14,551 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:14,551 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:13:14,551 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:14,551 [main:117] - GENERATED CALL = (i1).and(((larg2 shl 32)).toInt()).toString(iarg1)
2021-03-11 21:13:14,551 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:14,551 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:13:14,551 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:14,551 [main:117] - GENERATED CALL = (i1).toInt().toString(var prope1 =
2021-03-11 21:13:14,551 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:13:14,552 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:14,552 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:13:14,552 [main:117] - GENERATED CALL = (i1).toChar().uppercase()
2021-03-11 21:13:14,552 [main:114] - replacement of "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i of type String is (i1).toShort().toString(prope1)
2021-03-11 21:13:14,815 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:14,815 [main:66] - Compilation checking started
2021-03-11 21:13:15,507 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..numberOfSuspensions) {
            if (prope10 != i) error((i1).toShort().toString(prope1) + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:15,515 [main:107] - replacing (prope5, Continuation<*>)
2021-03-11 21:13:15,515 [main:50] - replacing prope5 Continuation<*>
2021-03-11 21:13:15,515 [main:54] - Getting value of type Continuation<*>
2021-03-11 21:13:15,792 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-11 21:13:16,072 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-11 21:13:16,087 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-11 21:13:17,143 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-11 21:13:17,423 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:17,439 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:18,114 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-11 21:13:18,408 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:18,424 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:19,464 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:19,464 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:19,464 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-11 21:13:19,464 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-11 21:13:19,899 [main:67] - randomType = Function1<Kla1, Long>
2021-03-11 21:13:19,900 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:19,930 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:13:19,959 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:19,988 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:13:20,019 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:13:20,050 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:13:20,051 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:20,052 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,052 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,053 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:20,054 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,055 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,056 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:20,057 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:13:20,058 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:13:20,058 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:13:20,059 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:13:20,092 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:13:20,092 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:13:20,093 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:13:20,094 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,095 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:13:20,096 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:13:20,096 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,097 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:13:20,098 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:20,099 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,100 [main:106] - GETTING Continuation<*> from Function0<Unit>
2021-03-11 21:13:20,109 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,110 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:13:20,110 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,111 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:13:20,112 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:13:20,113 [main:106] - GETTING Continuation<*> from Byte?
2021-03-11 21:13:20,114 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,115 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,115 [main:106] - GETTING Continuation<*> from Byte
2021-03-11 21:13:20,145 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,146 [main:106] - GETTING Continuation<*> from Short
2021-03-11 21:13:20,174 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:20,175 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,176 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,177 [main:106] - GETTING Continuation<*> from Short
2021-03-11 21:13:20,178 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,179 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,179 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:20,180 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,181 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,182 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:13:20,183 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,183 [main:106] - GETTING Continuation<*> from Short?
2021-03-11 21:13:20,184 [main:106] - GETTING Continuation<*> from Long?
2021-03-11 21:13:20,185 [main:106] - GETTING Continuation<*> from Function0<Unit>
2021-03-11 21:13:20,186 [main:106] - GETTING Continuation<*> from Int
2021-03-11 21:13:20,187 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,187 [main:106] - GETTING Continuation<*> from Long
2021-03-11 21:13:20,188 [main:106] - GETTING Continuation<*> from Int?
2021-03-11 21:13:20,188 [main:111] - Cant find and generate replacement for prope5 type Continuation<*>
2021-03-11 21:13:20,188 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-11 21:13:20,189 [main:50] - replacing numberOfSuspensions Int
2021-03-11 21:13:20,189 [main:54] - Getting value of type Int
2021-03-11 21:13:20,469 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:20,481 [main:58] - GENERATED VALUE OF TYPE Int = 1510651235
2021-03-11 21:13:20,482 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:21,162 [main:67] - randomType = Float?
2021-03-11 21:13:21,423 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:13:21,476 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@9e31c85]
2021-03-11 21:13:21,476 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@71628c83]
2021-03-11 21:13:21,743 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:13:21,756 [main:78] - Generated call from random type = (0.840922f)?.toByte().rem(-43)
2021-03-11 21:13:21,756 [main:106] - GETTING Int from Int
2021-03-11 21:13:21,785 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]]
2021-03-11 21:13:21,785 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:13:21,785 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@5b7b8a84]
2021-03-11 21:13:22,046 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:22,059 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toInt().coerceIn((0x00000000L shl 32 shl 1).compareTo(barg1), 1025857722)
2021-03-11 21:13:22,059 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@32dfaf36]]
2021-03-11 21:13:22,059 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:13:22,059 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@32dfaf36]
2021-03-11 21:13:22,060 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toByte().div(var barg2: Byte =
2021-03-11 21:13:22,060 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]]
2021-03-11 21:13:22,060 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:13:22,060 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]
2021-03-11 21:13:22,060 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toInt().unaryMinus()
2021-03-11 21:13:22,060 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]]
2021-03-11 21:13:22,060 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:13:22,060 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@dd17612]
2021-03-11 21:13:22,060 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toInt().countLeadingZeroBits()
2021-03-11 21:13:22,060 [main:113] - Case = [public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]]
2021-03-11 21:13:22,060 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6da05858]
2021-03-11 21:13:22,060 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())
2021-03-11 21:13:22,061 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]]
2021-03-11 21:13:22,061 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:13:22,061 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@377531b4]
2021-03-11 21:13:22,061 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).toShort().div(barg1)
2021-03-11 21:13:22,061 [main:113] - Case = [public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]]
2021-03-11 21:13:22,061 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@74fd6fed]
2021-03-11 21:13:22,329 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:22,342 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).xor(-998093291)
2021-03-11 21:13:22,342 [main:113] - Case = [public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]]
2021-03-11 21:13:22,342 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3c2bc21d]
2021-03-11 21:13:22,342 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).inc()
2021-03-11 21:13:22,343 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]]
2021-03-11 21:13:22,343 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:13:22,603 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:22,616 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@cd0a934]
2021-03-11 21:13:22,617 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).compareTo(1511533835).unaryMinus()
2021-03-11 21:13:22,617 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]]
2021-03-11 21:13:22,617 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:13:22,878 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:22,891 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1d9a7487]
2021-03-11 21:13:22,891 [main:117] - GENERATED CALL = (((larg2 shl 32)).toInt().xor(iarg1)).compareTo(441555260).toInt()
2021-03-11 21:13:22,891 [main:114] - replacement of numberOfSuspensions of type Int is (((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())
2021-03-11 21:13:23,152 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:23,152 [main:66] - Compilation checking started
2021-03-11 21:13:24,376 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:24,386 [main:107] - replacing (prope10++, Int)
2021-03-11 21:13:24,387 [main:50] - replacing prope10++ Int
2021-03-11 21:13:24,387 [main:54] - Getting value of type Int
2021-03-11 21:13:24,703 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:24,717 [main:58] - GENERATED VALUE OF TYPE Int = 444541534
2021-03-11 21:13:24,717 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:26,093 [main:67] - randomType = Function1<UInt?, UInt>
2021-03-11 21:13:26,094 [main:106] - GETTING Int from Long
2021-03-11 21:13:26,123 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@2af3682f]]
2021-03-11 21:13:26,123 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:13:26,123 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@2af3682f]
2021-03-11 21:13:26,386 [main:302] - generating value of type = Char true depth = 0
2021-03-11 21:13:26,400 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toChar().minus('ᆬ')
2021-03-11 21:13:26,400 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]]
2021-03-11 21:13:26,400 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:13:26,400 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@21e64dbc]
2021-03-11 21:13:26,400 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toInt().rem(var barg1: Byte =
2021-03-11 21:13:26,400 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]]
2021-03-11 21:13:26,400 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:13:26,401 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@ba43f59]
2021-03-11 21:13:26,664 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:26,678 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).compareTo(barg1).shr(1505254642)
2021-03-11 21:13:26,678 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]]
2021-03-11 21:13:26,678 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:13:26,678 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2a53d401]
2021-03-11 21:13:26,678 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).compareTo(var barg2: Byte =.unaryPlus()
2021-03-11 21:13:26,678 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]]
2021-03-11 21:13:26,678 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:13:26,678 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:13:26,679 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toLong().compareTo(var barg1: Byte =
2021-03-11 21:13:26,679 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@15466b6c]]
2021-03-11 21:13:26,679 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:13:26,679 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@15466b6c]
2021-03-11 21:13:26,679 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).compareTo(barg1).coerceAtMost(var iarg2: Int =
2021-03-11 21:13:26,679 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]]
2021-03-11 21:13:26,679 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:13:26,679 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@26fcf280]
2021-03-11 21:13:26,679 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toLong().countTrailingZeroBits()
2021-03-11 21:13:26,679 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]]
2021-03-11 21:13:26,680 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:13:26,680 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@4169e884]
2021-03-11 21:13:26,944 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:13:26,957 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toDouble().compareTo(-1)
2021-03-11 21:13:26,957 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]]
2021-03-11 21:13:26,957 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:13:26,957 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a367832]
2021-03-11 21:13:27,222 [main:302] - generating value of type = Byte true depth = 0
2021-03-11 21:13:27,236 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toShort().plus(82)
2021-03-11 21:13:27,236 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60337d73]]
2021-03-11 21:13:27,236 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:13:27,236 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60337d73]
2021-03-11 21:13:27,236 [main:117] - GENERATED CALL = (((larg2 shl 32) shl 32)).toInt().div(var barg2: Byte =
2021-03-11 21:13:27,236 [main:114] - replacement of prope10++ of type Int is (((larg2 shl 32) shl 32)).compareTo(var barg2: Byte =.unaryPlus()
2021-03-11 21:13:27,512 [main:33] - Trying to replace Element(POSTFIX_EXPRESSION) on Element(BINARY_EXPRESSION)
2021-03-11 21:13:27,513 [main:66] - Compilation checking started
2021-03-11 21:13:27,538 [main:71] - Wrong syntax or breaks conditions
2021-03-11 21:13:27,538 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        (((larg2 shl 32) shl 32)).compareTo(var barg2: Byte =.unaryPlus()
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:27,545 [main:107] - replacing (getOrThrow(), Any?)
2021-03-11 21:13:27,556 [main:50] - replacing getOrThrow() Any?
2021-03-11 21:13:27,557 [main:54] - Getting value of type Any?
2021-03-11 21:13:27,831 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:13:27,831 [main:58] - GENERATED VALUE OF TYPE Any? = "bllzs"
2021-03-11 21:13:27,831 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:27,886 [main:67] - randomType = Kla4
2021-03-11 21:13:28,162 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-11 21:13:28,176 [main:112] - generating klass Kla4 text = class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}
2021-03-11 21:13:28,191 [main:78] - Generated call from random type = (Kla4()).prope8
2021-03-11 21:13:28,191 [main:114] - replacement of getOrThrow() of type Any? is (Kla4()).prope8
2021-03-11 21:13:28,464 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:28,465 [main:66] - Compilation checking started
2021-03-11 21:13:29,212 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.(Kla4()).prope8
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:29,220 [main:107] - replacing (prope8, Any?)
2021-03-11 21:13:29,220 [main:50] - replacing prope8 Any?
2021-03-11 21:13:29,220 [main:54] - Getting value of type Any?
2021-03-11 21:13:29,495 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:13:29,496 [main:58] - GENERATED VALUE OF TYPE Any? = "btqpy"
2021-03-11 21:13:29,496 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:31,489 [main:67] - randomType = Triple<UInt?, Char?, Kla3>?
2021-03-11 21:13:31,764 [main:302] - generating value of type = Triple<UInt?, Char?, Kla3> false depth = 0
2021-03-11 21:13:32,055 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: UInt?, second: Char?, third: Kla3): Triple<UInt?, Char?, Kla3> = TODO()
2021-03-11 21:13:32,072 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: UInt?, second: Char?, third: Kla3): Triple<UInt?, Char?, Kla3> = TODO()
2021-03-11 21:13:32,369 [main:302] - generating value of type = UInt true depth = 3
2021-03-11 21:13:32,383 [main:302] - generating value of type = Char true depth = 3
2021-03-11 21:13:32,397 [main:302] - generating value of type = Kla3 false depth = 3
2021-03-11 21:13:32,411 [main:112] - generating klass Kla3 text = open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}
2021-03-11 21:13:32,718 [main:194] - Type params = []
2021-03-11 21:13:32,990 [main:302] - generating value of type = CoroutineContext false depth = 5
2021-03-11 21:13:33,277 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:33,294 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:33,995 [main:302] - generating value of type = Key<*> false depth = 8
2021-03-11 21:13:34,299 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:34,315 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:35,416 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:35,416 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:35,417 [main:95] - GENERATED = Triple<UInt?, Char?, Kla3>(1409546332.toUInt(), '绌', Kla3())
2021-03-11 21:13:35,434 [main:106] - GETTING Any? from Int?
2021-03-11 21:13:35,465 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,493 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,522 [main:106] - GETTING Any? from Function0<Unit>
2021-03-11 21:13:35,530 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,530 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,531 [main:106] - GETTING Any? from Short
2021-03-11 21:13:35,561 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,561 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,562 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,563 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,563 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,564 [main:106] - GETTING Any? from Long?
2021-03-11 21:13:35,596 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,597 [main:106] - GETTING Any? from Int?
2021-03-11 21:13:35,597 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,598 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,599 [main:106] - GETTING Any? from Long?
2021-03-11 21:13:35,599 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,600 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,601 [main:106] - GETTING Any? from Long?
2021-03-11 21:13:35,601 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,602 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,603 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,603 [main:106] - GETTING Any? from Short?
2021-03-11 21:13:35,634 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,635 [main:106] - GETTING Any? from Int?
2021-03-11 21:13:35,636 [main:106] - GETTING Any? from Int?
2021-03-11 21:13:35,637 [main:106] - GETTING Any? from Short
2021-03-11 21:13:35,637 [main:106] - GETTING Any? from Function0<Unit>
2021-03-11 21:13:35,638 [main:106] - GETTING Any? from Short?
2021-03-11 21:13:35,639 [main:106] - GETTING Any? from Short?
2021-03-11 21:13:35,639 [main:106] - GETTING Any? from Short?
2021-03-11 21:13:35,640 [main:106] - GETTING Any? from Byte?
2021-03-11 21:13:35,672 [main:106] - GETTING Any? from Byte
2021-03-11 21:13:35,700 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,701 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,702 [main:106] - GETTING Any? from Long?
2021-03-11 21:13:35,702 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,703 [main:106] - GETTING Any? from Byte?
2021-03-11 21:13:35,704 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,704 [main:106] - GETTING Any? from Int?
2021-03-11 21:13:35,705 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,706 [main:106] - GETTING Any? from Long?
2021-03-11 21:13:35,706 [main:106] - GETTING Any? from Int?
2021-03-11 21:13:35,707 [main:106] - GETTING Any? from Byte?
2021-03-11 21:13:35,708 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,708 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,709 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,710 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,710 [main:106] - GETTING Any? from Int?
2021-03-11 21:13:35,711 [main:106] - GETTING Any? from Byte?
2021-03-11 21:13:35,712 [main:106] - GETTING Any? from Long?
2021-03-11 21:13:35,712 [main:106] - GETTING Any? from Long?
2021-03-11 21:13:35,713 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,713 [main:106] - GETTING Any? from Long
2021-03-11 21:13:35,714 [main:106] - GETTING Any? from Int
2021-03-11 21:13:35,714 [main:114] - replacement of prope8 of type Any? is "btqpy"
2021-03-11 21:13:35,985 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-11 21:13:35,986 [main:66] - Compilation checking started
2021-03-11 21:13:36,726 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this."btqpy" = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (prope10 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:36,737 [main:107] - replacing (prope10 != numberOfSuspensions, Boolean)
2021-03-11 21:13:36,739 [main:50] - replacing prope10 != numberOfSuspensions Boolean
2021-03-11 21:13:36,739 [main:54] - Getting value of type Boolean
2021-03-11 21:13:37,021 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:13:37,035 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:13:37,035 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:37,387 [main:67] - randomType = UInt
2021-03-11 21:13:37,661 [main:302] - generating value of type = UInt true depth = 0
2021-03-11 21:13:37,700 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@5d97932]
2021-03-11 21:13:37,975 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:13:37,975 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@25672ca0]
2021-03-11 21:13:38,249 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:13:38,263 [main:78] - Generated call from random type = (1769940176.toUInt()).equals("ffhwu").or(false)
2021-03-11 21:13:38,264 [main:106] - GETTING Boolean from Int
2021-03-11 21:13:38,293 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]]
2021-03-11 21:13:38,293 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:38,293 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]
2021-03-11 21:13:38,293 [main:117] - GENERATED CALL = ((32)).toChar().isLetter()
2021-03-11 21:13:38,293 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:13:38,293 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:13:38,293 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:13:38,293 [main:117] - GENERATED CALL = ((32)).toDouble().isNaN()
2021-03-11 21:13:38,293 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]]
2021-03-11 21:13:38,293 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:38,293 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55ee47cc]
2021-03-11 21:13:38,294 [main:117] - GENERATED CALL = ((32)).toChar().isLowerCase()
2021-03-11 21:13:38,294 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:13:38,294 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:38,294 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:13:38,294 [main:117] - GENERATED CALL = ((32)).toChar().isWhitespace()
2021-03-11 21:13:38,294 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]]
2021-03-11 21:13:38,294 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:38,294 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@153c8cfb]
2021-03-11 21:13:38,294 [main:117] - GENERATED CALL = ((32)).toChar().isTitleCase()
2021-03-11 21:13:38,294 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:13:38,294 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:13:38,570 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:13:38,583 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:13:38,584 [main:117] - GENERATED CALL = ((32)).div(0.32232171788366126).isFinite()
2021-03-11 21:13:38,584 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]]
2021-03-11 21:13:38,584 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:13:38,584 [main:149] - GENERATING call of type public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@50b0cd7]
2021-03-11 21:13:38,584 [main:117] - GENERATED CALL = ((32)).toFloat().isFinite()
2021-03-11 21:13:38,584 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:13:38,584 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:13:38,584 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:13:38,584 [main:117] - GENERATED CALL = ((32)).toDouble().isInfinite()
2021-03-11 21:13:38,584 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]]
2021-03-11 21:13:38,584 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@494296a4]
2021-03-11 21:13:38,857 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:13:38,871 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@65ad8e5]
2021-03-11 21:13:39,147 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:13:39,147 [main:117] - GENERATED CALL = ((32)).div(0.4439926764557962).equals("ezthi")
2021-03-11 21:13:39,309 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]]
2021-03-11 21:13:39,309 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:13:39,309 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:13:39,588 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:13:39,588 [main:117] - GENERATED CALL = ((32)).toLong().equals("uhina")
2021-03-11 21:13:39,588 [main:114] - replacement of prope10 != numberOfSuspensions of type Boolean is ((32)).toChar().isTitleCase()
2021-03-11 21:13:39,868 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:39,868 [main:66] - Compilation checking started
2021-03-11 21:13:40,955 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:40,966 [main:107] - replacing (prope8.getOrThrow(), Ty0)
2021-03-11 21:13:40,967 [main:50] - replacing prope8.getOrThrow() Ty0
2021-03-11 21:13:40,967 [main:54] - Getting value of type Ty0
2021-03-11 21:13:41,238 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-11 21:13:41,255 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-11 21:13:41,283 [main:67] - randomType = String
2021-03-11 21:13:41,556 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:13:41,587 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,623 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,624 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,624 [main:106] - GETTING Ty0 from Function0<Unit>
2021-03-11 21:13:41,637 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,637 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,638 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,681 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:13:41,722 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,722 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:13:41,751 [main:106] - GETTING Ty0 from Short
2021-03-11 21:13:41,780 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,780 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:13:41,781 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,782 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:13:41,812 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:13:41,813 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:13:41,813 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,814 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,814 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,815 [main:106] - GETTING Ty0 from Function0<Unit>
2021-03-11 21:13:41,815 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:13:41,816 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,817 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,817 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,818 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,818 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,819 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,820 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:13:41,859 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:13:41,860 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:13:41,860 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:13:41,861 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:13:41,862 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,862 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,863 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:13:41,863 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,864 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,865 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,865 [main:106] - GETTING Ty0 from Short
2021-03-11 21:13:41,866 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:13:41,866 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:13:41,867 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:13:41,868 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,868 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,869 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,869 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:13:41,870 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,871 [main:106] - GETTING Ty0 from Byte
2021-03-11 21:13:41,901 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:13:41,901 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,902 [main:106] - GETTING Ty0 from Long
2021-03-11 21:13:41,903 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:13:41,903 [main:106] - GETTING Ty0 from Int
2021-03-11 21:13:41,904 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:13:41,904 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:13:41,905 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:13:41,905 [main:111] - Cant find and generate replacement for prope8.getOrThrow() type Ty0
2021-03-11 21:13:41,905 [main:107] - replacing ("Wrong state-machine generated: wrong number of overall suspensions. Expected ", String)
2021-03-11 21:13:41,906 [main:50] - replacing "Wrong state-machine generated: wrong number of overall suspensions. Expected " String
2021-03-11 21:13:41,906 [main:54] - Getting value of type String
2021-03-11 21:13:42,178 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:13:42,192 [main:58] - GENERATED VALUE OF TYPE String = "kzxrw"
2021-03-11 21:13:42,192 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:42,572 [main:67] - randomType = Kla8
2021-03-11 21:13:42,845 [main:302] - generating value of type = Kla8 false depth = 0
2021-03-11 21:13:42,859 [main:112] - generating klass Kla8 text = object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}
2021-03-11 21:13:42,876 [main:106] - GETTING String from Int?
2021-03-11 21:13:42,906 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:13:42,906 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:13:42,906 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:13:42,906 [main:117] - GENERATED CALL = (i6).toLong().toString((32))
2021-03-11 21:13:42,906 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:13:42,906 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:42,906 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:13:42,906 [main:117] - GENERATED CALL = (i6).toChar().uppercase()
2021-03-11 21:13:42,907 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:13:42,907 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:42,907 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:13:43,179 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:13:43,192 [main:117] - GENERATED CALL = (i6).toChar().plus("iyqjc")
2021-03-11 21:13:43,193 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:13:43,193 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:43,193 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:13:43,193 [main:117] - GENERATED CALL = (i6).toChar().lowercase()
2021-03-11 21:13:43,193 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:43,193 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:13:43,193 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:43,464 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:43,478 [main:117] - GENERATED CALL = (i6).toInt().toString(-1897489112)
2021-03-11 21:13:43,478 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:43,478 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@726986d2]
2021-03-11 21:13:43,478 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:43,759 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:43,773 [main:117] - GENERATED CALL = (i6).and((32)).toString(-1133987649)
2021-03-11 21:13:43,773 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:13:43,773 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@6911641e]
2021-03-11 21:13:44,054 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:13:44,068 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:13:44,068 [main:117] - GENERATED CALL = (i6).compareTo(-1602427915).toString((0x00000000L shl 32 shl 1).compareTo(barg1))
2021-03-11 21:13:44,068 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:13:44,068 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@60a21642]
2021-03-11 21:13:44,068 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:13:44,068 [main:117] - GENERATED CALL = (i6).toChar().titlecase()
2021-03-11 21:13:44,068 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:13:44,068 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7cbfa39d]
2021-03-11 21:13:44,068 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:13:44,069 [main:117] - GENERATED CALL = (i6).toByte().toString(iarg1)
2021-03-11 21:13:44,069 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:13:44,069 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1a9d5a73]
2021-03-11 21:13:44,069 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:13:44,069 [main:117] - GENERATED CALL = (i6).toShort().toString(((larg2 shl 32)).toInt())
2021-03-11 21:13:44,069 [main:114] - replacement of "Wrong state-machine generated: wrong number of overall suspensions. Expected " of type String is (i6).and((32)).toString(-1133987649)
2021-03-11 21:13:44,340 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:44,340 [main:66] - Compilation checking started
2021-03-11 21:13:45,238 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error((i6).and((32)).toString(-1133987649) + numberOfSuspensions + ", got " + prope10)
        if (prope11) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:45,245 [main:107] - replacing (prope5, Continuation<Any>?)
2021-03-11 21:13:45,246 [main:50] - replacing prope5 Continuation<Any>?
2021-03-11 21:13:45,246 [main:54] - Getting value of type Continuation<Any>?
2021-03-11 21:13:45,520 [main:302] - generating value of type = Continuation<Any> false depth = 0
2021-03-11 21:13:45,809 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-11 21:13:45,826 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-11 21:13:46,887 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-11 21:13:47,180 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:47,196 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:47,889 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-11 21:13:48,200 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:48,217 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:49,339 [main:302] - generating value of type = Key<AbstractCoroutineContextElement> false depth = 9
2021-03-11 21:13:49,643 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-11 21:13:49,659 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-11 21:13:50,733 [main:302] - generating value of type = Key<AbstractCoroutineContextElement> false depth = 12
2021-03-11 21:13:51,035 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-11 21:13:51,052 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-11 21:13:52,121 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-11 21:13:52,121 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-11 21:13:52,121 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:13:52,121 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:13:52,121 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-11 21:13:52,122 [main:58] - GENERATED VALUE OF TYPE Continuation<Any>? = 
2021-03-11 21:13:52,500 [main:67] - randomType = UShort?
2021-03-11 21:13:52,795 [main:302] - generating value of type = UShort true depth = 0
2021-03-11 21:13:52,836 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:52,864 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:52,865 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:52,894 [main:106] - GETTING Continuation<Any>? from Long?
2021-03-11 21:13:52,924 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:52,925 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:52,926 [main:106] - GETTING Continuation<Any>? from Short?
2021-03-11 21:13:52,956 [main:106] - GETTING Continuation<Any>? from Byte?
2021-03-11 21:13:52,987 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:52,987 [main:106] - GETTING Continuation<Any>? from Function0<Unit>
2021-03-11 21:13:52,996 [main:106] - GETTING Continuation<Any>? from Long?
2021-03-11 21:13:52,997 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:52,998 [main:106] - GETTING Continuation<Any>? from Long?
2021-03-11 21:13:52,999 [main:106] - GETTING Continuation<Any>? from Long?
2021-03-11 21:13:53,000 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:53,001 [main:106] - GETTING Continuation<Any>? from Byte?
2021-03-11 21:13:53,002 [main:106] - GETTING Continuation<Any>? from Int?
2021-03-11 21:13:53,033 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:53,034 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,035 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:53,036 [main:106] - GETTING Continuation<Any>? from Int?
2021-03-11 21:13:53,037 [main:106] - GETTING Continuation<Any>? from Short?
2021-03-11 21:13:53,038 [main:106] - GETTING Continuation<Any>? from Function0<Unit>
2021-03-11 21:13:53,039 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:53,040 [main:106] - GETTING Continuation<Any>? from Short?
2021-03-11 21:13:53,041 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,042 [main:106] - GETTING Continuation<Any>? from Int?
2021-03-11 21:13:53,042 [main:106] - GETTING Continuation<Any>? from Short?
2021-03-11 21:13:53,043 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,044 [main:106] - GETTING Continuation<Any>? from Byte
2021-03-11 21:13:53,074 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,075 [main:106] - GETTING Continuation<Any>? from Short
2021-03-11 21:13:53,104 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,105 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,106 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,107 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,108 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,109 [main:106] - GETTING Continuation<Any>? from Int?
2021-03-11 21:13:53,110 [main:106] - GETTING Continuation<Any>? from Short
2021-03-11 21:13:53,111 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,112 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,113 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,114 [main:106] - GETTING Continuation<Any>? from Int?
2021-03-11 21:13:53,114 [main:106] - GETTING Continuation<Any>? from Long?
2021-03-11 21:13:53,115 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:53,116 [main:106] - GETTING Continuation<Any>? from Long?
2021-03-11 21:13:53,117 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,118 [main:106] - GETTING Continuation<Any>? from Byte?
2021-03-11 21:13:53,119 [main:106] - GETTING Continuation<Any>? from Int?
2021-03-11 21:13:53,120 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:53,121 [main:106] - GETTING Continuation<Any>? from Byte?
2021-03-11 21:13:53,122 [main:106] - GETTING Continuation<Any>? from Long?
2021-03-11 21:13:53,123 [main:106] - GETTING Continuation<Any>? from Int?
2021-03-11 21:13:53,124 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,125 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,126 [main:106] - GETTING Continuation<Any>? from Int
2021-03-11 21:13:53,127 [main:106] - GETTING Continuation<Any>? from Long
2021-03-11 21:13:53,127 [main:111] - Cant find and generate replacement for prope5 type Continuation<Any>?
2021-03-11 21:13:53,127 [main:107] - replacing (prope11, Boolean)
2021-03-11 21:13:53,127 [main:50] - replacing prope11 Boolean
2021-03-11 21:13:53,127 [main:54] - Getting value of type Boolean
2021-03-11 21:13:53,399 [main:302] - generating value of type = Boolean true depth = 0
2021-03-11 21:13:53,413 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-11 21:13:53,413 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:54,609 [main:67] - randomType = MutableMap<UByte, Kla5<Int?>>
2021-03-11 21:13:54,726 [main:106] - GETTING Boolean from Long
2021-03-11 21:13:54,756 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]]
2021-03-11 21:13:54,756 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:13:54,756 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@1ba0cbc8]
2021-03-11 21:13:54,756 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toDouble().isNaN()
2021-03-11 21:13:54,756 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]]
2021-03-11 21:13:54,756 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:13:54,756 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@63e6efe4]
2021-03-11 21:13:54,756 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toDouble().isFinite()
2021-03-11 21:13:54,756 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]]
2021-03-11 21:13:54,756 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:13:54,756 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b54c736]
2021-03-11 21:13:54,757 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toChar().isWhitespace()
2021-03-11 21:13:54,757 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]]
2021-03-11 21:13:54,757 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:13:54,757 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40ac32ae]
2021-03-11 21:13:54,757 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toChar().isLetter()
2021-03-11 21:13:54,757 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]]
2021-03-11 21:13:54,757 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:13:54,757 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1849ae4a]
2021-03-11 21:13:54,757 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toChar().isISOControl()
2021-03-11 21:13:54,757 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]]
2021-03-11 21:13:54,757 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:13:54,757 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@178ce392]
2021-03-11 21:13:54,757 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toChar().isDigit()
2021-03-11 21:13:54,757 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]]
2021-03-11 21:13:54,757 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@1834b71b]
2021-03-11 21:13:55,031 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:13:55,032 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).equals("tywsc")
2021-03-11 21:13:55,032 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]]
2021-03-11 21:13:55,032 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@286ea80]
2021-03-11 21:13:55,032 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@5c1d85b5]
2021-03-11 21:13:55,032 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toDouble().isInfinite()
2021-03-11 21:13:55,032 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]]
2021-03-11 21:13:55,032 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:13:55,032 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@307cea0a]
2021-03-11 21:13:55,305 [main:302] - generating value of type = Any false depth = 0
2021-03-11 21:13:55,305 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).compareTo(barg1).equals("ttlzi")
2021-03-11 21:13:55,305 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]]
2021-03-11 21:13:55,305 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7c671131]
2021-03-11 21:13:55,305 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@469011df]
2021-03-11 21:13:55,305 [main:117] - GENERATED CALL = ((0x00000000L shl 32 shl 1)).toFloat().isNaN()
2021-03-11 21:13:55,305 [main:114] - replacement of prope11 of type Boolean is ((0x00000000L shl 32 shl 1)).toFloat().isNaN()
2021-03-11 21:13:55,576 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:13:55,576 [main:66] - Compilation checking started
2021-03-11 21:13:56,667 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope12()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:56,675 [main:107] - replacing (prope12, Function0<Unit>)
2021-03-11 21:13:56,676 [main:50] - replacing prope12 Function0<Unit>
2021-03-11 21:13:56,676 [main:54] - Getting value of type Function0<Unit>
2021-03-11 21:13:56,958 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-11 21:13:56,972 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:13:57,260 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:13:57,277 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:13:57,934 [main:302] - generating value of type = Boolean true depth = 4
2021-03-11 21:13:57,948 [main:95] - GENERATED = require(true)
2021-03-11 21:13:57,948 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true)}
2021-03-11 21:13:57,948 [main:61] - GENERATED IS CALL =false
2021-03-11 21:13:57,977 [main:67] - randomType = Short
2021-03-11 21:13:58,258 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:13:58,302 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,330 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:13:58,360 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:13:58,390 [main:106] - GETTING Function0<Unit> from Byte?
2021-03-11 21:13:58,391 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,392 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:13:58,421 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,422 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,423 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:13:58,424 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:13:58,425 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,426 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:13:58,427 [main:106] - GETTING Function0<Unit> from Int
2021-03-11 21:13:58,428 [main:106] - GETTING Function0<Unit> from Short
2021-03-11 21:13:58,458 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:13:58,459 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:13:58,460 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:13:58,461 [main:106] - GETTING Function0<Unit> from Int?
2021-03-11 21:13:58,492 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,493 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:13:58,494 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,495 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,496 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,497 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:13:58,497 [main:106] - GETTING Function0<Unit> from Function0<Unit>
2021-03-11 21:13:58,505 [main:114] - replacement of prope12 of type Function0<Unit> is prope3
2021-03-11 21:13:58,776 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-11 21:13:58,777 [main:66] - Compilation checking started
2021-03-11 21:13:59,860 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:13:59,871 [main:107] - replacing ("OK", String)
2021-03-11 21:13:59,873 [main:50] - replacing "OK" String
2021-03-11 21:13:59,873 [main:54] - Getting value of type String
2021-03-11 21:14:00,151 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:14:00,165 [main:58] - GENERATED VALUE OF TYPE String = "cwwxz"
2021-03-11 21:14:00,165 [main:61] - GENERATED IS CALL =false
2021-03-11 21:14:00,220 [main:67] - randomType = Kla1
2021-03-11 21:14:00,221 [main:106] - GETTING String from Long?
2021-03-11 21:14:00,269 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:14:00,269 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:00,269 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:14:00,269 [main:117] - GENERATED CALL = (l5).toChar().lowercase()
2021-03-11 21:14:00,269 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:14:00,269 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:14:00,269 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:14:00,269 [main:117] - GENERATED CALL = (l5).toInt().toString(((larg2 shl 32)).toInt())
2021-03-11 21:14:00,269 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:14:00,269 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:14:00,270 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:14:00,541 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:00,555 [main:117] - GENERATED CALL = (l5).toByte().toString(2052022874)
2021-03-11 21:14:00,555 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:14:00,555 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:14:00,556 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:14:00,556 [main:117] - GENERATED CALL = (l5).compareTo(var barg2: Byte =.toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1))
2021-03-11 21:14:00,556 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:14:00,556 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:00,556 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:14:00,556 [main:117] - GENERATED CALL = (l5).toChar().plus(var prope0 =
2021-03-11 21:14:00,556 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:14:00,556 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:14:00,556 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:14:00,557 [main:117] - GENERATED CALL = (l5).and(var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56.toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1))
2021-03-11 21:14:00,557 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:14:00,557 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:00,557 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:14:00,557 [main:117] - GENERATED CALL = (l5).toChar().titlecase()
2021-03-11 21:14:00,557 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:14:00,557 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:14:00,557 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:14:00,829 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:00,843 [main:117] - GENERATED CALL = (l5).toShort().toString(955293887)
2021-03-11 21:14:00,843 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:14:00,843 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:00,843 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:14:00,843 [main:117] - GENERATED CALL = (l5).toChar().uppercase()
2021-03-11 21:14:00,843 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:14:00,843 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:14:00,843 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:14:01,116 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:01,130 [main:117] - GENERATED CALL = (l5).toLong().toString(2119110473)
2021-03-11 21:14:01,130 [main:114] - replacement of "OK" of type String is (l5).toChar().lowercase()
2021-03-11 21:14:01,401 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-11 21:14:01,402 [main:66] - Compilation checking started
2021-03-11 21:14:02,129 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != (l5).toChar().lowercase()) return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        prope10 = 0
        prope11 = false
        prope12 = {}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:02,137 [main:107] - replacing ({}, Function0<Unit>)
2021-03-11 21:14:02,145 [main:50] - replacing {} Function0<Unit>
2021-03-11 21:14:02,145 [main:54] - Getting value of type Function0<Unit>
2021-03-11 21:14:02,428 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-11 21:14:02,442 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:14:02,460 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println()}
2021-03-11 21:14:02,460 [main:61] - GENERATED IS CALL =false
2021-03-11 21:14:04,502 [main:67] - randomType = Triple<Kla8, MutableMap<Double, Long>, UByte>
2021-03-11 21:14:04,787 [main:302] - generating value of type = Triple<Kla8, MutableMap<Double, Long>, UByte> false depth = 0
2021-03-11 21:14:05,089 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Kla8, second: MutableMap<Double, Long>, third: UByte): Triple<Kla8, MutableMap<Double, Long>, UByte> = TODO()
2021-03-11 21:14:05,107 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Kla8, second: MutableMap<Double, Long>, third: UByte): Triple<Kla8, MutableMap<Double, Long>, UByte> = TODO()
2021-03-11 21:14:05,557 [main:302] - generating value of type = Kla8 false depth = 3
2021-03-11 21:14:05,572 [main:112] - generating klass Kla8 text = object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}
2021-03-11 21:14:05,572 [main:302] - generating value of type = MutableMap<Double, Long> false depth = 3
2021-03-11 21:14:05,871 [main:43] - GENERATING CALL OF fun <K, V> mutableMapOf(pairs: Pair<Double, Long>): MutableMap<Double, Long> = TODO()
2021-03-11 21:14:05,888 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> mutableMapOf(pairs: Pair<Double, Long>): MutableMap<Double, Long> = TODO()
2021-03-11 21:14:06,194 [main:302] - generating value of type = Pair<Double, Long> false depth = 6
2021-03-11 21:14:06,496 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Double, second: Long): Pair<Double, Long> = TODO()
2021-03-11 21:14:06,514 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Double, second: Long): Pair<Double, Long> = TODO()
2021-03-11 21:14:06,818 [main:302] - generating value of type = Double true depth = 9
2021-03-11 21:14:06,833 [main:302] - generating value of type = Long true depth = 9
2021-03-11 21:14:06,847 [main:95] - GENERATED = Pair<Double, Long>(0.13035214266305484, 1571650270051364696)
2021-03-11 21:14:06,848 [main:95] - GENERATED = mutableMapOf<Double, Long>(Pair<Double, Long>(0.13035214266305484, 1571650270051364696))
2021-03-11 21:14:06,848 [main:302] - generating value of type = UByte true depth = 3
2021-03-11 21:14:06,862 [main:95] - GENERATED = Triple<Kla8, MutableMap<Double, Long>, UByte>(Kla8, mutableMapOf<Double, Long>(Pair<Double, Long>(0.13035214266305484, 1571650270051364696)), 108.toUByte())
2021-03-11 21:14:06,881 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:14:06,913 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:14:06,942 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:14:06,943 [main:106] - GETTING Function0<Unit> from Long?
2021-03-11 21:14:06,944 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:14:06,945 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:14:06,946 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:14:06,947 [main:106] - GETTING Function0<Unit> from Long
2021-03-11 21:14:06,947 [main:106] - GETTING Function0<Unit> from Function0<Unit>
2021-03-11 21:14:06,955 [main:114] - replacement of {} of type Function0<Unit> is { check(prope2, { "csrij"})}
2021-03-11 21:14:07,237 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-11 21:14:07,238 [main:66] - Compilation checking started
2021-03-11 21:14:08,339 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:08,347 [main:107] - replacing (getOrThrow(), Ty0)
2021-03-11 21:14:08,355 [main:50] - replacing getOrThrow() Ty0
2021-03-11 21:14:08,355 [main:54] - Getting value of type Ty0
2021-03-11 21:14:08,673 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-11 21:14:08,691 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-11 21:14:09,173 [main:67] - randomType = Kla4?
2021-03-11 21:14:09,490 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-11 21:14:09,506 [main:112] - generating klass Kla4 text = class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}
2021-03-11 21:14:09,523 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,554 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:14:09,591 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:14:09,625 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:14:09,625 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,660 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:14:09,660 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,661 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,661 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,662 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,663 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:14:09,663 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:14:09,664 [main:106] - GETTING Ty0 from Function0<Unit>
2021-03-11 21:14:09,676 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:14:09,709 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,709 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:14:09,710 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,710 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,711 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:14:09,712 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,712 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,713 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,713 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:14:09,714 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:14:09,715 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:14:09,747 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,747 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,748 [main:106] - GETTING Ty0 from Function0<Unit>
2021-03-11 21:14:09,749 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:14:09,749 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,750 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,750 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,751 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,751 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,752 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:14:09,753 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,753 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,754 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:14:09,754 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,755 [main:106] - GETTING Ty0 from Short?
2021-03-11 21:14:09,755 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,756 [main:106] - GETTING Ty0 from Short
2021-03-11 21:14:09,786 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,787 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,788 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,788 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:14:09,789 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,790 [main:106] - GETTING Ty0 from Int
2021-03-11 21:14:09,790 [main:106] - GETTING Ty0 from Byte
2021-03-11 21:14:09,820 [main:106] - GETTING Ty0 from Short
2021-03-11 21:14:09,821 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,821 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:14:09,822 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:14:09,823 [main:106] - GETTING Ty0 from Byte?
2021-03-11 21:14:09,823 [main:106] - GETTING Ty0 from Long?
2021-03-11 21:14:09,824 [main:106] - GETTING Ty0 from Long
2021-03-11 21:14:09,824 [main:106] - GETTING Ty0 from Int?
2021-03-11 21:14:09,824 [main:111] - Cant find and generate replacement for getOrThrow() type Ty0
2021-03-11 21:14:09,824 [main:107] - replacing (fu8().s, String)
2021-03-11 21:14:09,832 [main:50] - replacing fu8().s String
2021-03-11 21:14:09,832 [main:54] - Getting value of type String
2021-03-11 21:14:10,142 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:14:10,157 [main:58] - GENERATED VALUE OF TYPE String = "dmqqs"
2021-03-11 21:14:10,158 [main:61] - GENERATED IS CALL =false
2021-03-11 21:14:11,031 [main:67] - randomType = LinkedHashSet<Kla3?>
2021-03-11 21:14:11,335 [main:302] - generating value of type = LinkedHashSet<Kla3?> false depth = 0
2021-03-11 21:14:11,659 [main:43] - GENERATING CALL OF fun <E> LinkedHashSet(elements: kotlin.collections.Collection<Kla3?>): LinkedHashSet<Kla3?> = TODO()
2021-03-11 21:14:11,679 [main:61] - WITHOUT TYPE PARAMS = fun <E> LinkedHashSet(elements: kotlin.collections.Collection<Kla3?>): LinkedHashSet<Kla3?> = TODO()
2021-03-11 21:14:12,493 [main:302] - generating value of type = Collection<Kla3?> false depth = 3
2021-03-11 21:14:12,818 [main:43] - GENERATING CALL OF fun <T> setOf(elements: Kla3?): Collection<Kla3?> = TODO()
2021-03-11 21:14:12,837 [main:61] - WITHOUT TYPE PARAMS = fun <T> setOf(elements: Kla3?): Collection<Kla3?> = TODO()
2021-03-11 21:14:13,167 [main:302] - generating value of type = Kla3 false depth = 6
2021-03-11 21:14:13,183 [main:112] - generating klass Kla3 text = open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}
2021-03-11 21:14:13,486 [main:194] - Type params = []
2021-03-11 21:14:13,786 [main:302] - generating value of type = CoroutineContext false depth = 8
2021-03-11 21:14:14,105 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:14:14,124 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:14:14,898 [main:302] - generating value of type = Key<*> false depth = 11
2021-03-11 21:14:15,235 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:14:15,254 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:14:16,456 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 14
2021-03-11 21:14:16,851 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-11 21:14:16,870 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-11 21:14:18,070 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-11 21:14:18,070 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-11 21:14:18,070 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-11 21:14:18,071 [main:95] - GENERATED = setOf<Kla3?>(Kla3())
2021-03-11 21:14:18,071 [main:95] - GENERATED = LinkedHashSet<Kla3?>(setOf<Kla3?>(Kla3()))
2021-03-11 21:14:18,194 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.LinkedHashSet[DeserializedSimpleFunctionDescriptor@6198ad1e]
2021-03-11 21:14:18,194 [main:149] - GENERATING call of type public fun <T> kotlin.Array<out T>.joinToString(separator: kotlin.CharSequence = ..., prefix: kotlin.CharSequence = ..., postfix: kotlin.CharSequence = ..., limit: kotlin.Int = ..., truncated: kotlin.CharSequence = ..., transform: ((T) -> kotlin.CharSequence)? = ...): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@91115f9]
2021-03-11 21:14:18,499 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:14:18,822 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:14:19,142 [main:43] - GENERATING CALL OF fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-11 21:14:19,161 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-11 21:14:19,889 [main:302] - generating value of type = CharSequence false depth = 3
2021-03-11 21:14:20,217 [main:43] - GENERATING CALL OF fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-11 21:14:20,236 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-11 21:14:21,010 [main:302] - generating value of type = Int true depth = 6
2021-03-11 21:14:21,026 [main:95] - GENERATED = StringBuilder(1036465125)
2021-03-11 21:14:21,026 [main:95] - GENERATED = StringBuilder(StringBuilder(1036465125))
2021-03-11 21:14:21,329 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:14:21,651 [main:43] - GENERATING CALL OF fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-11 21:14:21,670 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-11 21:14:22,396 [main:302] - generating value of type = Int true depth = 3
2021-03-11 21:14:22,412 [main:95] - GENERATED = StringBuilder(-1782712836)
2021-03-11 21:14:22,730 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:23,073 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-11 21:14:23,403 [main:302] - generating value of type = Function1<T, CharSequence> false depth = 0
2021-03-11 21:14:23,419 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-11 21:14:23,438 [main:78] - Generated call from random type = (LinkedHashSet<Kla3?>(setOf<Kla3?>(Kla3()))).toArray().joinToString("momwf", StringBuilder(StringBuilder(1036465125)), StringBuilder(-1782712836), -120544684, "rshol", {a: T -> "fpcac"})
2021-03-11 21:14:23,439 [main:106] - GETTING String from Long
2021-03-11 21:14:23,471 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:14:23,472 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:23,472 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:14:23,472 [main:117] - GENERATED CALL = ((larg2 shl 32)).toChar().lowercase()
2021-03-11 21:14:23,472 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:14:23,472 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:14:23,472 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:14:23,788 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:23,804 [main:117] - GENERATED CALL = ((larg2 shl 32)).toShort().toString(-1787484792)
2021-03-11 21:14:23,805 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:14:23,805 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:14:23,805 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:14:23,805 [main:117] - GENERATED CALL = ((larg2 shl 32)).toInt().toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1))
2021-03-11 21:14:23,805 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:14:23,805 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:14:23,805 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:14:24,112 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:24,129 [main:117] - GENERATED CALL = ((larg2 shl 32)).toByte().toString(470056919)
2021-03-11 21:14:24,129 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:14:24,129 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:14:24,129 [main:117] - GENERATED CALL = ((larg2 shl 32)).toString((0x00000000L shl 32 shl 1).compareTo(barg1))
2021-03-11 21:14:24,129 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:14:24,130 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:14:24,130 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:14:24,437 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:24,453 [main:117] - GENERATED CALL = ((larg2 shl 32)).compareTo(var barg1: Byte =.toString(11041693)
2021-03-11 21:14:24,453 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:14:24,453 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:14:24,453 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:14:24,453 [main:117] - GENERATED CALL = ((larg2 shl 32)).toLong().toString(var iarg1: Int =
2021-03-11 21:14:24,453 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:14:24,453 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:24,453 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:14:24,453 [main:117] - GENERATED CALL = ((larg2 shl 32)).toChar().uppercase()
2021-03-11 21:14:24,453 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:14:24,454 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:24,454 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:14:24,454 [main:117] - GENERATED CALL = ((larg2 shl 32)).toChar().titlecase()
2021-03-11 21:14:24,454 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:14:24,454 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:24,454 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:14:24,454 [main:117] - GENERATED CALL = ((larg2 shl 32)).toChar().plus(var prope0 =
2021-03-11 21:14:24,454 [main:114] - replacement of fu8().s of type String is ((larg2 shl 32)).toLong().toString(var iarg1: Int =
2021-03-11 21:14:24,758 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(BINARY_EXPRESSION)
2021-03-11 21:14:24,759 [main:66] - Compilation checking started
2021-03-11 21:14:24,786 [main:71] - Wrong syntax or breaks conditions
2021-03-11 21:14:24,786 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return ((larg2 shl 32)).toLong().toString(var iarg1: Int =
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:24,794 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-11 21:14:24,794 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-11 21:14:24,794 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-11 21:14:25,110 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-11 21:14:25,129 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-11 21:14:25,161 [main:67] - randomType = Short
2021-03-11 21:14:25,465 [main:302] - generating value of type = Short true depth = 0
2021-03-11 21:14:25,512 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,541 [main:106] - GETTING EmptyCoroutineContext from Short?
2021-03-11 21:14:25,574 [main:106] - GETTING EmptyCoroutineContext from Short?
2021-03-11 21:14:25,575 [main:106] - GETTING EmptyCoroutineContext from Function0<Unit>
2021-03-11 21:14:25,584 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,613 [main:106] - GETTING EmptyCoroutineContext from Byte?
2021-03-11 21:14:25,645 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,645 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,646 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,647 [main:106] - GETTING EmptyCoroutineContext from Int?
2021-03-11 21:14:25,679 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,680 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,680 [main:106] - GETTING EmptyCoroutineContext from Byte?
2021-03-11 21:14:25,681 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,681 [main:106] - GETTING EmptyCoroutineContext from Byte?
2021-03-11 21:14:25,682 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,683 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,683 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,684 [main:106] - GETTING EmptyCoroutineContext from Long?
2021-03-11 21:14:25,715 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,716 [main:106] - GETTING EmptyCoroutineContext from Byte?
2021-03-11 21:14:25,716 [main:106] - GETTING EmptyCoroutineContext from Short?
2021-03-11 21:14:25,717 [main:106] - GETTING EmptyCoroutineContext from Int?
2021-03-11 21:14:25,718 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,718 [main:106] - GETTING EmptyCoroutineContext from Long?
2021-03-11 21:14:25,719 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,719 [main:106] - GETTING EmptyCoroutineContext from Long?
2021-03-11 21:14:25,720 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,721 [main:106] - GETTING EmptyCoroutineContext from Long?
2021-03-11 21:14:25,721 [main:106] - GETTING EmptyCoroutineContext from Int?
2021-03-11 21:14:25,722 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,723 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,723 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,724 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,724 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,725 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,726 [main:106] - GETTING EmptyCoroutineContext from Int?
2021-03-11 21:14:25,726 [main:106] - GETTING EmptyCoroutineContext from Short?
2021-03-11 21:14:25,727 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,727 [main:106] - GETTING EmptyCoroutineContext from Short
2021-03-11 21:14:25,759 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,759 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,760 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,761 [main:106] - GETTING EmptyCoroutineContext from Int?
2021-03-11 21:14:25,761 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,762 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,762 [main:106] - GETTING EmptyCoroutineContext from Byte
2021-03-11 21:14:25,793 [main:106] - GETTING EmptyCoroutineContext from Int?
2021-03-11 21:14:25,794 [main:106] - GETTING EmptyCoroutineContext from Long?
2021-03-11 21:14:25,795 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,795 [main:106] - GETTING EmptyCoroutineContext from Long?
2021-03-11 21:14:25,796 [main:106] - GETTING EmptyCoroutineContext from Function0<Unit>
2021-03-11 21:14:25,797 [main:106] - GETTING EmptyCoroutineContext from Short
2021-03-11 21:14:25,797 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-11 21:14:25,798 [main:106] - GETTING EmptyCoroutineContext from Int?
2021-03-11 21:14:25,799 [main:106] - GETTING EmptyCoroutineContext from Long
2021-03-11 21:14:25,799 [main:106] - GETTING EmptyCoroutineContext from Long?
2021-03-11 21:14:25,799 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-11 21:14:25,799 [main:107] - replacing ({
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
}, Function1<Continuation<Ty0>, Unit>)
2021-03-11 21:14:25,799 [main:50] - replacing {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
} Function1<Continuation<Ty0>, Unit>
2021-03-11 21:14:25,799 [main:54] - Getting value of type Function1<Continuation<Ty0>, Unit>
2021-03-11 21:14:26,102 [main:302] - generating value of type = Function1<Continuation<Ty0>, Unit> false depth = 0
2021-03-11 21:14:26,118 [main:302] - generating value of type = Unit false depth = 1
2021-03-11 21:14:26,436 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:14:26,455 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:14:27,596 [main:302] - generating value of type = Boolean true depth = 4
2021-03-11 21:14:27,612 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-11 21:14:27,627 [main:302] - generating value of type = Any false depth = 5
2021-03-11 21:14:27,628 [main:95] - GENERATED = check(true, { "umyph"})
2021-03-11 21:14:27,628 [main:58] - GENERATED VALUE OF TYPE Function1<Continuation<Ty0>, Unit> = {a: Continuation<Ty0> -> check(true, { "umyph"})}
2021-03-11 21:14:27,628 [main:61] - GENERATED IS CALL =false
2021-03-11 21:14:28,020 [main:67] - randomType = Double
2021-03-11 21:14:28,323 [main:302] - generating value of type = Double true depth = 0
2021-03-11 21:14:28,369 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,399 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:14:28,431 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:14:28,463 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,465 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,466 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short
2021-03-11 21:14:28,498 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,528 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,529 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,531 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,532 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,534 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,535 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:14:28,568 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:14:28,569 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,571 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:14:28,617 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:14:28,618 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:14:28,619 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:14:28,621 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,624 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:14:28,625 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,627 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,628 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,630 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,631 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:14:28,632 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,634 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:14:28,636 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,638 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,640 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,641 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:14:28,643 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:14:28,644 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,645 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:14:28,647 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:14:28,648 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,650 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:14:28,653 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,654 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,656 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long?
2021-03-11 21:14:28,657 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:14:28,658 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Function0<Unit>
2021-03-11 21:14:28,670 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,672 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,673 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:14:28,674 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,676 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int
2021-03-11 21:14:28,677 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short?
2021-03-11 21:14:28,680 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte
2021-03-11 21:14:28,715 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,716 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,718 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Short
2021-03-11 21:14:28,719 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Long
2021-03-11 21:14:28,722 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Int?
2021-03-11 21:14:28,724 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Function0<Unit>
2021-03-11 21:14:28,725 [main:106] - GETTING Function1<Continuation<Ty0>, Unit> from Byte?
2021-03-11 21:14:28,725 [main:114] - replacement of {
    @Suppress("UNCHECKED_CAST")
    prope5 = it as Continuation<Any>
} of type Function1<Continuation<Ty0>, Unit> is {a: Continuation<Ty0> -> check(true, { "umyph"})}
2021-03-11 21:14:29,047 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-11 21:14:29,047 [main:66] - Compilation checking started
2021-03-11 21:14:30,300 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {a: Continuation<Ty0> -> check(true, { "umyph"})}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.exceptionOrNull()?.let({a: Throwable -> check(true)})
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:30,310 [main:107] - replacing (prope8.exceptionOrNull()?.let({a: Throwable -> check(true)}), Unit?)
2021-03-11 21:14:30,310 [main:50] - replacing prope8.exceptionOrNull()?.let({a: Throwable -> check(true)}) Unit?
2021-03-11 21:14:30,310 [main:54] - Getting value of type Unit?
2021-03-11 21:14:30,629 [main:302] - generating value of type = Unit false depth = 0
2021-03-11 21:14:30,954 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:14:30,973 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-11 21:14:31,712 [main:302] - generating value of type = Boolean true depth = 3
2021-03-11 21:14:31,729 [main:95] - GENERATED = check(true)
2021-03-11 21:14:31,729 [main:58] - GENERATED VALUE OF TYPE Unit? = check(true)
2021-03-11 21:14:31,729 [main:61] - GENERATED IS CALL =true
2021-03-11 21:14:31,793 [main:67] - randomType = Kla2
2021-03-11 21:14:32,108 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-11 21:14:32,126 [main:112] - generating klass Kla2 text = class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}
2021-03-11 21:14:32,430 [main:194] - Type params = []
2021-03-11 21:14:32,743 [main:106] - GETTING Unit? from Long?
2021-03-11 21:14:32,785 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:32,815 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:32,816 [main:106] - GETTING Unit? from Int?
2021-03-11 21:14:32,851 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:32,852 [main:106] - GETTING Unit? from Long?
2021-03-11 21:14:32,853 [main:106] - GETTING Unit? from Long?
2021-03-11 21:14:32,853 [main:106] - GETTING Unit? from Int
2021-03-11 21:14:32,888 [main:106] - GETTING Unit? from Int?
2021-03-11 21:14:32,889 [main:106] - GETTING Unit? from Int?
2021-03-11 21:14:32,890 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:32,891 [main:106] - GETTING Unit? from Byte?
2021-03-11 21:14:32,926 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:32,927 [main:106] - GETTING Unit? from Function0<Unit>
2021-03-11 21:14:32,937 [main:113] - Case = [public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@6f0b9843]]
2021-03-11 21:14:32,937 [main:149] - GENERATING call of type public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@6f0b9843]
2021-03-11 21:14:32,937 [main:117] - GENERATED CALL = ({ check(prope2, { "csrij"})})?.invoke()
2021-03-11 21:14:32,937 [main:114] - replacement of prope8.exceptionOrNull()?.let({a: Throwable -> check(true)}) of type Unit? is ({ check(prope2, { "csrij"})})?.invoke()
2021-03-11 21:14:33,263 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-11 21:14:33,264 [main:66] - Compilation checking started
2021-03-11 21:14:34,458 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {a: Continuation<Ty0> -> check(true, { "umyph"})}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
({ check(prope2, { "csrij"})})?.invoke()
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:34,466 [main:107] - replacing ("OK", String)
2021-03-11 21:14:34,467 [main:50] - replacing "OK" String
2021-03-11 21:14:34,467 [main:54] - Getting value of type String
2021-03-11 21:14:34,778 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:14:34,794 [main:58] - GENERATED VALUE OF TYPE String = "ozlvw"
2021-03-11 21:14:34,794 [main:61] - GENERATED IS CALL =false
2021-03-11 21:14:37,655 [main:67] - randomType = Kla5<HashMap<MutableMap<UInt, Long>, Map<Long, Short>>>?
2021-03-11 21:14:37,959 [main:302] - generating value of type = Kla5<HashMap<MutableMap<UInt, Long>, Map<Long, Short>>> false depth = 0
2021-03-11 21:14:37,975 [main:112] - generating klass Kla5 text = abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-11 21:14:39,599 [main:302] - generating value of type = Kla8 false depth = 2
2021-03-11 21:14:39,615 [main:112] - generating klass Kla8 text = object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}
2021-03-11 21:14:39,638 [main:106] - GETTING String from Long?
2021-03-11 21:14:39,669 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]]
2021-03-11 21:14:39,669 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@66e1d1a1]
2021-03-11 21:14:39,669 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7446358a]
2021-03-11 21:14:39,669 [main:117] - GENERATED CALL = (l5).toShort().toString((32))
2021-03-11 21:14:39,669 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]]
2021-03-11 21:14:39,669 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:39,669 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7932971]
2021-03-11 21:14:39,669 [main:117] - GENERATED CALL = (l5).toChar().titlecase()
2021-03-11 21:14:39,670 [main:113] - Case = [public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:14:39,670 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Long): kotlin.Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@413d8c78]
2021-03-11 21:14:39,670 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:14:39,670 [main:117] - GENERATED CALL = (l5).and(0xB98AB98AL shl 32 shl iarg1).toString(prope1)
2021-03-11 21:14:39,670 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]]
2021-03-11 21:14:39,670 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:39,670 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5552709]
2021-03-11 21:14:39,978 [main:302] - generating value of type = String true depth = 0
2021-03-11 21:14:39,994 [main:117] - GENERATED CALL = (l5).toChar().plus("smaoh")
2021-03-11 21:14:39,994 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]]
2021-03-11 21:14:39,994 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@53d458db]
2021-03-11 21:14:39,994 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bb967f]
2021-03-11 21:14:39,994 [main:117] - GENERATED CALL = (l5).toLong().toString(var iarg1: Int =
2021-03-11 21:14:39,995 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]]
2021-03-11 21:14:39,995 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:39,995 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77c2231d]
2021-03-11 21:14:39,995 [main:117] - GENERATED CALL = (l5).toChar().lowercase()
2021-03-11 21:14:39,995 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:14:39,995 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@6e2157f2]
2021-03-11 21:14:39,995 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:14:39,995 [main:117] - GENERATED CALL = (l5).toInt().toString((32))
2021-03-11 21:14:39,995 [main:113] - Case = [public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]]
2021-03-11 21:14:39,995 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@726e4878]
2021-03-11 21:14:39,995 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@11cb8dd6]
2021-03-11 21:14:40,296 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:40,312 [main:117] - GENERATED CALL = (l5).compareTo(var barg1: Byte =.toString(906537373)
2021-03-11 21:14:40,312 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]]
2021-03-11 21:14:40,312 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@38c55d27]
2021-03-11 21:14:40,312 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2e5992e5]
2021-03-11 21:14:40,313 [main:117] - GENERATED CALL = (l5).toChar().uppercase()
2021-03-11 21:14:40,313 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]]
2021-03-11 21:14:40,313 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@71e4ec42]
2021-03-11 21:14:40,313 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@fd69ce]
2021-03-11 21:14:40,623 [main:302] - generating value of type = Int true depth = 0
2021-03-11 21:14:40,638 [main:117] - GENERATED CALL = (l5).toByte().toString(-1900793922)
2021-03-11 21:14:40,639 [main:114] - replacement of "OK" of type String is (l5).toLong().toString(var iarg1: Int =
2021-03-11 21:14:40,937 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(BINARY_EXPRESSION)
2021-03-11 21:14:40,938 [main:66] - Compilation checking started
2021-03-11 21:14:40,964 [main:71] - Wrong syntax or breaks conditions
2021-03-11 21:14:40,964 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {a: Continuation<Ty0> -> check(true, { "umyph"})}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != (l5).toLong().toString(var iarg1: Int =) return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
({ check(prope2, { "csrij"})})?.invoke()
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:40,984 [main:107] - replacing ({ it?.methodName?.startsWith(method) == true }, Function0<Boolean>)
2021-03-11 21:14:40,985 [main:50] - replacing { it?.methodName?.startsWith(method) == true } Function0<Boolean>
2021-03-11 21:14:40,985 [main:54] - Getting value of type Function0<Boolean>
2021-03-11 21:14:41,289 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-11 21:14:41,305 [main:302] - generating value of type = Boolean true depth = 1
2021-03-11 21:14:41,321 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { false}
2021-03-11 21:14:41,321 [main:61] - GENERATED IS CALL =false
2021-03-11 21:14:41,354 [main:67] - randomType = Float
2021-03-11 21:14:41,657 [main:302] - generating value of type = Float true depth = 0
2021-03-11 21:14:41,704 [main:106] - GETTING Function0<Boolean> from Int?
2021-03-11 21:14:41,737 [main:106] - GETTING Function0<Boolean> from Long?
2021-03-11 21:14:41,768 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,797 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:41,827 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:41,828 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,829 [main:106] - GETTING Function0<Boolean> from Short?
2021-03-11 21:14:41,868 [main:106] - GETTING Function0<Boolean> from Byte?
2021-03-11 21:14:41,900 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,901 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,902 [main:106] - GETTING Function0<Boolean> from Long?
2021-03-11 21:14:41,903 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,904 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,905 [main:106] - GETTING Function0<Boolean> from Short
2021-03-11 21:14:41,936 [main:106] - GETTING Function0<Boolean> from Short?
2021-03-11 21:14:41,937 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,938 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:41,939 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,940 [main:106] - GETTING Function0<Boolean> from Int?
2021-03-11 21:14:41,941 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,942 [main:106] - GETTING Function0<Boolean> from Long?
2021-03-11 21:14:41,943 [main:106] - GETTING Function0<Boolean> from Long?
2021-03-11 21:14:41,944 [main:106] - GETTING Function0<Boolean> from Byte?
2021-03-11 21:14:41,945 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:41,946 [main:106] - GETTING Function0<Boolean> from Long?
2021-03-11 21:14:41,947 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,948 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,948 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,949 [main:106] - GETTING Function0<Boolean> from Int?
2021-03-11 21:14:41,950 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,951 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,952 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,953 [main:106] - GETTING Function0<Boolean> from Byte
2021-03-11 21:14:41,994 [main:106] - GETTING Function0<Boolean> from Short
2021-03-11 21:14:41,995 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:41,996 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,997 [main:106] - GETTING Function0<Boolean> from Int?
2021-03-11 21:14:41,998 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:41,999 [main:106] - GETTING Function0<Boolean> from Short?
2021-03-11 21:14:42,000 [main:106] - GETTING Function0<Boolean> from Byte?
2021-03-11 21:14:42,001 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:42,002 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:42,003 [main:106] - GETTING Function0<Boolean> from Function0<Unit>
2021-03-11 21:14:42,013 [main:106] - GETTING Function0<Boolean> from Long?
2021-03-11 21:14:42,014 [main:106] - GETTING Function0<Boolean> from Long?
2021-03-11 21:14:42,015 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:42,016 [main:106] - GETTING Function0<Boolean> from Short?
2021-03-11 21:14:42,017 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:42,018 [main:106] - GETTING Function0<Boolean> from Int?
2021-03-11 21:14:42,019 [main:106] - GETTING Function0<Boolean> from Int
2021-03-11 21:14:42,020 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:42,021 [main:106] - GETTING Function0<Boolean> from Function0<Unit>
2021-03-11 21:14:42,022 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:42,023 [main:106] - GETTING Function0<Boolean> from Long
2021-03-11 21:14:42,024 [main:106] - GETTING Function0<Boolean> from Int?
2021-03-11 21:14:42,025 [main:106] - GETTING Function0<Boolean> from Byte?
2021-03-11 21:14:42,025 [main:106] - GETTING Function0<Boolean> from Int?
2021-03-11 21:14:42,025 [main:114] - replacement of { it?.methodName?.startsWith(method) == true } of type Function0<Boolean> is { false}
2021-03-11 21:14:42,324 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-11 21:14:42,325 [main:66] - Compilation checking started
2021-03-11 21:14:43,505 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {a: Continuation<Ty0> -> check(true, { "umyph"})}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
({ check(prope2, { "csrij"})})?.invoke()
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { false} ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:43,514 [main:107] - replacing (resume(Kla0("oelcd")), Unit?)
2021-03-11 21:14:43,514 [main:50] - replacing resume(Kla0("oelcd")) Unit?
2021-03-11 21:14:43,514 [main:54] - Getting value of type Unit?
2021-03-11 21:14:43,828 [main:302] - generating value of type = Unit false depth = 0
2021-03-11 21:14:44,147 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:14:44,166 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:14:44,944 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 3
2021-03-11 21:14:44,960 [main:302] - generating value of type = Unit false depth = 4
2021-03-11 21:14:45,286 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:14:45,304 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-11 21:14:46,048 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 7
2021-03-11 21:14:46,063 [main:302] - generating value of type = Unit false depth = 8
2021-03-11 21:14:46,383 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:14:46,402 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-11 21:14:47,547 [main:302] - generating value of type = Boolean true depth = 11
2021-03-11 21:14:47,563 [main:302] - generating value of type = Function0<Any> false depth = 11
2021-03-11 21:14:47,579 [main:302] - generating value of type = Any false depth = 12
2021-03-11 21:14:47,579 [main:95] - GENERATED = require(true, { "uvfkd"})
2021-03-11 21:14:47,579 [main:95] - GENERATED = contract({ require(true, { "uvfkd"})})
2021-03-11 21:14:47,580 [main:95] - GENERATED = contract({ contract({ require(true, { "uvfkd"})})})
2021-03-11 21:14:47,580 [main:58] - GENERATED VALUE OF TYPE Unit? = contract({ contract({ require(true, { "uvfkd"})})})
2021-03-11 21:14:47,580 [main:61] - GENERATED IS CALL =true
2021-03-11 21:14:48,817 [main:67] - randomType = Collection<Kla8?>
2021-03-11 21:14:48,819 [main:106] - GETTING Unit? from Int?
2021-03-11 21:14:48,861 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:48,889 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:48,890 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:48,891 [main:106] - GETTING Unit? from Int
2021-03-11 21:14:48,935 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:48,936 [main:106] - GETTING Unit? from Long?
2021-03-11 21:14:48,967 [main:106] - GETTING Unit? from Long
2021-03-11 21:14:48,968 [main:106] - GETTING Unit? from Int?
2021-03-11 21:14:48,969 [main:106] - GETTING Unit? from Function0<Unit>
2021-03-11 21:14:48,977 [main:113] - Case = [public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@94ff8af]]
2021-03-11 21:14:48,977 [main:149] - GENERATING call of type public abstract operator fun invoke(): kotlin.Unit defined in kotlin.Function0[FunctionInvokeDescriptor@94ff8af]
2021-03-11 21:14:48,978 [main:117] - GENERATED CALL = (prope3)?.invoke()
2021-03-11 21:14:48,978 [main:114] - replacement of resume(Kla0("oelcd")) of type Unit? is contract({ contract({ require(true, { "uvfkd"})})})
2021-03-11 21:14:49,276 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:14:49,277 [main:66] - Compilation checking started
2021-03-11 21:14:50,092 [main:49] - Result = false
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {a: Continuation<Ty0> -> check(true, { "umyph"})}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.contract({ contract({ require(true, { "uvfkd"})})})
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
({ check(prope2, { "csrij"})})?.invoke()
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { false} ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:50,101 [main:107] - replacing (this, Kla4)
2021-03-11 21:14:50,101 [main:50] - replacing this Kla4
2021-03-11 21:14:50,101 [main:54] - Getting value of type Kla4
2021-03-11 21:14:50,413 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-11 21:14:50,429 [main:112] - generating klass Kla4 text = class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}
2021-03-11 21:14:50,429 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4()
2021-03-11 21:14:50,429 [main:61] - GENERATED IS CALL =true
2021-03-11 21:14:51,797 [main:67] - randomType = Pair<Kla2?, LinkedHashSet<Kla4>>
2021-03-11 21:14:52,106 [main:302] - generating value of type = Pair<Kla2?, LinkedHashSet<Kla4>> false depth = 0
2021-03-11 21:14:52,432 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla2?, second: LinkedHashSet<Kla4>): Pair<Kla2?, LinkedHashSet<Kla4>> = TODO()
2021-03-11 21:14:52,452 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla2?, second: LinkedHashSet<Kla4>): Pair<Kla2?, LinkedHashSet<Kla4>> = TODO()
2021-03-11 21:14:52,784 [main:302] - generating value of type = Kla2 false depth = 3
2021-03-11 21:14:52,801 [main:112] - generating klass Kla2 text = class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}
2021-03-11 21:14:53,104 [main:194] - Type params = []
2021-03-11 21:14:53,434 [main:302] - generating value of type = LinkedHashSet<Kla4> false depth = 3
2021-03-11 21:14:53,759 [main:43] - GENERATING CALL OF fun <E> LinkedHashSet(elements: kotlin.collections.Collection<Kla4>): LinkedHashSet<Kla4> = TODO()
2021-03-11 21:14:53,778 [main:61] - WITHOUT TYPE PARAMS = fun <E> LinkedHashSet(elements: kotlin.collections.Collection<Kla4>): LinkedHashSet<Kla4> = TODO()
2021-03-11 21:14:54,559 [main:302] - generating value of type = Collection<Kla4> false depth = 6
2021-03-11 21:14:54,894 [main:43] - GENERATING CALL OF fun <T> hashSetOf(elements: Kla4): Collection<Kla4> = TODO()
2021-03-11 21:14:54,914 [main:61] - WITHOUT TYPE PARAMS = fun <T> hashSetOf(elements: Kla4): Collection<Kla4> = TODO()
2021-03-11 21:14:55,247 [main:302] - generating value of type = Kla4 false depth = 9
2021-03-11 21:14:55,264 [main:112] - generating klass Kla4 text = class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
this.prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}
2021-03-11 21:14:55,264 [main:95] - GENERATED = hashSetOf<Kla4>(Kla4())
2021-03-11 21:14:55,264 [main:95] - GENERATED = LinkedHashSet<Kla4>(hashSetOf<Kla4>(Kla4()))
2021-03-11 21:14:55,264 [main:95] - GENERATED = Pair<Kla2?, LinkedHashSet<Kla4>>(Kla2(), LinkedHashSet<Kla4>(hashSetOf<Kla4>(Kla4())))
2021-03-11 21:14:55,285 [main:106] - GETTING Kla4 from Function0<Unit>
2021-03-11 21:14:55,295 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,325 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,325 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,326 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,326 [main:106] - GETTING Kla4 from Int?
2021-03-11 21:14:55,358 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,388 [main:106] - GETTING Kla4 from Short?
2021-03-11 21:14:55,419 [main:106] - GETTING Kla4 from Byte
2021-03-11 21:14:55,449 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,450 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,450 [main:106] - GETTING Kla4 from Short?
2021-03-11 21:14:55,451 [main:106] - GETTING Kla4 from Long?
2021-03-11 21:14:55,482 [main:106] - GETTING Kla4 from Short?
2021-03-11 21:14:55,482 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,483 [main:106] - GETTING Kla4 from Byte?
2021-03-11 21:14:55,514 [main:106] - GETTING Kla4 from Int?
2021-03-11 21:14:55,515 [main:106] - GETTING Kla4 from Byte?
2021-03-11 21:14:55,516 [main:106] - GETTING Kla4 from Short?
2021-03-11 21:14:55,516 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,517 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,517 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,518 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,519 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,519 [main:106] - GETTING Kla4 from Long?
2021-03-11 21:14:55,520 [main:106] - GETTING Kla4 from Int?
2021-03-11 21:14:55,520 [main:106] - GETTING Kla4 from Int?
2021-03-11 21:14:55,521 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,522 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,522 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,523 [main:106] - GETTING Kla4 from Short
2021-03-11 21:14:55,553 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,554 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,554 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,555 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,556 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,556 [main:106] - GETTING Kla4 from Int?
2021-03-11 21:14:55,557 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,557 [main:106] - GETTING Kla4 from Long?
2021-03-11 21:14:55,558 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,558 [main:106] - GETTING Kla4 from Long?
2021-03-11 21:14:55,559 [main:106] - GETTING Kla4 from Long?
2021-03-11 21:14:55,560 [main:106] - GETTING Kla4 from Short
2021-03-11 21:14:55,560 [main:106] - GETTING Kla4 from Byte?
2021-03-11 21:14:55,561 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,561 [main:106] - GETTING Kla4 from Long?
2021-03-11 21:14:55,562 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,563 [main:106] - GETTING Kla4 from Int
2021-03-11 21:14:55,563 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,564 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,564 [main:106] - GETTING Kla4 from Byte?
2021-03-11 21:14:55,565 [main:106] - GETTING Kla4 from Int?
2021-03-11 21:14:55,565 [main:106] - GETTING Kla4 from Long?
2021-03-11 21:14:55,566 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,567 [main:106] - GETTING Kla4 from Int?
2021-03-11 21:14:55,567 [main:106] - GETTING Kla4 from Long
2021-03-11 21:14:55,568 [main:106] - GETTING Kla4 from Function0<Unit>
2021-03-11 21:14:55,568 [main:114] - replacement of this of type Kla4 is Kla4()
2021-03-11 21:14:55,893 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-11 21:14:55,894 [main:66] - Compilation checking started
2021-03-11 21:14:57,124 [main:53] - Result = true
Text:
import kotlin.experimental.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


fun box(): String {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}

var prope0 = "FAIL"

var prope1 = 0

var prope2 = false

var prope3: () -> Unit = {}

suspend fun fu0() = suspendCoroutine<Unit> {a: Continuation<Unit> -> println()}

inline suspend fun fu1() {
    fu0()
    fu0()
    fu0()
    fu0()
    fu0()
}

fun fu2(c: suspend () -> Unit) {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
val prope4 = object: Continuation<Unit> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(r: Result<Unit>) {
            var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
runCatching<Unit>({ print("cphxq")}).getOrThrow()
            prope3 = { println()}
        }
    }
    c.startCoroutine(prope4)
}

suspend fun fu3() {
    fu1()
    fu1()
}

fun box414(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
fu2 {
        fu3()
    }
    for (counter in 0 until 10) {
        if ((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1) != (32).toInt()) return "Expected ${((larg2 shl 32)).toInt().xor(iarg1) + 1}, got $prope1"
        prope3()
    }
    if (prope1 != 10) return "FAIL $prope1"
    if (prope2) return "pvtku"
    { check(prope2, { "csrij"})}()
    if (((larg2 shl 32) shl 32).equals("volbl")) return ((0xB98AB98AL shl 32 shl iarg1)).toShort().toString(iarg1)
    return prope0
}

fun fu4(prope5: suspend () -> Unit) {
    prope5.startCoroutine(Kla3)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope5: Continuation<Any>? = null

suspend fun <Ty0> fu5(): Ty0 = suspendCoroutine {a: Continuation<Ty0> -> check(true, { "umyph"})}

interface Kla1 {
    suspend fun fu8(): Kla0?
}

class Kla2() : Kla1 {

    override suspend fun fu8(): Kla0 = fu5()

    suspend fun fu9(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
val prope13: Kla1 = Kla2()
        return prope13.fu8()!!.s
    }

    suspend fun fu10(): String {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
return fu8().s
    }
}

fun box886(): String {
    var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
var prope8 = "FAIL"
    fu4 {
        prope8 = Kla2().fu9()
    }
    prope5?.resume(Kla0("oelcd"))
    if (prope8 != "OK") return "FAIL 1 $prope8"

    prope8 = "FAIL2"
    fu4 {
        prope8 = Kla2().fu10()
    }
    prope5?.resume(Kla0("OK"))
    if (prope8 != "OK") return "FAIL 2 $prope8"

    return prope8
}

fun <Ty0> fu6(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
x(prope8.getOrThrow())
    }
}

fun fu7(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
({ check(prope2, { "csrij"})})?.invoke()
    }
}

open class Kla3(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla9 : Kla3()
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope8.getOrThrow()
    }
}

class Kla4 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Any?>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
Kla4().prope8 = prope8.getOrThrow()
    }

    var prope8: Any? = null
}

abstract class Kla5<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope8: Result<Ty0>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope8.isSuccess) {
            resume(prope8.getOrThrow())
        } else {
            fu11(prope8.exceptionOrNull()!!)
        }
    }

    abstract fun fu11(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla6 {
    private val prope9 = arrayListOf<StackTraceElement?>()

    suspend fun fu13() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu13(it)
    }

    fun fu13(prope5: Continuation<*>) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
if (prope5 !is CoroutineStackFrame) error("Continuation " + prope5 + " is not subtype of CoroutineStackFrame")
        prope9.clear()
        var prope14: CoroutineStackFrame? = prope5
        while (prope14 != null) {
            prope9.add(prope14.getStackTraceElement())
            prope14 = prope14.callerFrame
        }
    }

    fun fu14(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { it?.methodName?.startsWith((((larg2 shl 32)).toInt().xor(iarg1)).toByte().toString(((larg2 shl 32)).toInt())) == true }?.let { error((-175906407).compareTo(((larg2 shl 32)).toInt()).toString((0x00000000L shl 32 shl 1).compareTo(barg1).times(barg1)) + it + " has state-machine " +
                prope9.joinToString(separator = "\n")) }
    }

    fun fu15(method: String) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope9.find { false} ?: error("tail-call optimization hit: method " + (((larg2 shl 32) shl 32)).toChar().lowercase() + " has no state-machine " +
                prope9.joinToString(separator = "\n"))
    }
}

val prope6 = Kla6()

class Kla7 {
    private var prope10 = 0
    var prope11 = false

    var prope12: () -> Unit = {}

    fun fu16() {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope10 = 0
        prope11 = false
        prope12 = { check(prope2, { "csrij"})}
    }

    suspend fun fu17() = suspendCoroutine<Unit> { prope5 ->
        prope10++
        prope3 = { prope5.resume(Unit) }
    }

    fun fu18(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
for (i in ((0xDC56DC56L shl 32) + 0xDC56DC56).toInt().minus(25)..(((larg2 shl 32)).toInt().xor(iarg1)).shl(((larg2 shl 32)).toInt())) {
            if (prope10 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope10)
            prope12()
        }
        if (((32)).toChar().isTitleCase())
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope10)
        if (((0x00000000L shl 32 shl 1)).toFloat().isNaN()) error("Wrong state-machine generated: it is finished early")
        prope3()
        if ((12484.toUShort()).equals("psktq").and(true)) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope7 = Kla7()

object Kla8: Kla5<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        var iarg1: Int = 0xDC56DC56.toInt()
var iarg2: Int = 0x65DC65DC
var i1: Int? = iarg1 and iarg2
var i2: Int? = iarg1 or  iarg2
var i3: Int? = iarg1 xor iarg2
var i4: Int? = iarg1.inv()
var i5: Int? = iarg1 shl 16
var i6: Int? = iarg1 shr 16
var i7: Int? = iarg1 ushr 16
var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
var larg2: Long = 0x65DC65DC65DC65DC
var l1: Long? = larg1 and larg2
var l2: Long? = larg1 or  larg2
var l3: Long? = larg1 xor larg2
var l4: Long? = larg1.inv()
var l5: Long? = larg1 shl 32
var l6: Long? = larg1 shr 32
var l7: Long? = larg1 ushr 32
var sarg1: Short = 0xDC56.toShort()
var sarg2: Short = 0x65DC.toShort()
var s1: Short? = sarg1 and sarg2
var s2: Short? = sarg1 or  sarg2
var s3: Short? = sarg1 xor sarg2
var s4: Short? = sarg1.inv()
var barg1: Byte = 0xDC.toByte()
var barg2: Byte = 0x65.toByte()
var b1: Byte? = barg1 and barg2
var b2: Byte? = barg1 or  barg2
var b3: Byte? = barg1 xor barg2
var b4: Byte? = barg1.inv()
var prope0 = "FAIL"
var prope1 = 0
var prope2 = false
var prope3: () -> Unit = {}
prope7.prope12 = {
            Kla7().prope11 = true
        }
    }

    override fun fu11(exception: Throwable) {
        throw exception
    }
}


2021-03-11 21:14:57,134 [main:107] - replacing (0, Int)
2021-03-11 21:14:57,134 [main:50] - replacing 0 Int
2021-03-11 21:14:57,135 [main:54] - Getting value of type Int
