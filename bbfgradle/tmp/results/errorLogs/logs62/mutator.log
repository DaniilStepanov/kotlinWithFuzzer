2021-03-12 01:43:07,830 [main:66] - Compilation checking started
2021-03-12 01:43:09,137 [main:50] - replacing vararg val args: KClass<*> KClass<*>
2021-03-12 01:43:09,137 [main:54] - Getting value of type KClass<*>
2021-03-12 01:43:09,311 [main:302] - generating value of type = KClass<*> false depth = 0
2021-03-12 01:43:09,497 [main:58] - GENERATED VALUE OF TYPE KClass<*> = O::class
2021-03-12 01:43:09,498 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:10,628 [main:67] - randomType = HashMap<Boolean, ArrayDeque<Long>>?
2021-03-12 01:43:10,756 [main:302] - generating value of type = HashMap<Boolean, ArrayDeque<Long>> false depth = 0
2021-03-12 01:43:10,902 [main:43] - GENERATING CALL OF fun <K, V> HashMap(original: kotlin.collections.Map<Boolean, ArrayDeque<Long>>): HashMap<Boolean, ArrayDeque<Long>> = TODO()
2021-03-12 01:43:10,905 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> HashMap(original: kotlin.collections.Map<Boolean, ArrayDeque<Long>>): HashMap<Boolean, ArrayDeque<Long>> = TODO()
2021-03-12 01:43:11,118 [main:302] - generating value of type = Map<Boolean, ArrayDeque<Long>> false depth = 3
2021-03-12 01:43:11,246 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): Map<Boolean, ArrayDeque<Long>> = TODO()
2021-03-12 01:43:11,249 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): Map<Boolean, ArrayDeque<Long>> = TODO()
2021-03-12 01:43:11,381 [main:95] - GENERATED = linkedMapOf<Boolean, ArrayDeque<Long>>()
2021-03-12 01:43:11,382 [main:95] - GENERATED = HashMap<Boolean, ArrayDeque<Long>>(linkedMapOf<Boolean, ArrayDeque<Long>>())
2021-03-12 01:43:11,663 [main:33] - Trying to replace Element(VALUE_PARAMETER) on Element(VALUE_PARAMETER)
2021-03-12 01:43:11,663 [main:66] - Compilation checking started
2021-03-12 01:43:12,096 [main:49] - Result = false
Text:
import kotlin.reflect.KClass

@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*> = O::class)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}


2021-03-12 01:43:12,316 [main:112] - generating klass Ann text = @Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)
2021-03-12 01:43:12,317 [main:112] - generating klass O text = class O
2021-03-12 01:43:12,317 [main:112] - generating klass K text = class K
2021-03-12 01:43:12,317 [main:112] - generating klass MyClass text = @Ann(O::class, K::class) class MyClass
2021-03-12 01:43:12,548 [main:45] - Trying to change 12 nodes
2021-03-12 01:43:12,551 [main:53] - replacing (argName2, String)
2021-03-12 01:43:12,551 [main:50] - replacing argName2 String
2021-03-12 01:43:12,551 [main:54] - Getting value of type String
2021-03-12 01:43:12,646 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:43:12,649 [main:58] - GENERATED VALUE OF TYPE String = "hujur"
2021-03-12 01:43:12,649 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:12,760 [main:67] - randomType = K
2021-03-12 01:43:12,850 [main:302] - generating value of type = K false depth = 0
2021-03-12 01:43:12,850 [main:112] - generating klass K text = class K
2021-03-12 01:43:12,855 [main:106] - GETTING String from String
2021-03-12 01:43:12,888 [main:113] - Case = [public fun kotlin.String.take(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@45ed6e0a]]
2021-03-12 01:43:12,889 [main:149] - GENERATING call of type public fun kotlin.String.take(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@45ed6e0a]
2021-03-12 01:43:12,975 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:12,977 [main:117] - GENERATED CALL = (argName2).take(509877075)
2021-03-12 01:43:12,977 [main:113] - Case = [public final operator fun plus(other: kotlin.Any?): kotlin.String defined in kotlin.String[DeserializedSimpleFunctionDescriptor@7cc89f6]]
2021-03-12 01:43:12,977 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Any?): kotlin.String defined in kotlin.String[DeserializedSimpleFunctionDescriptor@7cc89f6]
2021-03-12 01:43:13,068 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:43:13,070 [main:117] - GENERATED CALL = (argName2).plus("byifh")
2021-03-12 01:43:13,070 [main:113] - Case = [public fun kotlin.String.substringAfter(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e2da6e0]]
2021-03-12 01:43:13,070 [main:149] - GENERATING call of type public fun kotlin.String.substringAfter(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e2da6e0]
2021-03-12 01:43:13,190 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:43:13,192 [main:117] - GENERATED CALL = (argName2).substringAfter('瑏', argName1)
2021-03-12 01:43:13,192 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.replace(regex: kotlin.text.Regex, noinline transform: (kotlin.text.MatchResult) -> kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2801b6a0]]
2021-03-12 01:43:13,193 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:43:13,293 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:13,384 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:13,385 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.replace(regex: kotlin.text.Regex, noinline transform: (kotlin.text.MatchResult) -> kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2801b6a0]
2021-03-12 01:43:13,483 [main:302] - generating value of type = Regex false depth = 0
2021-03-12 01:43:13,588 [main:43] - GENERATING CALL OF fun Regex(pattern: kotlin.String): Regex = TODO()
2021-03-12 01:43:13,590 [main:61] - WITHOUT TYPE PARAMS = fun Regex(pattern: kotlin.String): Regex = TODO()
2021-03-12 01:43:13,781 [main:302] - generating value of type = String true depth = 3
2021-03-12 01:43:13,782 [main:95] - GENERATED = Regex("wfxdh")
2021-03-12 01:43:13,906 [main:302] - generating value of type = Function1<MatchResult, CharSequence> false depth = 0
2021-03-12 01:43:13,906 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-12 01:43:13,916 [main:117] - GENERATED CALL = (argName2).subSequence(249319596, 360989875).replace(Regex("wfxdh"), {a: MatchResult -> "bktks"})
2021-03-12 01:43:13,916 [main:113] - Case = [public fun kotlin.String.removeSurrounding(delimiter: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71671b6b]]
2021-03-12 01:43:13,916 [main:149] - GENERATING call of type public fun kotlin.String.removeSurrounding(delimiter: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71671b6b]
2021-03-12 01:43:14,025 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:43:14,126 [main:43] - GENERATING CALL OF fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-12 01:43:14,128 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-12 01:43:14,373 [main:302] - generating value of type = CharSequence false depth = 3
2021-03-12 01:43:14,379 [main:95] - GENERATED = StringBuilder("ffxdn")
2021-03-12 01:43:14,379 [main:117] - GENERATED CALL = (argName2).removeSurrounding(StringBuilder("ffxdn"))
2021-03-12 01:43:14,380 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceFirstChar(transform: (kotlin.Char) -> kotlin.Char): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@62a01f1b]]
2021-03-12 01:43:14,380 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceFirstChar(transform: (kotlin.Char) -> kotlin.Char): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@62a01f1b]
2021-03-12 01:43:14,470 [main:302] - generating value of type = Function1<Char, Char> false depth = 0
2021-03-12 01:43:14,470 [main:302] - generating value of type = Char true depth = 1
2021-03-12 01:43:14,472 [main:117] - GENERATED CALL = (argName2).replaceFirstChar({a: Char -> ''})
2021-03-12 01:43:14,472 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@b810d92]]
2021-03-12 01:43:14,472 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@b810d92]
2021-03-12 01:43:14,555 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:14,556 [main:117] - GENERATED CALL = (argName2).length.toString(1887146941)
2021-03-12 01:43:14,557 [main:113] - Case = [public fun kotlin.String.capitalize(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5a4536a8]]
2021-03-12 01:43:14,557 [main:149] - GENERATING call of type public fun kotlin.String.capitalize(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5a4536a8]
2021-03-12 01:43:14,557 [main:117] - GENERATED CALL = (argName2).capitalize()
2021-03-12 01:43:14,558 [main:113] - Case = [public fun kotlin.String.trimIndent(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@15ad0166]]
2021-03-12 01:43:14,558 [main:149] - GENERATING call of type public fun kotlin.String.trimIndent(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@15ad0166]
2021-03-12 01:43:14,558 [main:117] - GENERATED CALL = (argName2).trimIndent()
2021-03-12 01:43:14,558 [main:113] - Case = [public fun kotlin.String.prependIndent(indent: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2da28332]]
2021-03-12 01:43:14,558 [main:149] - GENERATING call of type public fun kotlin.String.prependIndent(indent: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2da28332]
2021-03-12 01:43:14,559 [main:117] - GENERATED CALL = (argName2).prependIndent(argName2)
2021-03-12 01:43:14,559 [main:61] - replacement of argName2 of type String is (argName2).prependIndent(argName2)
2021-03-12 01:43:14,641 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:14,642 [main:66] - Compilation checking started
2021-03-12 01:43:15,065 [main:53] - Result = true
Text:
import kotlin.reflect.KClass

@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + (argName2).prependIndent(argName2)
}


2021-03-12 01:43:15,066 [main:53] - replacing (AnnotationRetention.RUNTIME, AnnotationRetention)
2021-03-12 01:43:15,066 [main:50] - replacing AnnotationRetention.RUNTIME AnnotationRetention
2021-03-12 01:43:15,066 [main:54] - Getting value of type AnnotationRetention
2021-03-12 01:43:15,160 [main:302] - generating value of type = AnnotationRetention false depth = 0
2021-03-12 01:43:15,162 [main:58] - GENERATED VALUE OF TYPE AnnotationRetention = kotlin.annotation.AnnotationRetention.SOURCE
2021-03-12 01:43:15,162 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:15,255 [main:67] - randomType = Double
2021-03-12 01:43:15,340 [main:302] - generating value of type = Double true depth = 0
2021-03-12 01:43:15,402 [main:61] - replacement of AnnotationRetention.RUNTIME of type AnnotationRetention is kotlin.annotation.AnnotationRetention.SOURCE
2021-03-12 01:43:15,489 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:15,490 [main:66] - Compilation checking started
2021-03-12 01:43:15,889 [main:53] - Result = true
Text:
import kotlin.reflect.KClass

@Retention(kotlin.annotation.AnnotationRetention.SOURCE)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + (argName2).prependIndent(argName2)
}


2021-03-12 01:43:15,890 [main:53] - replacing (K::class, KClass<K>)
2021-03-12 01:43:15,890 [main:50] - replacing K::class KClass<K>
2021-03-12 01:43:15,890 [main:54] - Getting value of type KClass<K>
2021-03-12 01:43:16,007 [main:302] - generating value of type = KClass<K> false depth = 0
2021-03-12 01:43:16,093 [main:58] - GENERATED VALUE OF TYPE KClass<K> = K::class
2021-03-12 01:43:16,094 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:16,278 [main:67] - randomType = Collection<Byte>
2021-03-12 01:43:16,278 [main:61] - replacement of K::class of type KClass<K> is K::class
2021-03-12 01:43:16,363 [main:33] - Trying to replace Element(CLASS_LITERAL_EXPRESSION) on Element(CLASS_LITERAL_EXPRESSION)
2021-03-12 01:43:16,364 [main:53] - replacing (0, Int)
2021-03-12 01:43:16,364 [main:50] - replacing 0 Int
2021-03-12 01:43:16,364 [main:54] - Getting value of type Int
2021-03-12 01:43:16,451 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:16,451 [main:58] - GENERATED VALUE OF TYPE Int = 400232046
2021-03-12 01:43:16,451 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:16,563 [main:67] - randomType = K
2021-03-12 01:43:16,666 [main:302] - generating value of type = K false depth = 0
2021-03-12 01:43:16,667 [main:112] - generating klass K text = class K
2021-03-12 01:43:16,674 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in K[DeserializedSimpleFunctionDescriptor@2365ee40]
2021-03-12 01:43:16,768 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:43:16,768 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:43:16,856 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:16,857 [main:78] - Generated call from random type = (K()).equals("pnpzt").compareTo(true)
2021-03-12 01:43:16,859 [main:106] - GETTING Int from [ERROR : <ERROR PROPERTY TYPE>]
2021-03-12 01:43:16,865 [main:106] - GETTING Int from String
2021-03-12 01:43:16,902 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3d52a67f]]
2021-03-12 01:43:16,902 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3d52a67f]
2021-03-12 01:43:16,998 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:16,999 [main:117] - GENERATED CALL = (argName1).length.shr(-578278106)
2021-03-12 01:43:16,999 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:43:17,000 [main:117] - GENERATED CALL = (argName1).length
2021-03-12 01:43:17,000 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@645cceaa]]
2021-03-12 01:43:17,000 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:43:17,001 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@645cceaa]
2021-03-12 01:43:17,001 [main:117] - GENERATED CALL = (argName1).compareTo(argName1).dec()
2021-03-12 01:43:17,001 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3ef72d49]]
2021-03-12 01:43:17,002 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:43:17,002 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3ef72d49]
2021-03-12 01:43:17,111 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:17,112 [main:117] - GENERATED CALL = (argName1).compareTo(argName1).ushr(-1266487430)
2021-03-12 01:43:17,112 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]]
2021-03-12 01:43:17,112 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]
2021-03-12 01:43:17,112 [main:117] - GENERATED CALL = (argName1).count()
2021-03-12 01:43:17,112 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@5856de23]]
2021-03-12 01:43:17,113 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:43:17,198 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:17,199 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@5856de23]
2021-03-12 01:43:17,284 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:43:17,285 [main:117] - GENERATED CALL = (argName1).get(1668021551).compareTo('')
2021-03-12 01:43:17,286 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Int.absoluteValue: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@15d4cc5]]
2021-03-12 01:43:17,287 [main:117] - GENERATED CALL = (argName1).length.absoluteValue
2021-03-12 01:43:17,287 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.sumOf(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36df585a]]
2021-03-12 01:43:17,287 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.sumOf(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36df585a]
2021-03-12 01:43:17,373 [main:302] - generating value of type = Function1<Char, Int> false depth = 0
2021-03-12 01:43:17,374 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:43:17,375 [main:117] - GENERATED CALL = (argName1).sumOf({a: Char -> 907364751})
2021-03-12 01:43:17,375 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]]
2021-03-12 01:43:17,375 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:43:17,470 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:17,557 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:17,558 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]
2021-03-12 01:43:17,559 [main:117] - GENERATED CALL = (argName1).subSequence(1732711136, 692277735).count()
2021-03-12 01:43:17,559 [main:113] - Case = [public inline fun kotlin.CharSequence.indexOfLast(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@306cd945]]
2021-03-12 01:43:17,559 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.indexOfLast(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@306cd945]
2021-03-12 01:43:17,639 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:43:17,640 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:43:17,641 [main:117] - GENERATED CALL = (argName1).indexOfLast({a: Char -> false})
2021-03-12 01:43:17,641 [main:61] - replacement of 0 of type Int is (K()).equals("pnpzt").compareTo(true)
2021-03-12 01:43:17,722 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:17,722 [main:66] - Compilation checking started
2021-03-12 01:43:18,098 [main:53] - Result = true
Text:
import kotlin.reflect.KClass

@Retention(kotlin.annotation.AnnotationRetention.SOURCE)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[(K()).equals("pnpzt").compareTo(true)].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + (argName2).prependIndent(argName2)
}


2021-03-12 01:43:18,098 [main:53] - replacing (K::class, KClass<K>)
2021-03-12 01:43:18,098 [main:50] - replacing K::class KClass<K>
2021-03-12 01:43:18,098 [main:54] - Getting value of type KClass<K>
2021-03-12 01:43:18,203 [main:302] - generating value of type = KClass<K> false depth = 0
2021-03-12 01:43:18,297 [main:58] - GENERATED VALUE OF TYPE KClass<K> = K::class
2021-03-12 01:43:18,297 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:18,497 [main:67] - randomType = K?
2021-03-12 01:43:18,581 [main:302] - generating value of type = K false depth = 0
2021-03-12 01:43:18,581 [main:112] - generating klass K text = class K
2021-03-12 01:43:18,586 [main:61] - replacement of K::class of type KClass<K> is K::class
2021-03-12 01:43:18,667 [main:33] - Trying to replace Element(CLASS_LITERAL_EXPRESSION) on Element(CLASS_LITERAL_EXPRESSION)
2021-03-12 01:43:18,667 [main:53] - replacing (K::class, KClass<K>)
2021-03-12 01:43:18,667 [main:50] - replacing K::class KClass<K>
2021-03-12 01:43:18,667 [main:54] - Getting value of type KClass<K>
2021-03-12 01:43:18,785 [main:302] - generating value of type = KClass<K> false depth = 0
2021-03-12 01:43:18,878 [main:58] - GENERATED VALUE OF TYPE KClass<K> = K::class
2021-03-12 01:43:18,878 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:18,879 [main:67] - randomType = Ann
2021-03-12 01:43:18,963 [main:302] - generating value of type = Ann false depth = 0
2021-03-12 01:43:18,963 [main:112] - generating klass Ann text = @Retention(kotlin.annotation.AnnotationRetention.SOURCE)
annotation class Ann(vararg val args: KClass<*>)
2021-03-12 01:43:18,977 [main:61] - replacement of K::class of type KClass<K> is K::class
2021-03-12 01:43:19,060 [main:33] - Trying to replace Element(CLASS_LITERAL_EXPRESSION) on Element(CLASS_LITERAL_EXPRESSION)
2021-03-12 01:43:19,061 [main:53] - replacing (1, Int)
2021-03-12 01:43:19,062 [main:50] - replacing 1 Int
2021-03-12 01:43:19,062 [main:54] - Getting value of type Int
2021-03-12 01:43:19,145 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:19,145 [main:58] - GENERATED VALUE OF TYPE Int = 740143661
2021-03-12 01:43:19,145 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:19,260 [main:67] - randomType = K
2021-03-12 01:43:19,351 [main:302] - generating value of type = K false depth = 0
2021-03-12 01:43:19,351 [main:112] - generating klass K text = class K
2021-03-12 01:43:19,356 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in K[DeserializedSimpleFunctionDescriptor@7b4c167e]
2021-03-12 01:43:19,437 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:43:19,438 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:43:19,522 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:19,523 [main:78] - Generated call from random type = (K()).equals("yyksa").compareTo(false)
2021-03-12 01:43:19,524 [main:106] - GETTING Int from String
2021-03-12 01:43:19,559 [main:113] - Case = [public fun kotlin.CharSequence.lastIndexOfAny(chars: kotlin.CharArray, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12eaf6dc]]
2021-03-12 01:43:19,560 [main:149] - GENERATING call of type public fun kotlin.CharSequence.lastIndexOfAny(chars: kotlin.CharArray, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12eaf6dc]
2021-03-12 01:43:19,645 [main:302] - generating value of type = CharArray false depth = 0
2021-03-12 01:43:19,750 [main:43] - GENERATING CALL OF fun charArrayOf(elements: Char): CharArray = TODO()
2021-03-12 01:43:19,756 [main:61] - WITHOUT TYPE PARAMS = fun charArrayOf(elements: Char): CharArray = TODO()
2021-03-12 01:43:19,843 [main:302] - generating value of type = Char true depth = 3
2021-03-12 01:43:19,844 [main:95] - GENERATED = charArrayOf('授')
2021-03-12 01:43:19,923 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:20,006 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:20,007 [main:117] - GENERATED CALL = (argName2).lastIndexOfAny(charArrayOf('授'), 1617439772, true)
2021-03-12 01:43:20,008 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2aabdce6]]
2021-03-12 01:43:20,008 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2aabdce6]
2021-03-12 01:43:20,008 [main:117] - GENERATED CALL = (argName2).length.unaryPlus()
2021-03-12 01:43:20,008 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], @kotlin.ExperimentalStdlibApi @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Char.code: kotlin.Int defined in kotlin[DeserializedPropertyDescriptor@3dc77ff4]]
2021-03-12 01:43:20,008 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:43:20,096 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:20,097 [main:117] - GENERATED CALL = (argName2).get(-178492553).code
2021-03-12 01:43:20,097 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@42b8bc3a]]
2021-03-12 01:43:20,098 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@42b8bc3a]
2021-03-12 01:43:20,198 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:20,199 [main:117] - GENERATED CALL = (argName2).length.shl(292644125)
2021-03-12 01:43:20,200 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:43:20,200 [main:117] - GENERATED CALL = (argName2).length
2021-03-12 01:43:20,200 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.indexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@f5b882b]]
2021-03-12 01:43:20,200 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:43:20,304 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:20,387 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:20,388 [main:149] - GENERATING call of type public fun kotlin.CharSequence.indexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@f5b882b]
2021-03-12 01:43:20,469 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:43:20,558 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:20,659 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:20,660 [main:117] - GENERATED CALL = (argName2).subSequence(-853242961, 1757692184).indexOf('᫿', -911796638, true)
2021-03-12 01:43:20,660 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@292b7b88]]
2021-03-12 01:43:20,660 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@292b7b88]
2021-03-12 01:43:20,752 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:20,753 [main:117] - GENERATED CALL = (argName2).length.or(-946331833)
2021-03-12 01:43:20,753 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ee76b77]]
2021-03-12 01:43:20,753 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ee76b77]
2021-03-12 01:43:20,835 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:43:20,836 [main:117] - GENERATED CALL = (argName2).length.compareTo(4)
2021-03-12 01:43:20,836 [main:113] - Case = [public inline fun kotlin.CharSequence.sumBy(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6a73f254]]
2021-03-12 01:43:20,836 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.sumBy(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6a73f254]
2021-03-12 01:43:20,916 [main:302] - generating value of type = Function1<Char, Int> false depth = 0
2021-03-12 01:43:20,916 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:43:20,918 [main:117] - GENERATED CALL = (argName2).sumBy({a: Char -> 1650119567})
2021-03-12 01:43:20,918 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1f344be]]
2021-03-12 01:43:20,918 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:43:20,918 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1f344be]
2021-03-12 01:43:21,007 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:21,008 [main:117] - GENERATED CALL = (argName2).compareTo(argName2).coerceAtLeast(622702324)
2021-03-12 01:43:21,008 [main:61] - replacement of 1 of type Int is (argName2).compareTo(argName2).coerceAtLeast(622702324)
2021-03-12 01:43:21,110 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:21,111 [main:66] - Compilation checking started
2021-03-12 01:43:21,360 [main:49] - Result = false
Text:
import kotlin.reflect.KClass

@Retention(kotlin.annotation.AnnotationRetention.SOURCE)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[(K()).equals("pnpzt").compareTo(true)].simpleName ?: "fail 1"
    val argName2 = args[(argName2).compareTo(argName2).coerceAtLeast(622702324)].simpleName ?: "fail 2"
    return argName1 + (argName2).prependIndent(argName2)
}


2021-03-12 01:43:21,444 [main:119] - TRYING TO REPLACE CONSTANT true
2021-03-12 01:43:21,524 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:21,524 [main:66] - Compilation checking started
2021-03-12 01:43:21,853 [main:53] - Result = true
Text:
import kotlin.reflect.KClass

@Retention(kotlin.annotation.AnnotationRetention.SOURCE)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[(K()).equals("pnpzt").compareTo((K()).equals("pnpzt"))].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + (argName2).prependIndent(argName2)
}


2021-03-12 01:43:21,889 [main:41] - AFTER TRY 0 res = import kotlin.reflect.KClass

@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}
2021-03-12 01:43:22,077 [main:112] - generating klass Ann text = @Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)
2021-03-12 01:43:22,078 [main:112] - generating klass O text = class O
2021-03-12 01:43:22,078 [main:112] - generating klass K text = class K
2021-03-12 01:43:22,078 [main:112] - generating klass MyClass text = @Ann(O::class, K::class) class MyClass
2021-03-12 01:43:22,235 [main:43] - Try №0
2021-03-12 01:43:23,366 [main:41] - AFTER TRY 1 res = import kotlin.reflect.KClass

@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}
2021-03-12 01:43:23,537 [main:112] - generating klass Ann text = @Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)
2021-03-12 01:43:23,537 [main:112] - generating klass O text = class O
2021-03-12 01:43:23,537 [main:112] - generating klass K text = class K
2021-03-12 01:43:23,538 [main:112] - generating klass MyClass text = @Ann(O::class, K::class) class MyClass
2021-03-12 01:43:23,759 [main:43] - Try №1
2021-03-12 01:43:34,509 [main:48] - Already checked
2021-03-12 01:43:38,389 [main:69] - Trying to insert fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }
2021-03-12 01:43:38,606 [main:66] - Compilation checking started
2021-03-12 01:43:39,777 [main:103] - Trying to change 171 nodes
2021-03-12 01:43:39,778 [main:107] - replacing ("OK", String)
2021-03-12 01:43:39,780 [main:50] - replacing "OK" String
2021-03-12 01:43:39,780 [main:54] - Getting value of type String
2021-03-12 01:43:39,942 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:43:39,944 [main:58] - GENERATED VALUE OF TYPE String = "bqzlp"
2021-03-12 01:43:39,945 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:40,647 [main:67] - randomType = Function2<MyClass, UInt, UByte>
2021-03-12 01:43:40,647 [main:106] - GETTING String from String
2021-03-12 01:43:40,679 [main:113] - Case = [public fun kotlin.String.takeLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@652e2809]]
2021-03-12 01:43:40,679 [main:149] - GENERATING call of type public fun kotlin.String.takeLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@652e2809]
2021-03-12 01:43:40,826 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:40,828 [main:117] - GENERATED CALL = (argName1).takeLast(431272206)
2021-03-12 01:43:40,828 [main:113] - Case = [public fun kotlin.String.dropLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@459c7191]]
2021-03-12 01:43:40,828 [main:149] - GENERATING call of type public fun kotlin.String.dropLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@459c7191]
2021-03-12 01:43:40,976 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:40,979 [main:117] - GENERATED CALL = (argName1).dropLast(1599895902)
2021-03-12 01:43:40,979 [main:113] - Case = [public fun kotlin.String.substringBefore(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@70c5841b]]
2021-03-12 01:43:40,979 [main:149] - GENERATING call of type public fun kotlin.String.substringBefore(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@70c5841b]
2021-03-12 01:43:41,168 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:43:41,172 [main:117] - GENERATED CALL = (argName1).substringBefore('ҵ', argName1)
2021-03-12 01:43:41,172 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5146c661]]
2021-03-12 01:43:41,172 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:43:41,323 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:41,324 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5146c661]
2021-03-12 01:43:41,325 [main:117] - GENERATED CALL = (argName1).get(-896895721).lowercase()
2021-03-12 01:43:41,325 [main:113] - Case = [public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b4bbc69]]
2021-03-12 01:43:41,325 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b4bbc69]
2021-03-12 01:43:41,466 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:43:41,614 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:41,616 [main:117] - GENERATED CALL = (argName1).commonSuffixWith("sdmyn", true)
2021-03-12 01:43:41,616 [main:113] - Case = [public inline fun kotlin.String.dropWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1eee24d5]]
2021-03-12 01:43:41,616 [main:149] - GENERATING call of type public inline fun kotlin.String.dropWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1eee24d5]
2021-03-12 01:43:41,767 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:43:41,769 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:43:41,771 [main:117] - GENERATED CALL = (argName1).dropWhile({a: Char -> false})
2021-03-12 01:43:41,772 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.toUpperCase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44cab771]]
2021-03-12 01:43:41,772 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.toUpperCase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44cab771]
2021-03-12 01:43:41,772 [main:117] - GENERATED CALL = (argName1).toUpperCase()
2021-03-12 01:43:41,772 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.reversed(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@35d6c32a]]
2021-03-12 01:43:41,772 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.reversed(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@35d6c32a]
2021-03-12 01:43:41,773 [main:117] - GENERATED CALL = (argName1).reversed()
2021-03-12 01:43:41,773 [main:113] - Case = [public fun kotlin.String.padEnd(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@24fa5f07]]
2021-03-12 01:43:41,773 [main:149] - GENERATING call of type public fun kotlin.String.padEnd(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@24fa5f07]
2021-03-12 01:43:41,938 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:42,133 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:43:42,135 [main:117] - GENERATED CALL = (argName1).padEnd(-1634467449, '嗜')
2021-03-12 01:43:42,135 [main:113] - Case = [public fun kotlin.String.padStart(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@283e9d49]]
2021-03-12 01:43:42,135 [main:149] - GENERATING call of type public fun kotlin.String.padStart(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@283e9d49]
2021-03-12 01:43:42,275 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:42,423 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:43:42,426 [main:117] - GENERATED CALL = (argName1).padStart(807212580, '梏')
2021-03-12 01:43:42,426 [main:114] - replacement of "OK" of type String is (argName1).takeLast(431272206)
2021-03-12 01:43:42,560 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:42,560 [main:66] - Compilation checking started
2021-03-12 01:43:43,001 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return (argName1).takeLast(431272206)
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:43,004 [main:107] - replacing (prope5, Int)
2021-03-12 01:43:43,006 [main:50] - replacing prope5 Int
2021-03-12 01:43:43,006 [main:54] - Getting value of type Int
2021-03-12 01:43:43,175 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:43,177 [main:58] - GENERATED VALUE OF TYPE Int = -1319661247
2021-03-12 01:43:43,178 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:44,489 [main:67] - randomType = Function1<Byte, Triple<O, UByte?, LinkedHashSet<Ann>>?>
2021-03-12 01:43:44,490 [main:106] - GETTING Int from KClass<MyClass>
2021-03-12 01:43:44,500 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:43:44,500 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:43:44,627 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:43:44,628 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:43:44,760 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:44,762 [main:117] - GENERATED CALL = (MyClass::class).equals("cskco").compareTo(true)
2021-03-12 01:43:44,762 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:43:44,762 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.length
2021-03-12 01:43:44,762 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:43:44,762 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:43:44,895 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:43:44,897 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.compareTo("oiexy")
2021-03-12 01:43:44,897 [main:114] - replacement of prope5 of type Int is (MyClass::class).qualifiedName?.compareTo("oiexy")
2021-03-12 01:43:45,023 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:43:45,023 [main:66] - Compilation checking started
2021-03-12 01:43:45,465 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + (MyClass::class).qualifiedName?.compareTo("oiexy"))
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:45,468 [main:107] - replacing (prope2.getOrThrow(), Any?)
2021-03-12 01:43:45,469 [main:50] - replacing prope2.getOrThrow() Any?
2021-03-12 01:43:45,469 [main:54] - Getting value of type Any?
2021-03-12 01:43:45,618 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:43:45,618 [main:58] - GENERATED VALUE OF TYPE Any? = "namuu"
2021-03-12 01:43:45,618 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:47,322 [main:67] - randomType = LinkedHashMap<Triple<Float, Long?, Kla3<Kla5>>?, Kla3<Sequence<Char>>>?
2021-03-12 01:43:47,498 [main:302] - generating value of type = LinkedHashMap<Triple<Float, Long?, Kla3<Kla5>>?, Kla3<Sequence<Char>>> false depth = 0
2021-03-12 01:43:47,664 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): LkedHashMap<Triple<Float, Long?, Kla3<Kla5>>?, Kla3<Sequence<Char>>> = TODO()
2021-03-12 01:43:47,667 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): LkedHashMap<Triple<Float, Long?, Kla3<Kla5>>?, Kla3<Sequence<Char>>> = TODO()
2021-03-12 01:43:47,802 [main:95] - GENERATED = linkedMapOf<Triple<Float, Long?, Kla3<Kla5>>?, Kla3<Sequence<Char>>>()
2021-03-12 01:43:48,079 [main:106] - GETTING Any? from KClass<Ann>
2021-03-12 01:43:48,094 [main:106] - GETTING Any? from String
2021-03-12 01:43:48,126 [main:106] - GETTING Any? from KClass<MyClass>
2021-03-12 01:43:48,138 [main:114] - replacement of prope2.getOrThrow() of type Any? is "namuu"
2021-03-12 01:43:48,272 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 01:43:48,272 [main:66] - Compilation checking started
2021-03-12 01:43:48,689 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = "namuu"
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:48,691 [main:107] - replacing (prope3?.fu3() ?: 0, Int)
2021-03-12 01:43:48,691 [main:50] - replacing prope3?.fu3() ?: 0 Int
2021-03-12 01:43:48,691 [main:54] - Getting value of type Int
2021-03-12 01:43:48,818 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:48,820 [main:58] - GENERATED VALUE OF TYPE Int = -908931004
2021-03-12 01:43:48,820 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:48,956 [main:67] - randomType = Byte
2021-03-12 01:43:49,084 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:43:49,141 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@a928e3a]
2021-03-12 01:43:49,278 [main:302] - generating value of type = Float true depth = 0
2021-03-12 01:43:49,280 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@fed54a6]
2021-03-12 01:43:49,281 [main:78] - Generated call from random type = (24).div(0.7944336f).toBits()
2021-03-12 01:43:49,282 [main:106] - GETTING Int from KClass<Ann>
2021-03-12 01:43:49,294 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:43:49,294 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.length
2021-03-12 01:43:49,294 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:43:49,294 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:43:49,442 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:43:49,443 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:43:49,572 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:49,574 [main:117] - GENERATED CALL = (Ann::class).equals("azghy").compareTo(false)
2021-03-12 01:43:49,574 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:43:49,574 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:43:49,575 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.compareTo(val argName2 = args[1].simpleName ?: "fail 2"
2021-03-12 01:43:49,575 [main:114] - replacement of prope3?.fu3() ?: 0 of type Int is -908931004
2021-03-12 01:43:49,705 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 01:43:49,705 [main:66] - Compilation checking started
2021-03-12 01:43:50,170 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (-908931004)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:50,172 [main:107] - replacing (42, Int)
2021-03-12 01:43:50,172 [main:50] - replacing 42 Int
2021-03-12 01:43:50,172 [main:54] - Getting value of type Int
2021-03-12 01:43:50,295 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:50,297 [main:58] - GENERATED VALUE OF TYPE Int = 1338812110
2021-03-12 01:43:50,297 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:50,583 [main:67] - randomType = ULong?
2021-03-12 01:43:50,706 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 01:43:50,748 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@259e0b1]
2021-03-12 01:43:50,880 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 01:43:50,882 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@36923503]
2021-03-12 01:43:51,015 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:51,017 [main:78] - Generated call from random type = (1713406217516233046.toULong())?.compareTo(53.toUByte()).xor(-413925058)
2021-03-12 01:43:51,017 [main:114] - replacement of 42 of type Int is (1713406217516233046.toULong())?.compareTo(53.toUByte()).xor(-413925058)
2021-03-12 01:43:51,152 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:51,152 [main:66] - Compilation checking started
2021-03-12 01:43:51,563 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = (1713406217516233046.toULong())?.compareTo(53.toUByte()).xor(-413925058) + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:51,567 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 01:43:51,567 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 01:43:51,567 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 01:43:51,724 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 01:43:51,734 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 01:43:52,816 [main:67] - randomType = Map<Long, List<LinkedHashMap<String?, Ann?>>?>
2021-03-12 01:43:52,818 [main:106] - GETTING EmptyCoroutineContext from KClass<MyClass>
2021-03-12 01:43:52,830 [main:106] - GETTING EmptyCoroutineContext from String
2021-03-12 01:43:52,858 [main:106] - GETTING EmptyCoroutineContext from KClass<Ann>
2021-03-12 01:43:52,869 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 01:43:52,869 [main:107] - replacing (prope2.exceptionOrNull(), Throwable?)
2021-03-12 01:43:52,870 [main:50] - replacing prope2.exceptionOrNull() Throwable?
2021-03-12 01:43:52,870 [main:54] - Getting value of type Throwable?
2021-03-12 01:43:52,999 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 01:43:53,006 [main:58] - GENERATED VALUE OF TYPE Throwable? = UninitializedPropertyAccessException()
2021-03-12 01:43:53,006 [main:61] - GENERATED IS CALL =true
2021-03-12 01:43:53,151 [main:67] - randomType = Double
2021-03-12 01:43:53,278 [main:302] - generating value of type = Double true depth = 0
2021-03-12 01:43:53,326 [main:106] - GETTING Throwable? from KClass<MyClass>
2021-03-12 01:43:53,339 [main:106] - GETTING Throwable? from String
2021-03-12 01:43:53,373 [main:106] - GETTING Throwable? from KClass<Ann>
2021-03-12 01:43:53,385 [main:114] - replacement of prope2.exceptionOrNull() of type Throwable? is UninitializedPropertyAccessException()
2021-03-12 01:43:53,519 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:43:53,520 [main:66] - Compilation checking started
2021-03-12 01:43:53,915 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
UninitializedPropertyAccessException()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:53,917 [main:107] - replacing (0, Int)
2021-03-12 01:43:53,917 [main:50] - replacing 0 Int
2021-03-12 01:43:53,917 [main:54] - Getting value of type Int
2021-03-12 01:43:54,044 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:43:54,046 [main:58] - GENERATED VALUE OF TYPE Int = 485558749
2021-03-12 01:43:54,046 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:54,465 [main:67] - randomType = Pair<Float, Byte>
2021-03-12 01:43:54,589 [main:302] - generating value of type = Pair<Float, Byte> false depth = 0
2021-03-12 01:43:54,753 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Float, second: Byte): Pair<Float, Byte> = TODO()
2021-03-12 01:43:54,756 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Float, second: Byte): Pair<Float, Byte> = TODO()
2021-03-12 01:43:54,896 [main:302] - generating value of type = Float true depth = 3
2021-03-12 01:43:54,899 [main:302] - generating value of type = Byte true depth = 3
2021-03-12 01:43:54,901 [main:95] - GENERATED = Pair<Float, Byte>(0.37178028f, -70)
2021-03-12 01:43:54,917 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Float.roundToInt(): kotlin.Int defined in kotlin.math[DeserializedSimpleFunctionDescriptor@50e2cca5]
2021-03-12 01:43:54,917 [main:78] - Generated call from random type = (Pair<Float, Byte>(0.37178028f, -70)).first.roundToInt()
2021-03-12 01:43:54,918 [main:106] - GETTING Int from KClass<Ann>
2021-03-12 01:43:54,931 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:43:54,931 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:43:55,061 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:43:55,061 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:43:55,182 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:43:55,184 [main:117] - GENERATED CALL = (Ann::class).equals("geiao").compareTo(false)
2021-03-12 01:43:55,185 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:43:55,185 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:43:55,185 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.compareTo(argName1)
2021-03-12 01:43:55,185 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:43:55,185 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.length
2021-03-12 01:43:55,185 [main:114] - replacement of 0 of type Int is (Pair<Float, Byte>(0.37178028f, -70)).first.roundToInt()
2021-03-12 01:43:55,307 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:43:55,308 [main:66] - Compilation checking started
2021-03-12 01:43:55,694 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = (Pair<Float, Byte>(0.37178028f, -70)).first.roundToInt()
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:55,696 [main:107] - replacing (prope7, Function0<Unit>)
2021-03-12 01:43:55,697 [main:50] - replacing prope7 Function0<Unit>
2021-03-12 01:43:55,697 [main:54] - Getting value of type Function0<Unit>
2021-03-12 01:43:55,842 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 01:43:55,844 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:43:55,980 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 01:43:55,984 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 01:43:56,256 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 01:43:56,258 [main:95] - GENERATED = check(true)
2021-03-12 01:43:56,259 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { check(true)}
2021-03-12 01:43:56,259 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:56,686 [main:67] - randomType = HashMap<Ann, Long?>
2021-03-12 01:43:56,833 [main:302] - generating value of type = HashMap<Ann, Long?> false depth = 0
2021-03-12 01:43:57,002 [main:43] - GENERATING CALL OF fun <K, V> hashMapOf(): HashMap<Ann, Long?> = TODO()
2021-03-12 01:43:57,005 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> hashMapOf(): HashMap<Ann, Long?> = TODO()
2021-03-12 01:43:57,134 [main:95] - GENERATED = hashMapOf<Ann, Long?>()
2021-03-12 01:43:57,258 [main:106] - GETTING Function0<Unit> from KClass<MyClass>
2021-03-12 01:43:57,272 [main:106] - GETTING Function0<Unit> from String
2021-03-12 01:43:57,304 [main:106] - GETTING Function0<Unit> from KClass<Ann>
2021-03-12 01:43:57,315 [main:114] - replacement of prope7 of type Function0<Unit> is { check(true)}
2021-03-12 01:43:57,440 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 01:43:57,440 [main:66] - Compilation checking started
2021-03-12 01:43:57,806 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.{ check(true)} = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:43:57,808 [main:107] - replacing ({
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }, SuspendFunction0<Unit>)
2021-03-12 01:43:57,808 [main:50] - replacing {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    } SuspendFunction0<Unit>
2021-03-12 01:43:57,808 [main:54] - Getting value of type SuspendFunction0<Unit>
2021-03-12 01:43:57,941 [main:302] - generating value of type = SuspendFunction0<Unit> false depth = 0
2021-03-12 01:43:57,943 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:43:58,075 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 01:43:58,078 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 01:43:58,492 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 01:43:58,495 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 01:43:58,498 [main:302] - generating value of type = Any false depth = 5
2021-03-12 01:43:58,498 [main:95] - GENERATED = check(true, { "qkpek"})
2021-03-12 01:43:58,498 [main:58] - GENERATED VALUE OF TYPE SuspendFunction0<Unit> = { check(true, { "qkpek"})}
2021-03-12 01:43:58,499 [main:61] - GENERATED IS CALL =false
2021-03-12 01:43:59,258 [main:67] - randomType = ArrayList<Set<Short?>>?
2021-03-12 01:43:59,384 [main:302] - generating value of type = ArrayList<Set<Short?>> false depth = 0
2021-03-12 01:43:59,525 [main:43] - GENERATING CALL OF fun <E> ArrayList(elements: kotlin.collections.Collection<Set<Short?>>): ArrayList<Set<Short?>> = TODO()
2021-03-12 01:43:59,529 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayList(elements: kotlin.collections.Collection<Set<Short?>>): ArrayList<Set<Short?>> = TODO()
2021-03-12 01:43:59,859 [main:302] - generating value of type = Collection<Set<Short?>> false depth = 3
2021-03-12 01:43:59,988 [main:43] - GENERATING CALL OF fun <T> MutableList(size: kotlin.Int, init: (index: kotlin.Int)->Set<Short?>): Collection<Set<Short?>> = TODO()
2021-03-12 01:43:59,991 [main:61] - WITHOUT TYPE PARAMS = fun <T> MutableList(size: kotlin.Int, init: (index: kotlin.Int)->Set<Short?>): Collection<Set<Short?>> = TODO()
2021-03-12 01:44:00,407 [main:302] - generating value of type = Int true depth = 6
2021-03-12 01:44:00,409 [main:302] - generating value of type = Function1<[@kotlin.ParameterName] Int, Set<Short?>> false depth = 6
2021-03-12 01:44:00,411 [main:302] - generating value of type = Set<Short?> false depth = 7
2021-03-12 01:44:00,579 [main:43] - GENERATING CALL OF fun <E> HashSet(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): Set<Short?> = TODO()
2021-03-12 01:44:00,583 [main:61] - WITHOUT TYPE PARAMS = fun <E> HashSet(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): Set<Short?> = TODO()
2021-03-12 01:44:00,992 [main:302] - generating value of type = Int true depth = 10
2021-03-12 01:44:00,994 [main:302] - generating value of type = Float true depth = 10
2021-03-12 01:44:00,996 [main:95] - GENERATED = HashSet<Short?>(1842470095, 0.49477172f)
2021-03-12 01:44:00,996 [main:95] - GENERATED = MutableList<Set<Short?>>(1793729051, {a: Int -> HashSet<Short?>(1842470095, 0.49477172f)})
2021-03-12 01:44:00,997 [main:95] - GENERATED = ArrayList<Set<Short?>>(MutableList<Set<Short?>>(1793729051, {a: Int -> HashSet<Short?>(1842470095, 0.49477172f)}))
2021-03-12 01:44:01,155 [main:106] - GETTING SuspendFunction0<Unit> from KClass<MyClass>
2021-03-12 01:44:01,164 [main:106] - GETTING SuspendFunction0<Unit> from KClass<Ann>
2021-03-12 01:44:01,172 [main:106] - GETTING SuspendFunction0<Unit> from String
2021-03-12 01:44:01,191 [main:114] - replacement of {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    } of type SuspendFunction0<Unit> is { check(true, { "qkpek"})}
2021-03-12 01:44:01,314 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 01:44:01,314 [main:66] - Compilation checking started
2021-03-12 01:44:01,691 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 { check(true, { "qkpek"})}

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:01,694 [main:107] - replacing ("Wrong state-machine generated: it is finished early", String)
2021-03-12 01:44:01,694 [main:50] - replacing "Wrong state-machine generated: it is finished early" String
2021-03-12 01:44:01,694 [main:54] - Getting value of type String
2021-03-12 01:44:01,816 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:01,818 [main:58] - GENERATED VALUE OF TYPE String = "izwkw"
2021-03-12 01:44:01,819 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:01,826 [main:67] - randomType = Ann
2021-03-12 01:44:01,953 [main:302] - generating value of type = Ann false depth = 0
2021-03-12 01:44:01,955 [main:112] - generating klass Ann text = @Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)
2021-03-12 01:44:01,968 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.LowPriorityInOverloadResolution public fun <T> kotlin.Array<out T>.contentDeepToString(): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@74f0bfba]
2021-03-12 01:44:01,969 [main:78] - Generated call from random type = ().args.contentDeepToString()
2021-03-12 01:44:01,970 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:44:01,983 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:44:01,983 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:44:01,983 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:44:01,983 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:44:01,983 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:44:02,114 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:02,114 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("ywbrd")
2021-03-12 01:44:02,114 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:44:02,114 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:44:02,115 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:44:02,115 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:44:02,115 [main:114] - replacement of "Wrong state-machine generated: it is finished early" of type String is ().args.contentDeepToString()
2021-03-12 01:44:02,240 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:02,240 [main:66] - Compilation checking started
2021-03-12 01:44:02,244 [main:71] - Wrong syntax or breaks conditions
2021-03-12 01:44:02,245 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error(().args.contentDeepToString())
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:02,246 [main:107] - replacing (prope2, Int)
2021-03-12 01:44:02,247 [main:50] - replacing prope2 Int
2021-03-12 01:44:02,247 [main:54] - Getting value of type Int
2021-03-12 01:44:02,371 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:02,373 [main:58] - GENERATED VALUE OF TYPE Int = -1559614001
2021-03-12 01:44:02,373 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:02,520 [main:67] - randomType = Kla3<String>
2021-03-12 01:44:02,640 [main:302] - generating value of type = Kla3<String> false depth = 0
2021-03-12 01:44:02,642 [main:112] - generating klass Kla3 text = abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 01:44:03,353 [main:302] - generating value of type = Kla6 false depth = 2
2021-03-12 01:44:03,355 [main:112] - generating klass Kla6 text = object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}
2021-03-12 01:44:03,378 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla3[DeserializedSimpleFunctionDescriptor@6c0aa12f]
2021-03-12 01:44:03,525 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:03,525 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:03,675 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:03,678 [main:78] - Generated call from random type = (Kla6).equals("nuwga").compareTo(true)
2021-03-12 01:44:03,679 [main:106] - GETTING Int from KClass<MyClass>
2021-03-12 01:44:03,690 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:44:03,691 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:44:03,810 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:03,812 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.compareTo("aqmkc")
2021-03-12 01:44:03,812 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:44:03,813 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.length
2021-03-12 01:44:03,813 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:44:03,813 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:03,932 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:03,932 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:04,051 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:04,053 [main:117] - GENERATED CALL = (MyClass::class).equals("qzlgs").compareTo(true)
2021-03-12 01:44:04,053 [main:114] - replacement of prope2 of type Int is (Kla6).equals("nuwga").compareTo(true)
2021-03-12 01:44:04,171 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:04,171 [main:66] - Compilation checking started
2021-03-12 01:44:04,533 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        (Kla6).equals("nuwga").compareTo(true) = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:04,535 [main:107] - replacing (" has no state-machine ", String)
2021-03-12 01:44:04,536 [main:50] - replacing " has no state-machine " String
2021-03-12 01:44:04,536 [main:54] - Getting value of type String
2021-03-12 01:44:04,663 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:04,665 [main:58] - GENERATED VALUE OF TYPE String = "ribak"
2021-03-12 01:44:04,665 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:04,800 [main:67] - randomType = UInt
2021-03-12 01:44:04,928 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 01:44:04,975 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UInt.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6d460007]
2021-03-12 01:44:05,108 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:05,110 [main:78] - Generated call from random type = (549966204.toUInt()).toString(93481014)
2021-03-12 01:44:05,112 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:44:05,125 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:44:05,125 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:44:05,255 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:05,256 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("xnqwj")
2021-03-12 01:44:05,256 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:44:05,256 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:44:05,256 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:44:05,256 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:44:05,256 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:44:05,256 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:44:05,256 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:44:05,256 [main:114] - replacement of " has no state-machine " of type String is (Ann::class).qualifiedName?.plus("xnqwj")
2021-03-12 01:44:05,385 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:44:05,386 [main:66] - Compilation checking started
2021-03-12 01:44:05,798 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + (Ann::class).qualifiedName?.plus("xnqwj") +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:05,800 [main:107] - replacing (true, Boolean)
2021-03-12 01:44:05,801 [main:50] - replacing true Boolean
2021-03-12 01:44:05,801 [main:54] - Getting value of type Boolean
2021-03-12 01:44:05,943 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:05,945 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 01:44:05,945 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:06,085 [main:67] - randomType = UShort
2021-03-12 01:44:06,206 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 01:44:06,252 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@1edf47dc]
2021-03-12 01:44:06,382 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:06,382 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]
2021-03-12 01:44:06,382 [main:78] - Generated call from random type = (31493.toUShort()).equals("agksy").not()
2021-03-12 01:44:06,383 [main:114] - replacement of true of type Boolean is (31493.toUShort()).equals("agksy").not()
2021-03-12 01:44:06,514 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:06,514 [main:66] - Compilation checking started
2021-03-12 01:44:06,904 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = (31493.toUShort()).equals("agksy").not()) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:06,905 [main:107] - replacing (i, Int)
2021-03-12 01:44:06,906 [main:50] - replacing i Int
2021-03-12 01:44:06,906 [main:54] - Getting value of type Int
2021-03-12 01:44:07,036 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:07,037 [main:58] - GENERATED VALUE OF TYPE Int = -1790498587
2021-03-12 01:44:07,038 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:07,170 [main:67] - randomType = Char
2021-03-12 01:44:07,289 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:07,314 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@5856de23]
2021-03-12 01:44:07,438 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:07,440 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@798cb469]
2021-03-12 01:44:07,440 [main:78] - Generated call from random type = ('믠').compareTo('끰').takeLowestOneBit()
2021-03-12 01:44:07,441 [main:106] - GETTING Int from String
2021-03-12 01:44:07,467 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@5856de23]]
2021-03-12 01:44:07,467 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:44:07,587 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:07,589 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@5856de23]
2021-03-12 01:44:07,709 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:07,711 [main:117] - GENERATED CALL = (argName1).get(-350456497).compareTo('홢')
2021-03-12 01:44:07,711 [main:113] - Case = [public fun kotlin.CharSequence.indexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@f5b882b]]
2021-03-12 01:44:07,711 [main:149] - GENERATING call of type public fun kotlin.CharSequence.indexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@f5b882b]
2021-03-12 01:44:07,831 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:07,950 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:08,089 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:08,102 [main:117] - GENERATED CALL = (argName1).indexOf('眸', 48054658, false)
2021-03-12 01:44:08,102 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2b4d25cd]]
2021-03-12 01:44:08,102 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2b4d25cd]
2021-03-12 01:44:08,103 [main:117] - GENERATED CALL = (argName1).length.inc()
2021-03-12 01:44:08,103 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@49454830]]
2021-03-12 01:44:08,103 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@49454830]
2021-03-12 01:44:08,228 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:08,230 [main:117] - GENERATED CALL = (argName1).length.and(-472477501)
2021-03-12 01:44:08,230 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.String.compareTo(other: kotlin.String, ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4c03a05a]]
2021-03-12 01:44:08,230 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String.compareTo(other: kotlin.String, ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4c03a05a]
2021-03-12 01:44:08,347 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:08,349 [main:117] - GENERATED CALL = (argName1).compareTo(val argName1 = args[0].simpleName ?: "fail 1"
2021-03-12 01:44:08,349 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@38e09b9f]]
2021-03-12 01:44:08,350 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@38e09b9f]
2021-03-12 01:44:08,471 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:08,473 [main:117] - GENERATED CALL = (argName1).length.rotateLeft(8520992)
2021-03-12 01:44:08,475 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@79641072]]
2021-03-12 01:44:08,475 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:44:08,476 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@79641072]
2021-03-12 01:44:08,476 [main:117] - GENERATED CALL = (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".countLeadingZeroBits()
2021-03-12 01:44:08,476 [main:113] - Case = [public fun kotlin.String.toInt(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5aeaa4ff]]
2021-03-12 01:44:08,476 [main:149] - GENERATING call of type public fun kotlin.String.toInt(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5aeaa4ff]
2021-03-12 01:44:08,476 [main:117] - GENERATED CALL = (argName1).toInt()
2021-03-12 01:44:08,476 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]]
2021-03-12 01:44:08,476 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:44:08,593 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:08,711 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:08,713 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]
2021-03-12 01:44:08,713 [main:117] - GENERATED CALL = (argName1).subSequence(371206528, 1292744199).count()
2021-03-12 01:44:08,713 [main:113] - Case = [public inline fun kotlin.CharSequence.sumBy(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6a73f254]]
2021-03-12 01:44:08,713 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.sumBy(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6a73f254]
2021-03-12 01:44:08,849 [main:302] - generating value of type = Function1<Char, Int> false depth = 0
2021-03-12 01:44:08,851 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:44:08,854 [main:117] - GENERATED CALL = (argName1).sumBy({a: Char -> 694611756})
2021-03-12 01:44:08,854 [main:114] - replacement of i of type Int is (argName1).compareTo(val argName1 = args[0].simpleName ?: "fail 1"
2021-03-12 01:44:08,985 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BINARY_EXPRESSION)
2021-03-12 01:44:08,986 [main:66] - Compilation checking started
2021-03-12 01:44:08,990 [main:71] - Wrong syntax or breaks conditions
2021-03-12 01:44:08,990 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + (argName1).compareTo(val argName1 = args[0].simpleName ?: "fail 1" + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:08,992 [main:107] - replacing (c, Continuation<*>)
2021-03-12 01:44:08,993 [main:50] - replacing c Continuation<*>
2021-03-12 01:44:08,993 [main:54] - Getting value of type Continuation<*>
2021-03-12 01:44:09,121 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 01:44:09,250 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:09,253 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:09,653 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 01:44:09,824 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:09,827 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:10,096 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 01:44:10,226 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:10,229 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:10,681 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:10,682 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:10,682 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:10,682 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 01:44:11,986 [main:67] - randomType = Triple<Int, LinkedHashMap<Kla3<Char>, Sequence<Byte>>, Short?>
2021-03-12 01:44:12,105 [main:302] - generating value of type = Triple<Int, LinkedHashMap<Kla3<Char>, Sequence<Byte>>, Short?> false depth = 0
2021-03-12 01:44:12,231 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Int, second: LinkedHashMap<Kla3<Char>, Sequence<Byte>>, third: Short?): Triple<Int, LinkedHashMap<Kla3<Char>, Sequence<Byte>>, Short?> = TODO()
2021-03-12 01:44:12,233 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Int, second: LinkedHashMap<Kla3<Char>, Sequence<Byte>>, third: Short?): Triple<Int, LinkedHashMap<Kla3<Char>, Sequence<Byte>>, Short?> = TODO()
2021-03-12 01:44:12,358 [main:302] - generating value of type = Int true depth = 3
2021-03-12 01:44:12,360 [main:302] - generating value of type = LinkedHashMap<Kla3<Char>, Sequence<Byte>> false depth = 3
2021-03-12 01:44:12,506 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(pairs: Pair<Kla3<Char>, Sequence<Byte>>): LkedHashMap<Kla3<Char>, Sequence<Byte>> = TODO()
2021-03-12 01:44:12,509 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(pairs: Pair<Kla3<Char>, Sequence<Byte>>): LkedHashMap<Kla3<Char>, Sequence<Byte>> = TODO()
2021-03-12 01:44:12,649 [main:302] - generating value of type = Pair<Kla3<Char>, Sequence<Byte>> false depth = 6
2021-03-12 01:44:12,774 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla3<Char>, second: Sequence<Byte>): Pair<Kla3<Char>, Sequence<Byte>> = TODO()
2021-03-12 01:44:12,777 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla3<Char>, second: Sequence<Byte>): Pair<Kla3<Char>, Sequence<Byte>> = TODO()
2021-03-12 01:44:12,902 [main:302] - generating value of type = Kla3<Char> false depth = 9
2021-03-12 01:44:12,904 [main:112] - generating klass Kla3 text = abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 01:44:13,614 [main:302] - generating value of type = Kla6 false depth = 11
2021-03-12 01:44:13,616 [main:112] - generating klass Kla6 text = object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}
2021-03-12 01:44:13,619 [main:302] - generating value of type = Sequence<Byte> false depth = 9
2021-03-12 01:44:13,744 [main:43] - GENERATING CALL OF fun <T> sequenceOf(elements: Byte): Sequence<Byte> = TODO()
2021-03-12 01:44:13,747 [main:61] - WITHOUT TYPE PARAMS = fun <T> sequenceOf(elements: Byte): Sequence<Byte> = TODO()
2021-03-12 01:44:13,868 [main:302] - generating value of type = Byte true depth = 12
2021-03-12 01:44:13,870 [main:95] - GENERATED = sequenceOf<Byte>(-22)
2021-03-12 01:44:13,870 [main:95] - GENERATED = Pair<Kla3<Char>, Sequence<Byte>>(Kla6, sequenceOf<Byte>(-22))
2021-03-12 01:44:13,871 [main:95] - GENERATED = linkedMapOf<Kla3<Char>, Sequence<Byte>>(Pair<Kla3<Char>, Sequence<Byte>>(Kla6, sequenceOf<Byte>(-22)))
2021-03-12 01:44:13,871 [main:302] - generating value of type = Short true depth = 3
2021-03-12 01:44:13,873 [main:95] - GENERATED = Triple<Int, LinkedHashMap<Kla3<Char>, Sequence<Byte>>, Short?>(-1521147129, linkedMapOf<Kla3<Char>, Sequence<Byte>>(Pair<Kla3<Char>, Sequence<Byte>>(Kla6, sequenceOf<Byte>(-22))), -24972)
2021-03-12 01:44:13,900 [main:106] - GETTING Continuation<*> from KClass<Ann>
2021-03-12 01:44:13,908 [main:106] - GETTING Continuation<*> from String
2021-03-12 01:44:13,927 [main:106] - GETTING Continuation<*> from KClass<MyClass>
2021-03-12 01:44:13,934 [main:111] - Cant find and generate replacement for c type Continuation<*>
2021-03-12 01:44:13,934 [main:107] - replacing (42, Int)
2021-03-12 01:44:13,934 [main:50] - replacing 42 Int
2021-03-12 01:44:13,934 [main:54] - Getting value of type Int
2021-03-12 01:44:14,051 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:14,053 [main:58] - GENERATED VALUE OF TYPE Int = -1695059508
2021-03-12 01:44:14,053 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:14,061 [main:67] - randomType = Ann
2021-03-12 01:44:14,177 [main:302] - generating value of type = Ann false depth = 0
2021-03-12 01:44:14,179 [main:112] - generating klass Ann text = @Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)
2021-03-12 01:44:14,189 [main:149] - GENERATING call of type public inline fun <T> kotlin.Array<out T>.sumBy(selector: (T) -> kotlin.Int): kotlin.Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@31943acd]
2021-03-12 01:44:14,326 [main:302] - generating value of type = Function1<T, Int> false depth = 0
2021-03-12 01:44:14,328 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:44:14,330 [main:78] - Generated call from random type = ().args.sumBy({a: T -> -729148549})
2021-03-12 01:44:14,331 [main:106] - GETTING Int from String
2021-03-12 01:44:14,373 [main:113] - Case = [public val kotlin.CharSequence.lastIndex: kotlin.Int defined in kotlin.text[DeserializedPropertyDescriptor@69826c32]]
2021-03-12 01:44:14,373 [main:117] - GENERATED CALL = (argName1).lastIndex
2021-03-12 01:44:14,373 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@645cceaa]]
2021-03-12 01:44:14,373 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@645cceaa]
2021-03-12 01:44:14,373 [main:117] - GENERATED CALL = (argName1).length.dec()
2021-03-12 01:44:14,373 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2aabdce6]]
2021-03-12 01:44:14,373 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2aabdce6]
2021-03-12 01:44:14,374 [main:117] - GENERATED CALL = (argName1).length.unaryPlus()
2021-03-12 01:44:14,374 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@798cb469]]
2021-03-12 01:44:14,374 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:44:14,374 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@798cb469]
2021-03-12 01:44:14,374 [main:117] - GENERATED CALL = (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".takeLowestOneBit()
2021-03-12 01:44:14,374 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], @kotlin.ExperimentalStdlibApi @kotlin.SinceKotlin public fun kotlin.Char.digitToInt(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9d2bfbe]]
2021-03-12 01:44:14,374 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:44:14,499 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:14,501 [main:149] - GENERATING call of type @kotlin.ExperimentalStdlibApi @kotlin.SinceKotlin public fun kotlin.Char.digitToInt(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9d2bfbe]
2021-03-12 01:44:14,501 [main:117] - GENERATED CALL = (argName1).get(2003280719).digitToInt()
2021-03-12 01:44:14,501 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@79641072]]
2021-03-12 01:44:14,501 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@79641072]
2021-03-12 01:44:14,501 [main:117] - GENERATED CALL = (argName1).length.countLeadingZeroBits()
2021-03-12 01:44:14,501 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.lastIndexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@864e36e]]
2021-03-12 01:44:14,501 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:44:14,621 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:14,740 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:14,742 [main:149] - GENERATING call of type public fun kotlin.CharSequence.lastIndexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@864e36e]
2021-03-12 01:44:14,859 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:14,981 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:15,104 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:15,106 [main:117] - GENERATED CALL = (argName1).subSequence(-96303877, 279616974).lastIndexOf('逡', 4856914, true)
2021-03-12 01:44:15,106 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ee76b77]]
2021-03-12 01:44:15,106 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ee76b77]
2021-03-12 01:44:15,251 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:44:15,254 [main:117] - GENERATED CALL = (argName1).length.compareTo(-47)
2021-03-12 01:44:15,254 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.sumOf(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36df585a]]
2021-03-12 01:44:15,254 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.sumOf(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36df585a]
2021-03-12 01:44:15,392 [main:302] - generating value of type = Function1<Char, Int> false depth = 0
2021-03-12 01:44:15,394 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:44:15,396 [main:117] - GENERATED CALL = (argName1).sumOf({a: Char -> -490301125})
2021-03-12 01:44:15,396 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@36923503]]
2021-03-12 01:44:15,396 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:44:15,397 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@36923503]
2021-03-12 01:44:15,514 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:15,516 [main:117] - GENERATED CALL = (argName1).compareTo(argName1).xor(-532525857)
2021-03-12 01:44:15,516 [main:114] - replacement of 42 of type Int is (argName1).subSequence(-96303877, 279616974).lastIndexOf('逡', 4856914, true)
2021-03-12 01:44:15,632 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:15,633 [main:66] - Compilation checking started
2021-03-12 01:44:16,044 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != (argName1).subSequence(-96303877, 279616974).lastIndexOf('逡', 4856914, true)) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:16,046 [main:107] - replacing ({ c.resume(Unit) }, Function0<Unit>)
2021-03-12 01:44:16,046 [main:50] - replacing { c.resume(Unit) } Function0<Unit>
2021-03-12 01:44:16,046 [main:54] - Getting value of type Function0<Unit>
2021-03-12 01:44:16,172 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 01:44:16,174 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:44:16,180 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println()}
2021-03-12 01:44:16,180 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:16,187 [main:67] - randomType = Kla5
2021-03-12 01:44:16,307 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 01:44:16,309 [main:112] - generating klass Kla5 text = class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 01:44:16,318 [main:78] - Generated call from random type = (Kla5()).prope7
2021-03-12 01:44:16,319 [main:106] - GETTING Function0<Unit> from KClass<Ann>
2021-03-12 01:44:16,328 [main:106] - GETTING Function0<Unit> from KClass<MyClass>
2021-03-12 01:44:16,348 [main:106] - GETTING Function0<Unit> from String
2021-03-12 01:44:16,369 [main:114] - replacement of { c.resume(Unit) } of type Function0<Unit> is (Kla5()).prope7
2021-03-12 01:44:16,487 [main:33] - Trying to replace LAMBDA_EXPRESSION on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:16,487 [main:66] - Compilation checking started
2021-03-12 01:44:16,839 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = (Kla5()).prope7
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:16,841 [main:107] - replacing (prope5, Int)
2021-03-12 01:44:16,841 [main:50] - replacing prope5 Int
2021-03-12 01:44:16,841 [main:54] - Getting value of type Int
2021-03-12 01:44:16,962 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:16,964 [main:58] - GENERATED VALUE OF TYPE Int = 270806643
2021-03-12 01:44:16,964 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:17,525 [main:67] - randomType = Set<Function1<K, Char>>
2021-03-12 01:44:17,526 [main:106] - GETTING Int from KClass<Ann>
2021-03-12 01:44:17,534 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:44:17,534 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:17,655 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:17,655 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:17,772 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:17,774 [main:117] - GENERATED CALL = (Ann::class).equals("khsgp").compareTo(false)
2021-03-12 01:44:17,774 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:44:17,774 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.length
2021-03-12 01:44:17,774 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:44:17,775 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:44:17,891 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:17,893 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.compareTo("lfwlx")
2021-03-12 01:44:17,893 [main:114] - replacement of prope5 of type Int is (Ann::class).equals("khsgp").compareTo(false)
2021-03-12 01:44:18,008 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:18,009 [main:66] - Compilation checking started
2021-03-12 01:44:18,366 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if ((Ann::class).equals("khsgp").compareTo(false) != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:18,369 [main:107] - replacing (prope6, Boolean)
2021-03-12 01:44:18,369 [main:50] - replacing prope6 Boolean
2021-03-12 01:44:18,369 [main:54] - Getting value of type Boolean
2021-03-12 01:44:18,499 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:18,501 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 01:44:18,501 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:18,796 [main:67] - randomType = Kla3<MyClass>
2021-03-12 01:44:18,920 [main:302] - generating value of type = Kla3<MyClass> false depth = 0
2021-03-12 01:44:18,922 [main:112] - generating klass Kla3 text = abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 01:44:20,311 [main:302] - generating value of type = Kla6 false depth = 2
2021-03-12 01:44:20,313 [main:112] - generating klass Kla6 text = object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}
2021-03-12 01:44:20,326 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla3[DeserializedSimpleFunctionDescriptor@2b75e29a]
2021-03-12 01:44:20,444 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:20,445 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:44:20,565 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:20,567 [main:78] - Generated call from random type = (Kla6).equals("lzuol").xor(false)
2021-03-12 01:44:20,567 [main:114] - replacement of prope6 of type Boolean is (Kla6).equals("lzuol").xor(false)
2021-03-12 01:44:20,686 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:20,686 [main:66] - Compilation checking started
2021-03-12 01:44:21,057 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if ((Kla6).equals("lzuol").xor(false)) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:21,059 [main:107] - replacing (prope3?.fu3() ?: 0, Int)
2021-03-12 01:44:21,059 [main:50] - replacing prope3?.fu3() ?: 0 Int
2021-03-12 01:44:21,059 [main:54] - Getting value of type Int
2021-03-12 01:44:21,178 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:21,181 [main:58] - GENERATED VALUE OF TYPE Int = 1450498152
2021-03-12 01:44:21,181 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:21,583 [main:67] - randomType = Map<ULong, UShort>
2021-03-12 01:44:21,585 [main:106] - GETTING Int from KClass<Ann>
2021-03-12 01:44:21,593 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:44:21,593 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:44:21,593 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.compareTo(argName1)
2021-03-12 01:44:21,593 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:44:21,593 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:21,713 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:21,714 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:21,830 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:21,832 [main:117] - GENERATED CALL = (Ann::class).equals("qxbuq").compareTo(false)
2021-03-12 01:44:21,832 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:44:21,832 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.length
2021-03-12 01:44:21,832 [main:114] - replacement of prope3?.fu3() ?: 0 of type Int is (Ann::class).equals("qxbuq").compareTo(false)
2021-03-12 01:44:21,949 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:21,949 [main:66] - Compilation checking started
2021-03-12 01:44:22,319 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + ((Ann::class).equals("qxbuq").compareTo(false))
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:22,321 [main:107] - replacing (prope7, Function0<Unit>)
2021-03-12 01:44:22,321 [main:50] - replacing prope7 Function0<Unit>
2021-03-12 01:44:22,321 [main:54] - Getting value of type Function0<Unit>
2021-03-12 01:44:22,441 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 01:44:22,443 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:44:22,574 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 01:44:22,577 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 01:44:22,965 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 01:44:22,967 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 01:44:22,969 [main:302] - generating value of type = Any false depth = 5
2021-03-12 01:44:22,969 [main:95] - GENERATED = require(true, { "qsrdj"})
2021-03-12 01:44:22,969 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true, { "qsrdj"})}
2021-03-12 01:44:22,969 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:23,245 [main:67] - randomType = Set<Short>
2021-03-12 01:44:23,246 [main:106] - GETTING Function0<Unit> from String
2021-03-12 01:44:23,270 [main:106] - GETTING Function0<Unit> from KClass<MyClass>
2021-03-12 01:44:23,282 [main:106] - GETTING Function0<Unit> from KClass<Ann>
2021-03-12 01:44:23,294 [main:114] - replacement of prope7 of type Function0<Unit> is { require(true, { "qsrdj"})}
2021-03-12 01:44:23,412 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 01:44:23,413 [main:66] - Compilation checking started
2021-03-12 01:44:23,831 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            { require(true, { "qsrdj"})}()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:23,833 [main:107] - replacing (prope2, Int)
2021-03-12 01:44:23,833 [main:50] - replacing prope2 Int
2021-03-12 01:44:23,833 [main:54] - Getting value of type Int
2021-03-12 01:44:23,954 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:23,956 [main:58] - GENERATED VALUE OF TYPE Int = -103622034
2021-03-12 01:44:23,956 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:24,100 [main:67] - randomType = MyClass
2021-03-12 01:44:24,224 [main:302] - generating value of type = MyClass false depth = 0
2021-03-12 01:44:24,226 [main:112] - generating klass MyClass text = @Ann(O::class, K::class) class MyClass
2021-03-12 01:44:24,230 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in MyClass[DeserializedSimpleFunctionDescriptor@3cdaec75]
2021-03-12 01:44:24,350 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:24,350 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:24,469 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:24,471 [main:78] - Generated call from random type = (MyClass()).equals("revas").compareTo(false)
2021-03-12 01:44:24,472 [main:106] - GETTING Int from KClass<Ann>
2021-03-12 01:44:24,479 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:44:24,479 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:24,599 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:24,600 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:24,721 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:24,723 [main:117] - GENERATED CALL = (Ann::class).equals("wdoyq").compareTo(true)
2021-03-12 01:44:24,723 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:44:24,723 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.length
2021-03-12 01:44:24,724 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:44:24,724 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:44:24,724 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.compareTo(argName1)
2021-03-12 01:44:24,724 [main:114] - replacement of prope2 of type Int is -103622034
2021-03-12 01:44:24,840 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 01:44:24,841 [main:66] - Compilation checking started
2021-03-12 01:44:25,210 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $-103622034"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:25,212 [main:107] - replacing (prope2, Result<Any?>)
2021-03-12 01:44:25,212 [main:50] - replacing prope2 Result<Any?>
2021-03-12 01:44:25,212 [main:54] - Getting value of type Result<Any?>
2021-03-12 01:44:25,329 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 01:44:25,452 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 01:44:25,455 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 01:44:25,707 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 01:44:25,709 [main:302] - generating value of type = Any false depth = 4
2021-03-12 01:44:25,709 [main:95] - GENERATED = runCatching<Any?>({ "webka"})
2021-03-12 01:44:25,709 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "webka"})
2021-03-12 01:44:25,709 [main:61] - GENERATED IS CALL =true
2021-03-12 01:44:25,970 [main:67] - randomType = UByte?
2021-03-12 01:44:26,089 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 01:44:26,135 [main:106] - GETTING Result<Any?> from KClass<MyClass>
2021-03-12 01:44:26,145 [main:106] - GETTING Result<Any?> from KClass<Ann>
2021-03-12 01:44:26,156 [main:106] - GETTING Result<Any?> from String
2021-03-12 01:44:26,184 [main:114] - replacement of prope2 of type Result<Any?> is runCatching<Any?>({ "webka"})
2021-03-12 01:44:26,304 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:44:26,304 [main:66] - Compilation checking started
2021-03-12 01:44:26,696 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
runCatching<Any?>({ "webka"}).exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:26,698 [main:107] - replacing ("tail-call optimization miss: method at " + it, String)
2021-03-12 01:44:26,699 [main:50] - replacing "tail-call optimization miss: method at " + it String
2021-03-12 01:44:26,699 [main:54] - Getting value of type String
2021-03-12 01:44:26,823 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:26,825 [main:58] - GENERATED VALUE OF TYPE String = "qjupy"
2021-03-12 01:44:26,825 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:26,967 [main:67] - randomType = Set<Kla1>
2021-03-12 01:44:26,968 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:44:26,979 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:44:26,979 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:44:26,979 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:44:26,979 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:44:27,109 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:27,110 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("ibxbr")
2021-03-12 01:44:27,110 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:44:27,110 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:44:27,110 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:44:27,110 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:44:27,110 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:44:27,110 [main:114] - replacement of "tail-call optimization miss: method at " + it of type String is (Ann::class).qualifiedName
2021-03-12 01:44:27,228 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:27,229 [main:66] - Compilation checking started
2021-03-12 01:44:27,596 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error((Ann::class).qualifiedName + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:27,598 [main:107] - replacing (56, Int)
2021-03-12 01:44:27,598 [main:50] - replacing 56 Int
2021-03-12 01:44:27,599 [main:54] - Getting value of type Int
2021-03-12 01:44:27,733 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:27,736 [main:58] - GENERATED VALUE OF TYPE Int = -1322235003
2021-03-12 01:44:27,736 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:27,894 [main:67] - randomType = Ann?
2021-03-12 01:44:28,013 [main:302] - generating value of type = Ann false depth = 0
2021-03-12 01:44:28,015 [main:112] - generating klass Ann text = @Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)
2021-03-12 01:44:28,026 [main:149] - GENERATING call of type @kotlin.jvm.JvmName public fun kotlin.Array<out kotlin.Byte>.sum(): kotlin.Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@57ae95ca]
2021-03-12 01:44:28,026 [main:78] - Generated call from random type = ()?.args.sum()
2021-03-12 01:44:28,026 [main:114] - replacement of 56 of type Int is ()?.args.sum()
2021-03-12 01:44:28,144 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:28,144 [main:66] - Compilation checking started
2021-03-12 01:44:28,148 [main:71] - Wrong syntax or breaks conditions
2021-03-12 01:44:28,149 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != ()?.args.sum()) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:28,150 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-12 01:44:28,150 [main:50] - replacing numberOfSuspensions Int
2021-03-12 01:44:28,151 [main:54] - Getting value of type Int
2021-03-12 01:44:28,284 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:28,286 [main:58] - GENERATED VALUE OF TYPE Int = -1776862835
2021-03-12 01:44:28,286 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:28,290 [main:67] - randomType = Boolean
2021-03-12 01:44:28,408 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:28,418 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:28,536 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:28,538 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@248f8963]
2021-03-12 01:44:28,660 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:44:28,662 [main:78] - Generated call from random type = (false).compareTo(false).rem(127)
2021-03-12 01:44:28,662 [main:114] - replacement of numberOfSuspensions of type Int is (false).compareTo(false).rem(127)
2021-03-12 01:44:28,780 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:28,781 [main:66] - Compilation checking started
2021-03-12 01:44:29,162 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..(false).compareTo(false).rem(127)) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:29,165 [main:107] - replacing (prope2, Int)
2021-03-12 01:44:29,165 [main:50] - replacing prope2 Int
2021-03-12 01:44:29,165 [main:54] - Getting value of type Int
2021-03-12 01:44:29,299 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:29,301 [main:58] - GENERATED VALUE OF TYPE Int = -1456459939
2021-03-12 01:44:29,301 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:29,756 [main:67] - randomType = List<ULong>
2021-03-12 01:44:29,757 [main:106] - GETTING Int from KClass<Ann>
2021-03-12 01:44:29,767 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:44:29,767 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:44:29,767 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.compareTo(val argName2 = args[1].simpleName ?: "fail 2"
2021-03-12 01:44:29,767 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:44:29,768 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.length
2021-03-12 01:44:29,768 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:44:29,768 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:29,885 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:29,885 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:30,001 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:30,003 [main:117] - GENERATED CALL = (Ann::class).equals("skhpo").compareTo(true)
2021-03-12 01:44:30,003 [main:114] - replacement of prope2 of type Int is (Ann::class).qualifiedName?.length
2021-03-12 01:44:30,124 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:44:30,124 [main:66] - Compilation checking started
2021-03-12 01:44:30,493 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if ((Ann::class).qualifiedName?.length != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:30,495 [main:107] - replacing ("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got ", String)
2021-03-12 01:44:30,495 [main:50] - replacing "Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " String
2021-03-12 01:44:30,495 [main:54] - Getting value of type String
2021-03-12 01:44:30,612 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:30,614 [main:58] - GENERATED VALUE OF TYPE String = "bezbv"
2021-03-12 01:44:30,614 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:30,886 [main:67] - randomType = Array<Kla2?>
2021-03-12 01:44:31,027 [main:302] - generating value of type = Array<Kla2?> false depth = 0
2021-03-12 01:44:31,149 [main:43] - GENERATING CALL OF fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->Kla2?): Array<Kla2?> = TODO()
2021-03-12 01:44:31,152 [main:61] - WITHOUT TYPE PARAMS = fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->Kla2?): Array<Kla2?> = TODO()
2021-03-12 01:44:31,538 [main:302] - generating value of type = Int true depth = 3
2021-03-12 01:44:31,540 [main:302] - generating value of type = Function1<Int, Kla2?> false depth = 3
2021-03-12 01:44:31,541 [main:302] - generating value of type = Kla2 false depth = 4
2021-03-12 01:44:31,543 [main:112] - generating klass Kla2 text = class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}
2021-03-12 01:44:31,544 [main:95] - GENERATED = Array<Kla2?>(-1038203571, {a: Int -> Kla2()})
2021-03-12 01:44:31,555 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.LowPriorityInOverloadResolution public fun <T> kotlin.Array<out T>.contentDeepToString(): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@74f0bfba]
2021-03-12 01:44:31,555 [main:78] - Generated call from random type = (Array<Kla2?>(-1038203571, {a: Int -> Kla2()})).contentDeepToString()
2021-03-12 01:44:31,555 [main:106] - GETTING String from String
2021-03-12 01:44:31,576 [main:113] - Case = [public fun kotlin.String.replaceBefore(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b7171ef]]
2021-03-12 01:44:31,576 [main:149] - GENERATING call of type public fun kotlin.String.replaceBefore(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b7171ef]
2021-03-12 01:44:31,692 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:31,695 [main:117] - GENERATED CALL = (argName1).replaceBefore('?', val argName2 = args[1].simpleName ?: "fail 2"
2021-03-12 01:44:31,695 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.substring(startIndex: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4f58059f]]
2021-03-12 01:44:31,695 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.substring(startIndex: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4f58059f]
2021-03-12 01:44:31,813 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:31,815 [main:117] - GENERATED CALL = (argName1).substring(625081654)
2021-03-12 01:44:31,815 [main:113] - Case = [public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b4bbc69]]
2021-03-12 01:44:31,815 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b4bbc69]
2021-03-12 01:44:31,932 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:44:32,053 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:32,055 [main:117] - GENERATED CALL = (argName1).commonSuffixWith("oxfwf", false)
2021-03-12 01:44:32,055 [main:113] - Case = [public fun kotlin.String.substringBeforeLast(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6df9fbd3]]
2021-03-12 01:44:32,055 [main:149] - GENERATING call of type public fun kotlin.String.substringBeforeLast(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6df9fbd3]
2021-03-12 01:44:32,176 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:32,178 [main:117] - GENERATED CALL = (argName1).substringBeforeLast('⵻', argName1)
2021-03-12 01:44:32,178 [main:113] - Case = [public fun kotlin.String.trimIndent(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@15ad0166]]
2021-03-12 01:44:32,178 [main:149] - GENERATING call of type public fun kotlin.String.trimIndent(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@15ad0166]
2021-03-12 01:44:32,178 [main:117] - GENERATED CALL = (argName1).trimIndent()
2021-03-12 01:44:32,178 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@158ccbe]]
2021-03-12 01:44:32,178 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:44:32,301 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:32,440 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:32,442 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@158ccbe]
2021-03-12 01:44:32,559 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:44:32,679 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:32,681 [main:117] - GENERATED CALL = (argName1).subSequence(-885588042, -1392121964).commonPrefixWith(StringBuilder(), false)
2021-03-12 01:44:32,681 [main:113] - Case = [public inline fun kotlin.String.filter(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1a3dc5eb]]
2021-03-12 01:44:32,681 [main:149] - GENERATING call of type public inline fun kotlin.String.filter(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1a3dc5eb]
2021-03-12 01:44:32,796 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:44:32,798 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:44:32,800 [main:117] - GENERATED CALL = (argName1).filter({a: Char -> false})
2021-03-12 01:44:32,800 [main:113] - Case = [public fun kotlin.CharSequence.repeat(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ffb45b2]]
2021-03-12 01:44:32,800 [main:149] - GENERATING call of type public fun kotlin.CharSequence.repeat(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ffb45b2]
2021-03-12 01:44:32,918 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:32,920 [main:117] - GENERATED CALL = (argName1).repeat(1016202169)
2021-03-12 01:44:32,920 [main:113] - Case = [public fun kotlin.String.removeSuffix(suffix: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@61211fb0]]
2021-03-12 01:44:32,920 [main:149] - GENERATING call of type public fun kotlin.String.removeSuffix(suffix: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@61211fb0]
2021-03-12 01:44:33,039 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:44:33,045 [main:117] - GENERATED CALL = (argName1).removeSuffix("vckkv")
2021-03-12 01:44:33,045 [main:113] - Case = [public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@158ccbe]]
2021-03-12 01:44:33,045 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@158ccbe]
2021-03-12 01:44:33,162 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:44:33,284 [main:43] - GENERATING CALL OF fun StringBuilder(content: kotlin.String): CharSequence = TODO()
2021-03-12 01:44:33,287 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(content: kotlin.String): CharSequence = TODO()
2021-03-12 01:44:33,539 [main:302] - generating value of type = String true depth = 3
2021-03-12 01:44:33,541 [main:95] - GENERATED = StringBuilder("cwlwb")
2021-03-12 01:44:33,658 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:33,660 [main:117] - GENERATED CALL = (argName1).commonPrefixWith(StringBuilder("cwlwb"), true)
2021-03-12 01:44:33,660 [main:114] - replacement of "Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " of type String is (argName1).commonSuffixWith("oxfwf", false)
2021-03-12 01:44:33,776 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:33,776 [main:66] - Compilation checking started
2021-03-12 01:44:34,155 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error((argName1).commonSuffixWith("oxfwf", false) + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:34,158 [main:107] - replacing (isSuccess, Boolean)
2021-03-12 01:44:34,160 [main:50] - replacing isSuccess Boolean
2021-03-12 01:44:34,160 [main:54] - Getting value of type Boolean
2021-03-12 01:44:34,296 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:34,297 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:44:34,298 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:34,429 [main:67] - randomType = K
2021-03-12 01:44:34,543 [main:302] - generating value of type = K false depth = 0
2021-03-12 01:44:34,545 [main:112] - generating klass K text = class K
2021-03-12 01:44:34,549 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in K[DeserializedSimpleFunctionDescriptor@22391e3e]
2021-03-12 01:44:34,664 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:34,665 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:44:34,779 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:34,781 [main:78] - Generated call from random type = (K()).equals("agxpk").and(false)
2021-03-12 01:44:34,782 [main:106] - GETTING Boolean from KClass<Ann>
2021-03-12 01:44:34,790 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]]
2021-03-12 01:44:34,790 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:34,907 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:34,907 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:44:35,023 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:35,023 [main:117] - GENERATED CALL = (Ann::class).equals("xwqnq").equals("nkvcx")
2021-03-12 01:44:35,023 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]]
2021-03-12 01:44:35,023 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:35,140 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:35,140 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:44:35,258 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:35,260 [main:117] - GENERATED CALL = (Ann::class).equals("puoib").and(true)
2021-03-12 01:44:35,260 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]]
2021-03-12 01:44:35,260 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:35,377 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:35,378 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]
2021-03-12 01:44:35,515 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:35,517 [main:117] - GENERATED CALL = (Ann::class).equals("jubmd").or(true)
2021-03-12 01:44:35,517 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]]
2021-03-12 01:44:35,517 [main:149] - GENERATING call of type public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]
2021-03-12 01:44:35,642 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:35,759 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:35,761 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.equals("vlutq", true)
2021-03-12 01:44:35,761 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]]
2021-03-12 01:44:35,761 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:35,878 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:35,878 [main:117] - GENERATED CALL = (Ann::class).equals("nivtp")
2021-03-12 01:44:35,878 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]]
2021-03-12 01:44:35,878 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:35,999 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:44:36,119 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:36,121 [main:117] - GENERATED CALL = (Ann::class).equals(null).xor(false)
2021-03-12 01:44:36,122 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]]
2021-03-12 01:44:36,122 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]
2021-03-12 01:44:36,122 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.toBoolean()
2021-03-12 01:44:36,122 [main:113] - Case = [@kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]]
2021-03-12 01:44:36,122 [main:149] - GENERATING call of type @kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]
2021-03-12 01:44:36,243 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:36,243 [main:117] - GENERATED CALL = (Ann::class).isInstance("cpgas")
2021-03-12 01:44:36,243 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]]
2021-03-12 01:44:36,243 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:44:36,362 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:36,362 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]
2021-03-12 01:44:36,363 [main:117] - GENERATED CALL = (Ann::class).equals("nrchy").not()
2021-03-12 01:44:36,363 [main:114] - replacement of isSuccess of type Boolean is false
2021-03-12 01:44:36,478 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 01:44:36,480 [main:107] - replacing (", got ", String)
2021-03-12 01:44:36,480 [main:50] - replacing ", got " String
2021-03-12 01:44:36,480 [main:54] - Getting value of type String
2021-03-12 01:44:36,597 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:36,599 [main:58] - GENERATED VALUE OF TYPE String = "zatav"
2021-03-12 01:44:36,599 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:37,331 [main:67] - randomType = List<Function1<UShort?, Ann>>?
2021-03-12 01:44:37,331 [main:106] - GETTING String from String
2021-03-12 01:44:37,353 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@396c934e]]
2021-03-12 01:44:37,354 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:44:37,470 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:37,472 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@396c934e]
2021-03-12 01:44:37,472 [main:117] - GENERATED CALL = (argName1).get(-1068260314).titlecase()
2021-03-12 01:44:37,472 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.trimStart(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@535de74f]]
2021-03-12 01:44:37,472 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.trimStart(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@535de74f]
2021-03-12 01:44:37,473 [main:117] - GENERATED CALL = (argName1).trimStart()
2021-03-12 01:44:37,473 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.replace(regex: kotlin.text.Regex, noinline transform: (kotlin.text.MatchResult) -> kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2801b6a0]]
2021-03-12 01:44:37,473 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:44:37,588 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:37,704 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:37,707 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.replace(regex: kotlin.text.Regex, noinline transform: (kotlin.text.MatchResult) -> kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2801b6a0]
2021-03-12 01:44:37,822 [main:302] - generating value of type = Regex false depth = 0
2021-03-12 01:44:37,945 [main:43] - GENERATING CALL OF fun Regex(pattern: kotlin.String): Regex = TODO()
2021-03-12 01:44:37,948 [main:61] - WITHOUT TYPE PARAMS = fun Regex(pattern: kotlin.String): Regex = TODO()
2021-03-12 01:44:38,236 [main:302] - generating value of type = String true depth = 3
2021-03-12 01:44:38,238 [main:95] - GENERATED = Regex("bybkj")
2021-03-12 01:44:38,370 [main:302] - generating value of type = Function1<MatchResult, CharSequence> false depth = 0
2021-03-12 01:44:38,372 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-12 01:44:38,498 [main:43] - GENERATING CALL OF fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 01:44:38,501 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 01:44:38,760 [main:302] - generating value of type = Int true depth = 4
2021-03-12 01:44:38,762 [main:95] - GENERATED = StringBuilder(-1609596437)
2021-03-12 01:44:38,762 [main:117] - GENERATED CALL = (argName1).subSequence(-319521433, -93910401).replace(Regex("bybkj"), {a: MatchResult -> StringBuilder(-1609596437)})
2021-03-12 01:44:38,762 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.reversed(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@35d6c32a]]
2021-03-12 01:44:38,762 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.reversed(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@35d6c32a]
2021-03-12 01:44:38,762 [main:117] - GENERATED CALL = (argName1).reversed()
2021-03-12 01:44:38,763 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceFirstChar(transform: (kotlin.Char) -> kotlin.Char): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@62a01f1b]]
2021-03-12 01:44:38,763 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceFirstChar(transform: (kotlin.Char) -> kotlin.Char): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@62a01f1b]
2021-03-12 01:44:38,879 [main:302] - generating value of type = Function1<Char, Char> false depth = 0
2021-03-12 01:44:38,881 [main:302] - generating value of type = Char true depth = 1
2021-03-12 01:44:38,883 [main:117] - GENERATED CALL = (argName1).replaceFirstChar({a: Char -> '꜔'})
2021-03-12 01:44:38,883 [main:113] - Case = [public fun kotlin.String.drop(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@54ff8db7]]
2021-03-12 01:44:38,883 [main:149] - GENERATING call of type public fun kotlin.String.drop(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@54ff8db7]
2021-03-12 01:44:39,001 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:39,003 [main:117] - GENERATED CALL = (argName1).drop(63849033)
2021-03-12 01:44:39,003 [main:113] - Case = [public fun kotlin.String.padEnd(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@24fa5f07]]
2021-03-12 01:44:39,003 [main:149] - GENERATING call of type public fun kotlin.String.padEnd(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@24fa5f07]
2021-03-12 01:44:39,126 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:39,244 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:39,246 [main:117] - GENERATED CALL = (argName1).padEnd(-987730728, 'ꍕ')
2021-03-12 01:44:39,246 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.trim(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6e5bf43d]]
2021-03-12 01:44:39,246 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.trim(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6e5bf43d]
2021-03-12 01:44:39,246 [main:117] - GENERATED CALL = (argName1).trim()
2021-03-12 01:44:39,246 [main:113] - Case = [public fun kotlin.String.take(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@45ed6e0a]]
2021-03-12 01:44:39,246 [main:149] - GENERATING call of type public fun kotlin.String.take(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@45ed6e0a]
2021-03-12 01:44:39,389 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:39,391 [main:117] - GENERATED CALL = (argName1).take(619271180)
2021-03-12 01:44:39,391 [main:113] - Case = [public fun kotlin.String.takeLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@652e2809]]
2021-03-12 01:44:39,391 [main:149] - GENERATING call of type public fun kotlin.String.takeLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@652e2809]
2021-03-12 01:44:39,519 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:39,521 [main:117] - GENERATED CALL = (argName1).takeLast(168597426)
2021-03-12 01:44:39,521 [main:114] - replacement of ", got " of type String is (argName1).trim()
2021-03-12 01:44:39,637 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:39,637 [main:66] - Compilation checking started
2021-03-12 01:44:39,995 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + (argName1).trim() + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:39,996 [main:107] - replacing (c !is CoroutineStackFrame, Boolean)
2021-03-12 01:44:39,997 [main:50] - replacing c !is CoroutineStackFrame Boolean
2021-03-12 01:44:39,997 [main:54] - Getting value of type Boolean
2021-03-12 01:44:40,120 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:40,122 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:44:40,122 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:40,400 [main:67] - randomType = UInt?
2021-03-12 01:44:40,515 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 01:44:40,548 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@48361cdc]
2021-03-12 01:44:40,679 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:40,680 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:44:40,796 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:40,798 [main:78] - Generated call from random type = (1517086369.toUInt())?.equals("uqxkk").xor(true)
2021-03-12 01:44:40,799 [main:106] - GETTING Boolean from KClass<MyClass>
2021-03-12 01:44:40,806 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]]
2021-03-12 01:44:40,807 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:40,921 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:40,922 [main:117] - GENERATED CALL = (MyClass::class).equals("kefha")
2021-03-12 01:44:40,922 [main:113] - Case = [@kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6af1f6a1]]
2021-03-12 01:44:40,922 [main:149] - GENERATING call of type @kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6af1f6a1]
2021-03-12 01:44:41,036 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:41,036 [main:117] - GENERATED CALL = (MyClass::class).isInstance("cjcay")
2021-03-12 01:44:41,036 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]]
2021-03-12 01:44:41,036 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:41,153 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:41,153 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:44:41,270 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:41,272 [main:117] - GENERATED CALL = (MyClass::class).equals("bkjhc").and(false)
2021-03-12 01:44:41,272 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]]
2021-03-12 01:44:41,272 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]
2021-03-12 01:44:41,272 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.toBoolean()
2021-03-12 01:44:41,272 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]]
2021-03-12 01:44:41,272 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:41,387 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:41,387 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:44:41,505 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:41,505 [main:117] - GENERATED CALL = (MyClass::class).equals("qpffc").equals("yrvet")
2021-03-12 01:44:41,505 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]]
2021-03-12 01:44:41,505 [main:149] - GENERATING call of type public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]
2021-03-12 01:44:41,625 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:41,766 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:41,768 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.equals("ezhoj", false)
2021-03-12 01:44:41,768 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]]
2021-03-12 01:44:41,768 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:41,898 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:41,898 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:44:42,013 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:42,015 [main:117] - GENERATED CALL = (MyClass::class).equals("btlci").xor(false)
2021-03-12 01:44:42,015 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]]
2021-03-12 01:44:42,015 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:42,136 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:42,136 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]
2021-03-12 01:44:42,250 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:42,252 [main:117] - GENERATED CALL = (MyClass::class).equals("yhmkv").or(true)
2021-03-12 01:44:42,252 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]]
2021-03-12 01:44:42,252 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:42,366 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:42,366 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]
2021-03-12 01:44:42,367 [main:117] - GENERATED CALL = (MyClass::class).equals("hraws").not()
2021-03-12 01:44:42,367 [main:114] - replacement of c !is CoroutineStackFrame of type Boolean is (MyClass::class).equals("qpffc").equals("yrvet")
2021-03-12 01:44:42,482 [main:33] - Trying to replace Element(IS_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:42,483 [main:66] - Compilation checking started
2021-03-12 01:44:42,835 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if ((MyClass::class).equals("qpffc").equals("yrvet")) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:42,837 [main:107] - replacing (i, Int)
2021-03-12 01:44:42,837 [main:50] - replacing i Int
2021-03-12 01:44:42,837 [main:54] - Getting value of type Int
2021-03-12 01:44:42,952 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:42,954 [main:58] - GENERATED VALUE OF TYPE Int = 670143273
2021-03-12 01:44:42,954 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:43,358 [main:67] - randomType = Sequence<Float?>
2021-03-12 01:44:43,359 [main:106] - GETTING Int from KClass<MyClass>
2021-03-12 01:44:43,367 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:44:43,367 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:44:43,367 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.compareTo(val argName2 = args[1].simpleName ?: "fail 2"
2021-03-12 01:44:43,367 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:44:43,367 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.length
2021-03-12 01:44:43,367 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:44:43,367 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@7b7594b0]
2021-03-12 01:44:43,481 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:43,481 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:44:43,596 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:44:43,599 [main:117] - GENERATED CALL = (MyClass::class).equals("tpoka").compareTo(true)
2021-03-12 01:44:43,599 [main:114] - replacement of i of type Int is (MyClass::class).qualifiedName?.compareTo(val argName2 = args[1].simpleName ?: "fail 2"
2021-03-12 01:44:43,712 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BINARY_EXPRESSION)
2021-03-12 01:44:43,712 [main:66] - Compilation checking started
2021-03-12 01:44:43,716 [main:71] - Wrong syntax or breaks conditions
2021-03-12 01:44:43,717 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != (MyClass::class).qualifiedName?.compareTo(val argName2 = args[1].simpleName ?: "fail 2") error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:43,718 [main:107] - replacing (Kla5(), Kla5)
2021-03-12 01:44:43,718 [main:50] - replacing Kla5() Kla5
2021-03-12 01:44:43,718 [main:54] - Getting value of type Kla5
2021-03-12 01:44:43,832 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 01:44:43,834 [main:112] - generating klass Kla5 text = class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 01:44:43,834 [main:58] - GENERATED VALUE OF TYPE Kla5 = Kla5()
2021-03-12 01:44:43,834 [main:61] - GENERATED IS CALL =true
2021-03-12 01:44:44,780 [main:67] - randomType = Map<Array<Byte?>, List<Char?>>
2021-03-12 01:44:44,781 [main:106] - GETTING Kla5 from KClass<Ann>
2021-03-12 01:44:44,790 [main:106] - GETTING Kla5 from KClass<MyClass>
2021-03-12 01:44:44,797 [main:106] - GETTING Kla5 from String
2021-03-12 01:44:44,816 [main:114] - replacement of Kla5() of type Kla5 is Kla5()
2021-03-12 01:44:44,929 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:44:44,931 [main:107] - replacing ("OK", String)
2021-03-12 01:44:44,931 [main:50] - replacing "OK" String
2021-03-12 01:44:44,931 [main:54] - Getting value of type String
2021-03-12 01:44:45,045 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:45,047 [main:58] - GENERATED VALUE OF TYPE String = "cymhn"
2021-03-12 01:44:45,047 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:45,306 [main:67] - randomType = MyClass?
2021-03-12 01:44:45,420 [main:302] - generating value of type = MyClass false depth = 0
2021-03-12 01:44:45,422 [main:112] - generating klass MyClass text = @Ann(O::class, K::class) class MyClass
2021-03-12 01:44:45,426 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:44:45,434 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:44:45,435 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:44:45,435 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:44:45,435 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:44:45,579 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:45,579 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("wjell")
2021-03-12 01:44:45,579 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:44:45,579 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:44:45,579 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:44:45,580 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:44:45,580 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:44:45,580 [main:114] - replacement of "OK" of type String is (Ann::class).qualifiedName
2021-03-12 01:44:45,707 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:45,707 [main:66] - Compilation checking started
2021-03-12 01:44:46,053 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return (Ann::class).qualifiedName
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:46,055 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 01:44:46,055 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 01:44:46,055 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 01:44:46,173 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 01:44:46,178 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 01:44:46,840 [main:67] - randomType = Pair<Char, Sequence<Kla4?>?>
2021-03-12 01:44:46,980 [main:302] - generating value of type = Pair<Char, Sequence<Kla4?>?> false depth = 0
2021-03-12 01:44:47,107 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Char, second: Sequence<Kla4?>?): Pair<Char, Sequence<Kla4?>?> = TODO()
2021-03-12 01:44:47,110 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Char, second: Sequence<Kla4?>?): Pair<Char, Sequence<Kla4?>?> = TODO()
2021-03-12 01:44:47,230 [main:302] - generating value of type = Char true depth = 3
2021-03-12 01:44:47,232 [main:302] - generating value of type = Sequence<Kla4?> false depth = 3
2021-03-12 01:44:47,351 [main:43] - GENERATING CALL OF fun <T> sequenceOf(elements: Kla4?): Sequence<Kla4?> = TODO()
2021-03-12 01:44:47,354 [main:61] - WITHOUT TYPE PARAMS = fun <T> sequenceOf(elements: Kla4?): Sequence<Kla4?> = TODO()
2021-03-12 01:44:47,474 [main:302] - generating value of type = Kla4 false depth = 6
2021-03-12 01:44:47,476 [main:112] - generating klass Kla4 text = class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}
2021-03-12 01:44:47,477 [main:95] - GENERATED = sequenceOf<Kla4?>(Kla4())
2021-03-12 01:44:47,477 [main:95] - GENERATED = Pair<Char, Sequence<Kla4?>?>('〹', sequenceOf<Kla4?>(Kla4()))
2021-03-12 01:44:47,492 [main:106] - GETTING EmptyCoroutineContext from KClass<Ann>
2021-03-12 01:44:47,500 [main:106] - GETTING EmptyCoroutineContext from String
2021-03-12 01:44:47,519 [main:106] - GETTING EmptyCoroutineContext from KClass<MyClass>
2021-03-12 01:44:47,526 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 01:44:47,526 [main:107] - replacing ({
        fu6(it)
    }, Function1<Continuation<Unit>, Unit>)
2021-03-12 01:44:47,526 [main:50] - replacing {
        fu6(it)
    } Function1<Continuation<Unit>, Unit>
2021-03-12 01:44:47,526 [main:54] - Getting value of type Function1<Continuation<Unit>, Unit>
2021-03-12 01:44:47,641 [main:302] - generating value of type = Function1<Continuation<Unit>, Unit> false depth = 0
2021-03-12 01:44:47,643 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:44:47,762 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:44:47,765 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:44:48,012 [main:302] - generating value of type = Any false depth = 4
2021-03-12 01:44:48,012 [main:95] - GENERATED = println("lerpv")
2021-03-12 01:44:48,012 [main:58] - GENERATED VALUE OF TYPE Function1<Continuation<Unit>, Unit> = {a: Continuation<Unit> -> println("lerpv")}
2021-03-12 01:44:48,012 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:48,140 [main:67] - randomType = Char
2021-03-12 01:44:48,277 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:44:48,299 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from KClass<Ann>
2021-03-12 01:44:48,308 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from KClass<MyClass>
2021-03-12 01:44:48,317 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from String
2021-03-12 01:44:48,336 [main:114] - replacement of {
        fu6(it)
    } of type Function1<Continuation<Unit>, Unit> is {a: Continuation<Unit> -> println("lerpv")}
2021-03-12 01:44:48,451 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 01:44:48,451 [main:66] - Compilation checking started
2021-03-12 01:44:48,796 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> println("lerpv")}

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:48,797 [main:107] - replacing (prope2, Result<Ty0>)
2021-03-12 01:44:48,797 [main:50] - replacing prope2 Result<Ty0>
2021-03-12 01:44:48,798 [main:54] - Getting value of type Result<Ty0>
2021-03-12 01:44:48,913 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 01:44:49,040 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 01:44:49,043 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 01:44:49,295 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 01:44:49,295 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 01:44:50,270 [main:67] - randomType = Function1<Pair<Kla5, Byte>, Sequence<Kla3<O>>>
2021-03-12 01:44:50,271 [main:106] - GETTING Result<Ty0> from KClass<MyClass>
2021-03-12 01:44:50,280 [main:106] - GETTING Result<Ty0> from String
2021-03-12 01:44:50,300 [main:106] - GETTING Result<Ty0> from KClass<Ann>
2021-03-12 01:44:50,307 [main:111] - Cant find and generate replacement for prope2 type Result<Ty0>
2021-03-12 01:44:50,307 [main:107] - replacing (c, Continuation<*>)
2021-03-12 01:44:50,307 [main:50] - replacing c Continuation<*>
2021-03-12 01:44:50,307 [main:54] - Getting value of type Continuation<*>
2021-03-12 01:44:50,421 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 01:44:50,543 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:50,546 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:50,934 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 01:44:51,054 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:51,057 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:51,349 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 01:44:51,472 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:51,475 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:51,860 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:51,860 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:51,860 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:51,860 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 01:44:51,864 [main:67] - randomType = Int
2021-03-12 01:44:51,977 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:52,013 [main:106] - GETTING Continuation<*> from String
2021-03-12 01:44:52,036 [main:106] - GETTING Continuation<*> from KClass<Ann>
2021-03-12 01:44:52,048 [main:106] - GETTING Continuation<*> from KClass<MyClass>
2021-03-12 01:44:52,060 [main:111] - Cant find and generate replacement for c type Continuation<*>
2021-03-12 01:44:52,060 [main:107] - replacing ("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected ", String)
2021-03-12 01:44:52,060 [main:50] - replacing "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " String
2021-03-12 01:44:52,060 [main:54] - Getting value of type String
2021-03-12 01:44:52,175 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:52,177 [main:58] - GENERATED VALUE OF TYPE String = "ceffb"
2021-03-12 01:44:52,177 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:52,305 [main:67] - randomType = Double
2021-03-12 01:44:52,418 [main:302] - generating value of type = Double true depth = 0
2021-03-12 01:44:52,448 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@29bc88bf]
2021-03-12 01:44:52,561 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:44:52,563 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@b810d92]
2021-03-12 01:44:52,677 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:44:52,679 [main:78] - Generated call from random type = (0.946820789079102).compareTo(-105).toString(-799542113)
2021-03-12 01:44:52,680 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:44:52,688 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:44:52,688 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:44:52,801 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:52,802 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("ivenk")
2021-03-12 01:44:52,802 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:44:52,802 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:44:52,802 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:44:52,802 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:44:52,802 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:44:52,802 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:44:52,802 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:44:52,802 [main:114] - replacement of "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " of type String is (Ann::class).simpleName
2021-03-12 01:44:52,932 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:52,933 [main:66] - Compilation checking started
2021-03-12 01:44:53,312 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error((Ann::class).simpleName + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:53,314 [main:107] - replacing ("tail-call optimization hit: method " + method + " has no state-machine ", String)
2021-03-12 01:44:53,314 [main:50] - replacing "tail-call optimization hit: method " + method + " has no state-machine " String
2021-03-12 01:44:53,314 [main:54] - Getting value of type String
2021-03-12 01:44:53,427 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:53,429 [main:58] - GENERATED VALUE OF TYPE String = "glsxx"
2021-03-12 01:44:53,429 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:53,437 [main:67] - randomType = Kla1
2021-03-12 01:44:53,551 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 01:44:53,553 [main:112] - generating klass Kla1 text = open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}
2021-03-12 01:44:53,668 [main:194] - Type params = []
2021-03-12 01:44:53,782 [main:302] - generating value of type = CoroutineContext false depth = 2
2021-03-12 01:44:53,899 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:53,902 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:54,157 [main:302] - generating value of type = Key<*> false depth = 5
2021-03-12 01:44:54,279 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:54,282 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:54,696 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:54,696 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:54,709 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:44:54,716 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:44:54,716 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:44:54,716 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:44:54,716 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:44:54,716 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:44:54,716 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:44:54,716 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:44:54,829 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:54,830 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("hxslj")
2021-03-12 01:44:54,830 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:44:54,830 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:44:54,830 [main:114] - replacement of "tail-call optimization hit: method " + method + " has no state-machine " of type String is "glsxx"
2021-03-12 01:44:54,944 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 01:44:54,944 [main:66] - Compilation checking started
2021-03-12 01:44:55,286 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("glsxx" +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:55,289 [main:107] - replacing (", got ", String)
2021-03-12 01:44:55,289 [main:50] - replacing ", got " String
2021-03-12 01:44:55,289 [main:54] - Getting value of type String
2021-03-12 01:44:55,421 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:44:55,423 [main:58] - GENERATED VALUE OF TYPE String = "ykumo"
2021-03-12 01:44:55,423 [main:61] - GENERATED IS CALL =false
2021-03-12 01:44:55,680 [main:67] - randomType = ArrayDeque<Float>
2021-03-12 01:44:55,795 [main:302] - generating value of type = ArrayDeque<Float> false depth = 0
2021-03-12 01:44:55,914 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(elements: kotlin.collections.Collection<Float>): ArrayDeque<Float> = TODO()
2021-03-12 01:44:55,917 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(elements: kotlin.collections.Collection<Float>): ArrayDeque<Float> = TODO()
2021-03-12 01:44:56,171 [main:302] - generating value of type = Collection<Float> false depth = 3
2021-03-12 01:44:56,292 [main:43] - GENERATING CALL OF fun <T> emptyList(): Collection<Float> = TODO()
2021-03-12 01:44:56,295 [main:61] - WITHOUT TYPE PARAMS = fun <T> emptyList(): Collection<Float> = TODO()
2021-03-12 01:44:56,444 [main:95] - GENERATED = emptyList<Float>()
2021-03-12 01:44:56,444 [main:95] - GENERATED = ArrayDeque<Float>(emptyList<Float>())
2021-03-12 01:44:56,562 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.ArrayDeque[DeserializedSimpleFunctionDescriptor@5c532582]
2021-03-12 01:44:56,563 [main:149] - GENERATING call of type @kotlin.Deprecated @kotlin.SinceKotlin @kotlin.DeprecatedSinceKotlin public fun <T> kotlin.Array<out T>.contentToString(): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@5ef60f95]
2021-03-12 01:44:56,563 [main:78] - Generated call from random type = (ArrayDeque<Float>(emptyList<Float>())).toArray().contentToString()
2021-03-12 01:44:56,564 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:44:56,571 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:44:56,572 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:44:56,572 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:44:56,572 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:44:56,572 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:44:56,572 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:44:56,572 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:44:56,572 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:44:56,572 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:44:56,686 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:44:56,686 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("yhakp")
2021-03-12 01:44:56,686 [main:114] - replacement of ", got " of type String is (ArrayDeque<Float>(emptyList<Float>())).toArray().contentToString()
2021-03-12 01:44:56,799 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:44:56,800 [main:66] - Compilation checking started
2021-03-12 01:44:57,194 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + (ArrayDeque<Float>(emptyList<Float>())).toArray().contentToString() + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:44:57,196 [main:107] - replacing (c, Continuation<*>)
2021-03-12 01:44:57,197 [main:50] - replacing c Continuation<*>
2021-03-12 01:44:57,197 [main:54] - Getting value of type Continuation<*>
2021-03-12 01:44:57,325 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 01:44:57,445 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:57,448 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:57,834 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 01:44:57,952 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:57,955 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:58,215 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 01:44:58,364 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:58,367 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:58,758 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 9
2021-03-12 01:44:58,880 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 01:44:58,883 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 01:44:59,275 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 12
2021-03-12 01:44:59,397 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 01:44:59,399 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 01:44:59,783 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 01:44:59,783 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 01:44:59,783 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:44:59,783 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:44:59,783 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:44:59,783 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 01:44:59,918 [main:67] - randomType = Long
2021-03-12 01:45:00,098 [main:302] - generating value of type = Long true depth = 0
2021-03-12 01:45:00,138 [main:106] - GETTING Continuation<*> from String
2021-03-12 01:45:00,199 [main:106] - GETTING Continuation<*> from KClass<MyClass>
2021-03-12 01:45:00,211 [main:106] - GETTING Continuation<*> from KClass<Ann>
2021-03-12 01:45:00,223 [main:111] - Cant find and generate replacement for c type Continuation<*>
2021-03-12 01:45:00,223 [main:107] - replacing ("fail 1: $prope2", String)
2021-03-12 01:45:00,223 [main:50] - replacing "fail 1: $prope2" String
2021-03-12 01:45:00,223 [main:54] - Getting value of type String
2021-03-12 01:45:00,340 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:00,342 [main:58] - GENERATED VALUE OF TYPE String = "hxbse"
2021-03-12 01:45:00,342 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:00,470 [main:67] - randomType = UShort
2021-03-12 01:45:00,583 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 01:45:00,616 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@7e2573a]
2021-03-12 01:45:00,730 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 01:45:00,732 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@b810d92]
2021-03-12 01:45:00,846 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:00,848 [main:78] - Generated call from random type = (25260.toUShort()).compareTo(26.toUByte()).toString(-532680979)
2021-03-12 01:45:00,848 [main:114] - replacement of "fail 1: $prope2" of type String is (25260.toUShort()).compareTo(26.toUByte()).toString(-532680979)
2021-03-12 01:45:00,964 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:00,964 [main:66] - Compilation checking started
2021-03-12 01:45:01,325 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return (25260.toUShort()).compareTo(26.toUByte()).toString(-532680979)

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:01,327 [main:107] - replacing (fu3(), Int)
2021-03-12 01:45:01,327 [main:50] - replacing fu3() Int
2021-03-12 01:45:01,327 [main:54] - Getting value of type Int
2021-03-12 01:45:01,461 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:01,464 [main:58] - GENERATED VALUE OF TYPE Int = -693468730
2021-03-12 01:45:01,464 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:01,719 [main:67] - randomType = HashSet<Float>
2021-03-12 01:45:01,834 [main:302] - generating value of type = HashSet<Float> false depth = 0
2021-03-12 01:45:01,952 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: Float): HashSet<Float> = TODO()
2021-03-12 01:45:01,955 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: Float): HashSet<Float> = TODO()
2021-03-12 01:45:02,075 [main:302] - generating value of type = Float true depth = 3
2021-03-12 01:45:02,077 [main:95] - GENERATED = linkedSetOf<Float>(0.653083f)
2021-03-12 01:45:02,174 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.HashSet[DeserializedSimpleFunctionDescriptor@1d6d0e86]
2021-03-12 01:45:02,175 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun <T> kotlin.Array<out T>.sumOf(selector: (T) -> kotlin.Int): kotlin.Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@7e0b3d79]
2021-03-12 01:45:02,290 [main:302] - generating value of type = Function1<T, Int> false depth = 0
2021-03-12 01:45:02,291 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:45:02,294 [main:78] - Generated call from random type = (linkedSetOf<Float>(0.653083f)).toArray().sumOf({a: T -> 1174889112})
2021-03-12 01:45:02,294 [main:114] - replacement of fu3() of type Int is (linkedSetOf<Float>(0.653083f)).toArray().sumOf({a: T -> 1174889112})
2021-03-12 01:45:02,407 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:02,408 [main:66] - Compilation checking started
2021-03-12 01:45:02,851 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.(linkedSetOf<Float>(0.653083f)).toArray().sumOf({a: T -> 1174889112}) ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:02,853 [main:107] - replacing ("Continuation " + c + " is not subtype of CoroutineStackFrame", String)
2021-03-12 01:45:02,854 [main:50] - replacing "Continuation " + c + " is not subtype of CoroutineStackFrame" String
2021-03-12 01:45:02,854 [main:54] - Getting value of type String
2021-03-12 01:45:02,999 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:03,001 [main:58] - GENERATED VALUE OF TYPE String = "aknij"
2021-03-12 01:45:03,001 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:03,279 [main:67] - randomType = Double?
2021-03-12 01:45:03,396 [main:302] - generating value of type = Double true depth = 0
2021-03-12 01:45:03,427 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@dc0829f]
2021-03-12 01:45:03,427 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5146c661]
2021-03-12 01:45:03,428 [main:78] - Generated call from random type = (0.8870543247293734)?.toChar().lowercase()
2021-03-12 01:45:03,428 [main:106] - GETTING String from KClass<MyClass>
2021-03-12 01:45:03,435 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:45:03,435 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:45:03,553 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:03,553 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.plus("uycwx")
2021-03-12 01:45:03,553 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7]]
2021-03-12 01:45:03,553 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName
2021-03-12 01:45:03,553 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:45:03,553 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:45:03,554 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.orEmpty()
2021-03-12 01:45:03,554 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@20dad990]]
2021-03-12 01:45:03,554 [main:117] - GENERATED CALL = (MyClass::class).simpleName
2021-03-12 01:45:03,554 [main:114] - replacement of "Continuation " + c + " is not subtype of CoroutineStackFrame" of type String is (MyClass::class).qualifiedName?.orEmpty()
2021-03-12 01:45:03,676 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:45:03,676 [main:66] - Compilation checking started
2021-03-12 01:45:04,025 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error((MyClass::class).qualifiedName?.orEmpty())
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:04,027 [main:107] - replacing ("OK", String)
2021-03-12 01:45:04,027 [main:50] - replacing "OK" String
2021-03-12 01:45:04,027 [main:54] - Getting value of type String
2021-03-12 01:45:04,150 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:04,152 [main:58] - GENERATED VALUE OF TYPE String = "dpess"
2021-03-12 01:45:04,152 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:04,421 [main:67] - randomType = List<K>
2021-03-12 01:45:04,421 [main:106] - GETTING String from String
2021-03-12 01:45:04,442 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.String.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5296c183]]
2021-03-12 01:45:04,442 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.String.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5296c183]
2021-03-12 01:45:04,442 [main:117] - GENERATED CALL = (argName1).lowercase()
2021-03-12 01:45:04,442 [main:113] - Case = [public fun kotlin.CharSequence.repeat(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ffb45b2]]
2021-03-12 01:45:04,442 [main:149] - GENERATING call of type public fun kotlin.CharSequence.repeat(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@ffb45b2]
2021-03-12 01:45:04,582 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:04,585 [main:117] - GENERATED CALL = (argName1).repeat(1983088227)
2021-03-12 01:45:04,585 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.replaceRange(startIndex: kotlin.Int, endIndex: kotlin.Int, replacement: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@344902a5]]
2021-03-12 01:45:04,585 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.replaceRange(startIndex: kotlin.Int, endIndex: kotlin.Int, replacement: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@344902a5]
2021-03-12 01:45:04,708 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:04,832 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:04,954 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:45:04,960 [main:117] - GENERATED CALL = (argName1).replaceRange(-278518766, 1358435420, "cbqfk")
2021-03-12 01:45:04,960 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.String.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2ed2b3a4]]
2021-03-12 01:45:04,960 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.String.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2ed2b3a4]
2021-03-12 01:45:04,960 [main:117] - GENERATED CALL = (argName1).uppercase()
2021-03-12 01:45:04,960 [main:113] - Case = [public fun kotlin.String.prependIndent(indent: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2da28332]]
2021-03-12 01:45:04,960 [main:149] - GENERATING call of type public fun kotlin.String.prependIndent(indent: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2da28332]
2021-03-12 01:45:05,083 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:05,085 [main:117] - GENERATED CALL = (argName1).prependIndent("imppw")
2021-03-12 01:45:05,085 [main:113] - Case = [public fun kotlin.String.padStart(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@283e9d49]]
2021-03-12 01:45:05,085 [main:149] - GENERATING call of type public fun kotlin.String.padStart(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@283e9d49]
2021-03-12 01:45:05,210 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:05,331 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:05,333 [main:117] - GENERATED CALL = (argName1).padStart(1136666502, 'Ⓩ')
2021-03-12 01:45:05,333 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.replace(regex: kotlin.text.Regex, noinline transform: (kotlin.text.MatchResult) -> kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2801b6a0]]
2021-03-12 01:45:05,333 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:05,450 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:05,571 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:05,573 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.replace(regex: kotlin.text.Regex, noinline transform: (kotlin.text.MatchResult) -> kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2801b6a0]
2021-03-12 01:45:05,689 [main:302] - generating value of type = Regex false depth = 0
2021-03-12 01:45:05,838 [main:43] - GENERATING CALL OF fun Regex(pattern: kotlin.String): Regex = TODO()
2021-03-12 01:45:05,841 [main:61] - WITHOUT TYPE PARAMS = fun Regex(pattern: kotlin.String): Regex = TODO()
2021-03-12 01:45:06,109 [main:302] - generating value of type = String true depth = 3
2021-03-12 01:45:06,111 [main:95] - GENERATED = Regex("fktdu")
2021-03-12 01:45:06,225 [main:302] - generating value of type = Function1<MatchResult, CharSequence> false depth = 0
2021-03-12 01:45:06,227 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-12 01:45:06,346 [main:43] - GENERATING CALL OF fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 01:45:06,348 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 01:45:06,599 [main:302] - generating value of type = Int true depth = 4
2021-03-12 01:45:06,601 [main:95] - GENERATED = StringBuilder(-632731639)
2021-03-12 01:45:06,602 [main:117] - GENERATED CALL = (argName1).subSequence(-1497742544, -1061585623).replace(Regex("fktdu"), {a: MatchResult -> StringBuilder(-632731639)})
2021-03-12 01:45:06,602 [main:113] - Case = [public fun kotlin.String.removeSuffix(suffix: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@61211fb0]]
2021-03-12 01:45:06,602 [main:149] - GENERATING call of type public fun kotlin.String.removeSuffix(suffix: kotlin.CharSequence): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@61211fb0]
2021-03-12 01:45:06,717 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:45:06,722 [main:117] - GENERATED CALL = (argName1).removeSuffix(StringBuilder())
2021-03-12 01:45:06,722 [main:113] - Case = [public fun kotlin.String.replaceBefore(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b7171ef]]
2021-03-12 01:45:06,722 [main:149] - GENERATING call of type public fun kotlin.String.replaceBefore(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b7171ef]
2021-03-12 01:45:06,836 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:06,952 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:07,098 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:07,100 [main:117] - GENERATED CALL = (argName1).replaceBefore('', "ckcou", "qguxm")
2021-03-12 01:45:07,100 [main:113] - Case = [public fun kotlin.String.substringAfterLast(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1cf7429e]]
2021-03-12 01:45:07,101 [main:149] - GENERATING call of type public fun kotlin.String.substringAfterLast(delimiter: kotlin.Char, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1cf7429e]
2021-03-12 01:45:07,238 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:07,357 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:07,359 [main:117] - GENERATED CALL = (argName1).substringAfterLast('剏', "dqgjt")
2021-03-12 01:45:07,359 [main:114] - replacement of "OK" of type String is (argName1).replaceBefore('', "ckcou", "qguxm")
2021-03-12 01:45:07,473 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:07,473 [main:66] - Compilation checking started
2021-03-12 01:45:07,828 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return (argName1).replaceBefore('', "ckcou", "qguxm")
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:07,829 [main:107] - replacing (prope3?.fu3() ?: 0, Int)
2021-03-12 01:45:07,830 [main:50] - replacing prope3?.fu3() ?: 0 Int
2021-03-12 01:45:07,830 [main:54] - Getting value of type Int
2021-03-12 01:45:07,948 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:07,950 [main:58] - GENERATED VALUE OF TYPE Int = -280162223
2021-03-12 01:45:07,950 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:08,081 [main:67] - randomType = ULong
2021-03-12 01:45:08,194 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 01:45:08,223 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@4e861a4]
2021-03-12 01:45:08,338 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 01:45:08,340 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@1877da1d]
2021-03-12 01:45:08,455 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:45:08,457 [main:78] - Generated call from random type = (646194775791431122.toULong()).compareTo(125.toUByte()).div(70)
2021-03-12 01:45:08,457 [main:114] - replacement of prope3?.fu3() ?: 0 of type Int is (646194775791431122.toULong()).compareTo(125.toUByte()).div(70)
2021-03-12 01:45:08,591 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:08,591 [main:66] - Compilation checking started
2021-03-12 01:45:08,944 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + ((646194775791431122.toULong()).compareTo(125.toUByte()).div(70))
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:08,946 [main:107] - replacing (true, Boolean)
2021-03-12 01:45:08,946 [main:50] - replacing true Boolean
2021-03-12 01:45:08,946 [main:54] - Getting value of type Boolean
2021-03-12 01:45:09,060 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:09,062 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 01:45:09,062 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:09,193 [main:67] - randomType = Kla6
2021-03-12 01:45:09,307 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 01:45:09,309 [main:112] - generating klass Kla6 text = object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}
2021-03-12 01:45:09,326 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla6[DeserializedSimpleFunctionDescriptor@446f8467]
2021-03-12 01:45:09,440 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:09,440 [main:78] - Generated call from random type = (Kla6).equals("yeqgc")
2021-03-12 01:45:09,441 [main:114] - replacement of true of type Boolean is (Kla6).equals("yeqgc")
2021-03-12 01:45:09,557 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:09,558 [main:66] - Compilation checking started
2021-03-12 01:45:09,911 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == (Kla6).equals("yeqgc") } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:09,913 [main:107] - replacing (prope2.exceptionOrNull()?.let(x), Unit?)
2021-03-12 01:45:09,913 [main:50] - replacing prope2.exceptionOrNull()?.let(x) Unit?
2021-03-12 01:45:09,913 [main:54] - Getting value of type Unit?
2021-03-12 01:45:10,030 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 01:45:10,172 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 01:45:10,175 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 01:45:10,437 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 3
2021-03-12 01:45:10,440 [main:302] - generating value of type = Unit false depth = 4
2021-03-12 01:45:10,445 [main:95] - GENERATED = contract({ println()})
2021-03-12 01:45:10,445 [main:58] - GENERATED VALUE OF TYPE Unit? = contract({ println()})
2021-03-12 01:45:10,445 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:10,708 [main:67] - randomType = Kla3<Long>
2021-03-12 01:45:10,821 [main:302] - generating value of type = Kla3<Long> false depth = 0
2021-03-12 01:45:10,823 [main:112] - generating klass Kla3 text = abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 01:45:11,204 [main:302] - generating value of type = Kla6 false depth = 2
2021-03-12 01:45:11,206 [main:112] - generating klass Kla6 text = object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}
2021-03-12 01:45:11,224 [main:149] - GENERATING call of type public abstract fun fu4(exception: kotlin.Throwable): kotlin.Unit defined in Kla3[SimpleFunctionDescriptorImpl@234bb65e]
2021-03-12 01:45:11,337 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 01:45:11,456 [main:43] - GENERATING CALL OF fun NumberFormatException(message: kotlin.String?): Throwable = TODO()
2021-03-12 01:45:11,459 [main:61] - WITHOUT TYPE PARAMS = fun NumberFormatException(message: kotlin.String?): Throwable = TODO()
2021-03-12 01:45:11,755 [main:302] - generating value of type = String true depth = 3
2021-03-12 01:45:11,757 [main:95] - GENERATED = NumberFormatException("zheve")
2021-03-12 01:45:11,757 [main:78] - Generated call from random type = (Kla6).fu4(NumberFormatException("zheve"))
2021-03-12 01:45:11,758 [main:106] - GETTING Unit? from String
2021-03-12 01:45:11,785 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public inline fun kotlin.CharSequence.forEachIndexed(action: (index: kotlin.Int, kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5fbbc725]]
2021-03-12 01:45:11,785 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:11,901 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:12,017 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:12,019 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.forEachIndexed(action: (index: kotlin.Int, kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5fbbc725]
2021-03-12 01:45:12,135 [main:302] - generating value of type = Function2<[@kotlin.ParameterName] Int, Char, Unit> false depth = 0
2021-03-12 01:45:12,137 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:45:12,258 [main:43] - GENERATING CALL OF fun repeat(times: kotlin.Int, action: (kotlin.Int)->kotlin.Unit): Unit = TODO()
2021-03-12 01:45:12,261 [main:61] - WITHOUT TYPE PARAMS = fun repeat(times: kotlin.Int, action: (kotlin.Int)->kotlin.Unit): Unit = TODO()
2021-03-12 01:45:12,641 [main:302] - generating value of type = Int true depth = 4
2021-03-12 01:45:12,643 [main:302] - generating value of type = Function1<Int, Unit> false depth = 4
2021-03-12 01:45:12,645 [main:302] - generating value of type = Unit false depth = 5
2021-03-12 01:45:12,766 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:45:12,769 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:45:13,059 [main:302] - generating value of type = Any false depth = 8
2021-03-12 01:45:13,060 [main:95] - GENERATED = println("epvlu")
2021-03-12 01:45:13,060 [main:95] - GENERATED = repeat(-1953689698, {a: Int -> println("epvlu")})
2021-03-12 01:45:13,060 [main:117] - GENERATED CALL = (argName1)?.subSequence(-1242309982, 69319486).forEachIndexed({a: Int, b: Char -> repeat(-1953689698, {a: Int -> println("epvlu")})})
2021-03-12 01:45:13,060 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public inline fun kotlin.CharSequence.forEach(action: (kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@63a81830]]
2021-03-12 01:45:13,060 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:13,190 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:13,307 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:13,309 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.forEach(action: (kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@63a81830]
2021-03-12 01:45:13,424 [main:302] - generating value of type = Function1<Char, Unit> false depth = 0
2021-03-12 01:45:13,426 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:45:13,434 [main:117] - GENERATED CALL = (argName1)?.subSequence(-113960238, -1919640625).forEach({a: Char -> println()})
2021-03-12 01:45:13,434 [main:113] - Case = [public inline fun kotlin.CharSequence.forEachIndexed(action: (index: kotlin.Int, kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5fbbc725]]
2021-03-12 01:45:13,434 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.forEachIndexed(action: (index: kotlin.Int, kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5fbbc725]
2021-03-12 01:45:13,547 [main:302] - generating value of type = Function2<[@kotlin.ParameterName] Int, Char, Unit> false depth = 0
2021-03-12 01:45:13,549 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:45:13,554 [main:117] - GENERATED CALL = (argName1)?.forEachIndexed({a: Int, b: Char -> println()})
2021-03-12 01:45:13,554 [main:113] - Case = [public inline fun kotlin.CharSequence.forEach(action: (kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@63a81830]]
2021-03-12 01:45:13,554 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.forEach(action: (kotlin.Char) -> kotlin.Unit): kotlin.Unit defined in kotlin.text[DeserializedSimpleFunctionDescriptor@63a81830]
2021-03-12 01:45:13,668 [main:302] - generating value of type = Function1<Char, Unit> false depth = 0
2021-03-12 01:45:13,670 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:45:13,788 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 01:45:13,791 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 01:45:14,036 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 01:45:14,038 [main:95] - GENERATED = require(false)
2021-03-12 01:45:14,039 [main:117] - GENERATED CALL = (argName1)?.forEach({a: Char -> require(false)})
2021-03-12 01:45:14,039 [main:114] - replacement of prope2.exceptionOrNull()?.let(x) of type Unit? is (argName1)?.subSequence(-113960238, -1919640625).forEach({a: Char -> println()})
2021-03-12 01:45:14,153 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:14,153 [main:66] - Compilation checking started
2021-03-12 01:45:14,517 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
(argName1)?.subSequence(-113960238, -1919640625).forEach({a: Char -> println()})
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:14,519 [main:107] - replacing (prope6, Boolean)
2021-03-12 01:45:14,519 [main:50] - replacing prope6 Boolean
2021-03-12 01:45:14,519 [main:54] - Getting value of type Boolean
2021-03-12 01:45:14,655 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:14,657 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 01:45:14,657 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:15,060 [main:67] - randomType = HashMap<Kla1?, O>
2021-03-12 01:45:15,174 [main:302] - generating value of type = HashMap<Kla1?, O> false depth = 0
2021-03-12 01:45:15,294 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): HashMap<Kla1?, O> = TODO()
2021-03-12 01:45:15,296 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): HashMap<Kla1?, O> = TODO()
2021-03-12 01:45:15,416 [main:95] - GENERATED = linkedMapOf<Kla1?, O>()
2021-03-12 01:45:15,508 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.MutableCollection<out T>.remove(element: T): kotlin.Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@74f8dc1b]
2021-03-12 01:45:15,622 [main:78] - Generated call from random type = (linkedMapOf<Kla1?, O>()).values.remove(null)
2021-03-12 01:45:15,623 [main:114] - replacement of prope6 of type Boolean is (linkedMapOf<Kla1?, O>()).values.remove(null)
2021-03-12 01:45:15,736 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:15,737 [main:66] - Compilation checking started
2021-03-12 01:45:16,118 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if ((linkedMapOf<Kla1?, O>()).values.remove(null)) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:16,121 [main:107] - replacing (prope5 != numberOfSuspensions, Boolean)
2021-03-12 01:45:16,121 [main:50] - replacing prope5 != numberOfSuspensions Boolean
2021-03-12 01:45:16,121 [main:54] - Getting value of type Boolean
2021-03-12 01:45:16,262 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:16,264 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:45:16,264 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:16,272 [main:67] - randomType = Kla5
2021-03-12 01:45:16,391 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 01:45:16,393 [main:112] - generating klass Kla5 text = class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 01:45:16,404 [main:149] - GENERATING call of type public final fun fu9(): kotlin.Unit defined in Kla5[SimpleFunctionDescriptorImpl@472f986]
2021-03-12 01:45:16,404 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Unit[DeserializedSimpleFunctionDescriptor@44c4aa0c]
2021-03-12 01:45:16,530 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:16,530 [main:78] - Generated call from random type = (Kla5()).fu9().equals("moyuk")
2021-03-12 01:45:16,531 [main:106] - GETTING Boolean from KClass<Ann>
2021-03-12 01:45:16,543 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]]
2021-03-12 01:45:16,543 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:16,662 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:16,662 [main:117] - GENERATED CALL = (Ann::class).equals("mfjxs")
2021-03-12 01:45:16,662 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]]
2021-03-12 01:45:16,662 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:16,776 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:16,776 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:45:16,890 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:16,892 [main:117] - GENERATED CALL = (Ann::class).equals("zrwfa").and(false)
2021-03-12 01:45:16,892 [main:113] - Case = [@kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]]
2021-03-12 01:45:16,892 [main:149] - GENERATING call of type @kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]
2021-03-12 01:45:17,005 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:17,005 [main:117] - GENERATED CALL = (Ann::class).isInstance("pszmi")
2021-03-12 01:45:17,006 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]]
2021-03-12 01:45:17,006 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:17,121 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:17,121 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:45:17,235 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:17,238 [main:117] - GENERATED CALL = (Ann::class).equals("tdubb").xor(true)
2021-03-12 01:45:17,238 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]]
2021-03-12 01:45:17,238 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:17,351 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:17,352 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]
2021-03-12 01:45:17,465 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:17,467 [main:117] - GENERATED CALL = (Ann::class).equals("diopi").or(false)
2021-03-12 01:45:17,467 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]]
2021-03-12 01:45:17,467 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]
2021-03-12 01:45:17,467 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.toBoolean()
2021-03-12 01:45:17,467 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]]
2021-03-12 01:45:17,467 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:17,581 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:17,581 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:45:17,732 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:17,733 [main:117] - GENERATED CALL = (Ann::class).equals("gefhq").equals("lyngo")
2021-03-12 01:45:17,733 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]]
2021-03-12 01:45:17,733 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:17,874 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:17,874 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]
2021-03-12 01:45:17,875 [main:117] - GENERATED CALL = (Ann::class).equals("geftf").not()
2021-03-12 01:45:17,875 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]]
2021-03-12 01:45:17,875 [main:149] - GENERATING call of type public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]
2021-03-12 01:45:17,990 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:18,107 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:18,109 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.equals("aygna", false)
2021-03-12 01:45:18,109 [main:114] - replacement of prope5 != numberOfSuspensions of type Boolean is (Ann::class).equals("gefhq").equals("lyngo")
2021-03-12 01:45:18,238 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:18,238 [main:66] - Compilation checking started
2021-03-12 01:45:18,596 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if ((Ann::class).equals("gefhq").equals("lyngo"))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:18,599 [main:107] - replacing (14, Int)
2021-03-12 01:45:18,599 [main:50] - replacing 14 Int
2021-03-12 01:45:18,599 [main:54] - Getting value of type Int
2021-03-12 01:45:18,727 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:18,729 [main:58] - GENERATED VALUE OF TYPE Int = 1400937796
2021-03-12 01:45:18,729 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:18,987 [main:67] - randomType = Sequence<Byte>
2021-03-12 01:45:18,988 [main:106] - GETTING Int from KClass<Ann>
2021-03-12 01:45:18,996 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:45:18,996 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:19,110 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:19,110 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:45:19,226 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:19,228 [main:117] - GENERATED CALL = (Ann::class).equals("gmwmf").compareTo(false)
2021-03-12 01:45:19,228 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:45:19,228 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.length
2021-03-12 01:45:19,228 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]]
2021-03-12 01:45:19,228 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor@a2ea05b]
2021-03-12 01:45:19,347 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:19,377 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.compareTo("iftno")
2021-03-12 01:45:19,377 [main:114] - replacement of 14 of type Int is 1400937796
2021-03-12 01:45:19,493 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 01:45:19,493 [main:66] - Compilation checking started
2021-03-12 01:45:19,839 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(1400937796)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:19,841 [main:107] - replacing (prope6, Boolean)
2021-03-12 01:45:19,841 [main:50] - replacing prope6 Boolean
2021-03-12 01:45:19,841 [main:54] - Getting value of type Boolean
2021-03-12 01:45:19,960 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:19,962 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 01:45:19,962 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:20,092 [main:67] - randomType = UByte
2021-03-12 01:45:20,206 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 01:45:20,237 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun rangeTo(other: kotlin.UByte): kotlin.ranges.UIntRange defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@212c3046]
2021-03-12 01:45:20,353 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 01:45:20,355 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.UIntRange[DeserializedSimpleFunctionDescriptor@33d9e850]
2021-03-12 01:45:20,469 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:20,469 [main:78] - Generated call from random type = (104.toUByte()).rangeTo(55.toUByte()).equals("ghpvv")
2021-03-12 01:45:20,470 [main:106] - GETTING Boolean from KClass<Ann>
2021-03-12 01:45:20,478 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]]
2021-03-12 01:45:20,478 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:20,591 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:20,592 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]
2021-03-12 01:45:20,707 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:20,709 [main:117] - GENERATED CALL = (Ann::class).equals("jekup").or(true)
2021-03-12 01:45:20,709 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]]
2021-03-12 01:45:20,709 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:20,823 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:20,823 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]
2021-03-12 01:45:20,823 [main:117] - GENERATED CALL = (Ann::class).equals("yjtne").not()
2021-03-12 01:45:20,824 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]]
2021-03-12 01:45:20,824 [main:149] - GENERATING call of type public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]
2021-03-12 01:45:20,939 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:21,079 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:21,081 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.equals("rzvyk", true)
2021-03-12 01:45:21,081 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]]
2021-03-12 01:45:21,081 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]
2021-03-12 01:45:21,081 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.toBoolean()
2021-03-12 01:45:21,081 [main:113] - Case = [@kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]]
2021-03-12 01:45:21,081 [main:149] - GENERATING call of type @kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]
2021-03-12 01:45:21,196 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:21,197 [main:117] - GENERATED CALL = (Ann::class).isInstance("joncp")
2021-03-12 01:45:21,197 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]]
2021-03-12 01:45:21,197 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:21,312 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:45:21,426 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:21,428 [main:117] - GENERATED CALL = (Ann::class).equals(null).and(true)
2021-03-12 01:45:21,428 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]]
2021-03-12 01:45:21,428 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:21,542 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:21,542 [main:117] - GENERATED CALL = (Ann::class).equals("ncnuw")
2021-03-12 01:45:21,542 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]]
2021-03-12 01:45:21,542 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:21,657 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:21,657 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:45:21,771 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:21,773 [main:117] - GENERATED CALL = (Ann::class).equals("pfzmm").xor(true)
2021-03-12 01:45:21,773 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]]
2021-03-12 01:45:21,773 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:21,886 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:21,886 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:45:22,003 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:22,004 [main:117] - GENERATED CALL = (Ann::class).equals("odmli").equals("wlody")
2021-03-12 01:45:22,004 [main:114] - replacement of prope6 of type Boolean is (Ann::class).qualifiedName?.toBoolean()
2021-03-12 01:45:22,121 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:45:22,122 [main:66] - Compilation checking started
2021-03-12 01:45:22,471 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if ((Ann::class).qualifiedName?.toBoolean()) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:22,472 [main:107] - replacing (", got ", String)
2021-03-12 01:45:22,472 [main:50] - replacing ", got " String
2021-03-12 01:45:22,472 [main:54] - Getting value of type String
2021-03-12 01:45:22,586 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:22,588 [main:58] - GENERATED VALUE OF TYPE String = "iepig"
2021-03-12 01:45:22,588 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:22,714 [main:67] - randomType = Short
2021-03-12 01:45:22,844 [main:302] - generating value of type = Short true depth = 0
2021-03-12 01:45:22,875 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6de2d8f4]
2021-03-12 01:45:22,875 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2be1aa4e]
2021-03-12 01:45:22,875 [main:78] - Generated call from random type = (6416).toChar().plus(val argName2 = args[1].simpleName ?: "fail 2"
2021-03-12 01:45:22,876 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:45:22,883 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:45:22,883 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:45:22,884 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:45:22,884 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:45:22,884 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:45:22,884 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:45:22,884 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:45:22,999 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:22,999 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("pyhms")
2021-03-12 01:45:22,999 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:45:22,999 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:45:22,999 [main:114] - replacement of ", got " of type String is (Ann::class).simpleName
2021-03-12 01:45:23,113 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:23,114 [main:66] - Compilation checking started
2021-03-12 01:45:23,463 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + (Ann::class).simpleName + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:23,465 [main:107] - replacing (prope2, Int)
2021-03-12 01:45:23,465 [main:50] - replacing prope2 Int
2021-03-12 01:45:23,465 [main:54] - Getting value of type Int
2021-03-12 01:45:23,578 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:23,580 [main:58] - GENERATED VALUE OF TYPE Int = 828398788
2021-03-12 01:45:23,580 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:24,637 [main:67] - randomType = Function2<ArrayList<Map<ArrayDeque<Double?>, Char>>, String, UShort>
2021-03-12 01:45:24,638 [main:106] - GETTING Int from String
2021-03-12 01:45:24,657 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@35c7c5e]]
2021-03-12 01:45:24,657 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:45:24,770 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:24,773 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@35c7c5e]
2021-03-12 01:45:24,890 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:24,892 [main:117] - GENERATED CALL = (argName1).compareTo("biuuu").rotateRight(1014566639)
2021-03-12 01:45:24,892 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@645cceaa]]
2021-03-12 01:45:24,892 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@645cceaa]
2021-03-12 01:45:24,892 [main:117] - GENERATED CALL = (argName1).length.dec()
2021-03-12 01:45:24,892 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6540b81e]]
2021-03-12 01:45:24,892 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6540b81e]
2021-03-12 01:45:25,007 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:45:25,009 [main:117] - GENERATED CALL = (argName1).length.minus(122)
2021-03-12 01:45:25,009 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public inline fun kotlin.CharSequence.sumBy(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6a73f254]]
2021-03-12 01:45:25,009 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:25,124 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:25,239 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:25,241 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.sumBy(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6a73f254]
2021-03-12 01:45:25,353 [main:302] - generating value of type = Function1<Char, Int> false depth = 0
2021-03-12 01:45:25,355 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:45:25,357 [main:117] - GENERATED CALL = (argName1).subSequence(-862111115, 60102286).sumBy({a: Char -> 16959394})
2021-03-12 01:45:25,357 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@798cb469]]
2021-03-12 01:45:25,357 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:45:25,358 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@798cb469]
2021-03-12 01:45:25,358 [main:117] - GENERATED CALL = (argName1).compareTo(argName1).takeLowestOneBit()
2021-03-12 01:45:25,358 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688]]
2021-03-12 01:45:25,358 [main:117] - GENERATED CALL = (argName1).length
2021-03-12 01:45:25,358 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3ef72d49]]
2021-03-12 01:45:25,358 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:45:25,358 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3ef72d49]
2021-03-12 01:45:25,471 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:25,474 [main:117] - GENERATED CALL = (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".ushr(1844307138)
2021-03-12 01:45:25,474 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.sumOf(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36df585a]]
2021-03-12 01:45:25,474 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:25,587 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:25,702 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:25,704 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.sumOf(selector: (kotlin.Char) -> kotlin.Int): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@36df585a]
2021-03-12 01:45:25,817 [main:302] - generating value of type = Function1<Char, Int> false depth = 0
2021-03-12 01:45:25,819 [main:302] - generating value of type = Int true depth = 1
2021-03-12 01:45:25,821 [main:117] - GENERATED CALL = (argName1).subSequence(1291350021, -1260193255).sumOf({a: Char -> -789833507})
2021-03-12 01:45:25,821 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2feea37d]]
2021-03-12 01:45:25,821 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:45:25,822 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2feea37d]
2021-03-12 01:45:25,822 [main:117] - GENERATED CALL = (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".toInt()
2021-03-12 01:45:25,822 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1e89b7d6]]
2021-03-12 01:45:25,822 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:45:25,822 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1e89b7d6]
2021-03-12 01:45:25,935 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:26,050 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:26,052 [main:117] - GENERATED CALL = (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".coerceIn(1543216763, 1793279137)
2021-03-12 01:45:26,052 [main:114] - replacement of prope2 of type Int is (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".toInt()
2021-03-12 01:45:26,166 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BINARY_EXPRESSION)
2021-03-12 01:45:26,167 [main:66] - Compilation checking started
2021-03-12 01:45:26,171 [main:71] - Wrong syntax or breaks conditions
2021-03-12 01:45:26,171 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".toInt() = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:26,173 [main:107] - replacing (Kla0(), Kla0)
2021-03-12 01:45:26,173 [main:50] - replacing Kla0() Kla0
2021-03-12 01:45:26,173 [main:54] - Getting value of type Kla0
2021-03-12 01:45:26,313 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 01:45:26,315 [main:112] - generating klass Kla0 text = class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}
2021-03-12 01:45:26,316 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla0()
2021-03-12 01:45:26,316 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:26,323 [main:67] - randomType = Kla5
2021-03-12 01:45:26,463 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 01:45:26,465 [main:112] - generating klass Kla5 text = class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 01:45:26,475 [main:106] - GETTING Kla0 from String
2021-03-12 01:45:26,507 [main:106] - GETTING Kla0 from KClass<MyClass>
2021-03-12 01:45:26,521 [main:106] - GETTING Kla0 from KClass<Ann>
2021-03-12 01:45:26,533 [main:114] - replacement of Kla0() of type Kla0 is Kla0()
2021-03-12 01:45:26,652 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:26,654 [main:107] - replacing (prope2 != 56, Boolean)
2021-03-12 01:45:26,654 [main:50] - replacing prope2 != 56 Boolean
2021-03-12 01:45:26,654 [main:54] - Getting value of type Boolean
2021-03-12 01:45:26,770 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:26,772 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:45:26,772 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:26,909 [main:67] - randomType = ULong
2021-03-12 01:45:27,031 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 01:45:27,073 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@f38f1fa]
2021-03-12 01:45:27,073 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4d17097b]
2021-03-12 01:45:27,074 [main:78] - Generated call from random type = (5438787430186299472.toULong()).toDouble().isNaN()
2021-03-12 01:45:27,074 [main:106] - GETTING Boolean from KClass<Ann>
2021-03-12 01:45:27,085 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]]
2021-03-12 01:45:27,085 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:27,204 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:27,205 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]
2021-03-12 01:45:27,319 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:27,321 [main:117] - GENERATED CALL = (Ann::class).equals("lmzso").or(true)
2021-03-12 01:45:27,321 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]]
2021-03-12 01:45:27,321 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:27,436 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]
2021-03-12 01:45:27,437 [main:117] - GENERATED CALL = (Ann::class).equals(null).not()
2021-03-12 01:45:27,437 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]]
2021-03-12 01:45:27,437 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:27,553 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:27,553 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:45:27,669 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:27,671 [main:117] - GENERATED CALL = (Ann::class).equals("ljmsv").and(false)
2021-03-12 01:45:27,671 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]]
2021-03-12 01:45:27,671 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:27,785 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:27,785 [main:117] - GENERATED CALL = (Ann::class).equals("wmckb")
2021-03-12 01:45:27,785 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]]
2021-03-12 01:45:27,785 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:27,929 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:27,929 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:45:28,058 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:28,061 [main:117] - GENERATED CALL = (Ann::class).equals("fpsbp").xor(true)
2021-03-12 01:45:28,061 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]]
2021-03-12 01:45:28,061 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]
2021-03-12 01:45:28,061 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.toBoolean()
2021-03-12 01:45:28,061 [main:113] - Case = [@kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]]
2021-03-12 01:45:28,061 [main:149] - GENERATING call of type @kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]
2021-03-12 01:45:28,178 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:28,179 [main:117] - GENERATED CALL = (Ann::class).isInstance("qqszf")
2021-03-12 01:45:28,179 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]]
2021-03-12 01:45:28,179 [main:149] - GENERATING call of type public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]
2021-03-12 01:45:28,291 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:28,405 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:28,407 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.equals("pnxcq", false)
2021-03-12 01:45:28,407 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]]
2021-03-12 01:45:28,407 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:28,528 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:28,528 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:45:28,640 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:28,641 [main:117] - GENERATED CALL = (Ann::class).equals("kbazl").equals("lgeho")
2021-03-12 01:45:28,641 [main:114] - replacement of prope2 != 56 of type Boolean is false
2021-03-12 01:45:28,754 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 01:45:28,755 [main:66] - Compilation checking started
2021-03-12 01:45:29,091 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (false) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:29,093 [main:107] - replacing (prope5, Int)
2021-03-12 01:45:29,093 [main:50] - replacing prope5 Int
2021-03-12 01:45:29,093 [main:54] - Getting value of type Int
2021-03-12 01:45:29,208 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:29,210 [main:58] - GENERATED VALUE OF TYPE Int = 965972717
2021-03-12 01:45:29,210 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:29,214 [main:67] - randomType = Boolean
2021-03-12 01:45:29,328 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:29,338 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:45:29,452 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:29,454 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2feea37d]
2021-03-12 01:45:29,455 [main:78] - Generated call from random type = (false).compareTo(true).toInt()
2021-03-12 01:45:29,455 [main:106] - GETTING Int from String
2021-03-12 01:45:29,475 [main:113] - Case = [public val kotlin.CharSequence.lastIndex: kotlin.Int defined in kotlin.text[DeserializedPropertyDescriptor@69826c32]]
2021-03-12 01:45:29,475 [main:117] - GENERATED CALL = (argName1).lastIndex
2021-03-12 01:45:29,475 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]]
2021-03-12 01:45:29,475 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:29,607 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:29,722 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:29,724 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.count(): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68397630]
2021-03-12 01:45:29,724 [main:117] - GENERATED CALL = (argName1).subSequence(-902981956, -1625378788).count()
2021-03-12 01:45:29,724 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@32702e11]]
2021-03-12 01:45:29,724 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:45:29,837 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:29,839 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@32702e11]
2021-03-12 01:45:29,839 [main:117] - GENERATED CALL = (argName1).compareTo("nldyo").inv()
2021-03-12 01:45:29,839 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]]
2021-03-12 01:45:29,839 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809]
2021-03-12 01:45:29,951 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:29,951 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:45:30,071 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:30,074 [main:117] - GENERATED CALL = (argName1).equals("zkqpp").compareTo(true)
2021-03-12 01:45:30,074 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@42ee2c95]]
2021-03-12 01:45:30,074 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@42ee2c95]
2021-03-12 01:45:30,074 [main:117] - GENERATED CALL = (argName1).length.takeHighestOneBit()
2021-03-12 01:45:30,074 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@78071dc3]]
2021-03-12 01:45:30,074 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:45:30,074 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@78071dc3]
2021-03-12 01:45:30,188 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:45:30,190 [main:117] - GENERATED CALL = (argName1).compareTo(argName1).times(71)
2021-03-12 01:45:30,190 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@35c7c5e]]
2021-03-12 01:45:30,190 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@35c7c5e]
2021-03-12 01:45:30,303 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:30,305 [main:117] - GENERATED CALL = (argName1).length.rotateRight(1342666387)
2021-03-12 01:45:30,305 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@52ed11cf]]
2021-03-12 01:45:30,305 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@52ed11cf]
2021-03-12 01:45:30,305 [main:117] - GENERATED CALL = (argName1).length.countOneBits()
2021-03-12 01:45:30,305 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@499c2c14]]
2021-03-12 01:45:30,305 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@499c2c14]
2021-03-12 01:45:30,418 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:30,420 [main:117] - GENERATED CALL = (argName1).length.coerceAtMost(-858649033)
2021-03-12 01:45:30,420 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.lastIndexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@864e36e]]
2021-03-12 01:45:30,420 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:30,533 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:30,648 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:30,650 [main:149] - GENERATING call of type public fun kotlin.CharSequence.lastIndexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@864e36e]
2021-03-12 01:45:30,763 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:30,881 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:30,999 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:31,001 [main:117] - GENERATED CALL = (argName1).subSequence(-1245839417, 1542170805).lastIndexOf('玥', 1997899891, true)
2021-03-12 01:45:31,001 [main:114] - replacement of prope5 of type Int is (argName1).length.takeHighestOneBit()
2021-03-12 01:45:31,148 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:31,148 [main:66] - Compilation checking started
2021-03-12 01:45:31,524 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + (argName1).length.takeHighestOneBit())
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:31,526 [main:107] - replacing (prope3, Kla0?)
2021-03-12 01:45:31,526 [main:50] - replacing prope3 Kla0?
2021-03-12 01:45:31,526 [main:54] - Getting value of type Kla0?
2021-03-12 01:45:31,638 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 01:45:31,640 [main:112] - generating klass Kla0 text = class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}
2021-03-12 01:45:31,640 [main:58] - GENERATED VALUE OF TYPE Kla0? = Kla0()
2021-03-12 01:45:31,641 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:31,771 [main:67] - randomType = Kla0
2021-03-12 01:45:31,883 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 01:45:31,885 [main:112] - generating klass Kla0 text = class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}
2021-03-12 01:45:31,890 [main:106] - GETTING Kla0? from String
2021-03-12 01:45:31,909 [main:106] - GETTING Kla0? from KClass<Ann>
2021-03-12 01:45:31,917 [main:106] - GETTING Kla0? from KClass<MyClass>
2021-03-12 01:45:31,923 [main:114] - replacement of prope3 of type Kla0? is Kla0()
2021-03-12 01:45:32,036 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:32,037 [main:66] - Compilation checking started
2021-03-12 01:45:32,375 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (Kla0()?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:32,377 [main:107] - replacing ({}, Function0<Unit>)
2021-03-12 01:45:32,377 [main:50] - replacing {} Function0<Unit>
2021-03-12 01:45:32,377 [main:54] - Getting value of type Function0<Unit>
2021-03-12 01:45:32,490 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 01:45:32,491 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:45:32,610 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 01:45:32,613 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 01:45:32,883 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 01:45:32,885 [main:95] - GENERATED = check(false)
2021-03-12 01:45:32,885 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { check(false)}
2021-03-12 01:45:32,885 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:32,889 [main:67] - randomType = Boolean
2021-03-12 01:45:33,002 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:33,013 [main:106] - GETTING Function0<Unit> from KClass<Ann>
2021-03-12 01:45:33,021 [main:106] - GETTING Function0<Unit> from String
2021-03-12 01:45:33,040 [main:106] - GETTING Function0<Unit> from KClass<MyClass>
2021-03-12 01:45:33,047 [main:114] - replacement of {} of type Function0<Unit> is { check(false)}
2021-03-12 01:45:33,160 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 01:45:33,160 [main:66] - Compilation checking started
2021-03-12 01:45:33,496 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = { check(false)}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:33,497 [main:107] - replacing (prope1, Kla5)
2021-03-12 01:45:33,497 [main:50] - replacing prope1 Kla5
2021-03-12 01:45:33,497 [main:54] - Getting value of type Kla5
2021-03-12 01:45:33,610 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 01:45:33,611 [main:112] - generating klass Kla5 text = class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 01:45:33,612 [main:58] - GENERATED VALUE OF TYPE Kla5 = Kla5()
2021-03-12 01:45:33,612 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:33,619 [main:67] - randomType = Kla0
2021-03-12 01:45:33,731 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 01:45:33,733 [main:112] - generating klass Kla0 text = class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}
2021-03-12 01:45:33,738 [main:106] - GETTING Kla5 from KClass<MyClass>
2021-03-12 01:45:33,746 [main:106] - GETTING Kla5 from KClass<Ann>
2021-03-12 01:45:33,753 [main:106] - GETTING Kla5 from String
2021-03-12 01:45:33,771 [main:114] - replacement of prope1 of type Kla5 is Kla5()
2021-03-12 01:45:33,884 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:33,885 [main:66] - Compilation checking started
2021-03-12 01:45:34,228 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            Kla5().prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:34,230 [main:107] - replacing (Kla4(), Kla4)
2021-03-12 01:45:34,230 [main:50] - replacing Kla4() Kla4
2021-03-12 01:45:34,230 [main:54] - Getting value of type Kla4
2021-03-12 01:45:34,346 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 01:45:34,348 [main:112] - generating klass Kla4 text = class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}
2021-03-12 01:45:34,348 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4()
2021-03-12 01:45:34,348 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:34,902 [main:67] - randomType = MutableMap<UShort, Collection<Int>>?
2021-03-12 01:45:34,903 [main:106] - GETTING Kla4 from String
2021-03-12 01:45:34,923 [main:106] - GETTING Kla4 from KClass<MyClass>
2021-03-12 01:45:34,930 [main:106] - GETTING Kla4 from KClass<Ann>
2021-03-12 01:45:34,937 [main:114] - replacement of Kla4() of type Kla4 is Kla4()
2021-03-12 01:45:35,048 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:35,050 [main:107] - replacing (prope7, Function0<Unit>)
2021-03-12 01:45:35,051 [main:50] - replacing prope7 Function0<Unit>
2021-03-12 01:45:35,051 [main:54] - Getting value of type Function0<Unit>
2021-03-12 01:45:35,166 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 01:45:35,168 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:45:35,173 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println()}
2021-03-12 01:45:35,173 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:35,558 [main:67] - randomType = Collection<UInt>
2021-03-12 01:45:35,560 [main:106] - GETTING Function0<Unit> from KClass<MyClass>
2021-03-12 01:45:35,569 [main:106] - GETTING Function0<Unit> from KClass<Ann>
2021-03-12 01:45:35,577 [main:106] - GETTING Function0<Unit> from String
2021-03-12 01:45:35,594 [main:114] - replacement of prope7 of type Function0<Unit> is { println()}
2021-03-12 01:45:35,709 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 01:45:35,709 [main:66] - Compilation checking started
2021-03-12 01:45:36,055 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        { println()} = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:36,057 [main:107] - replacing (exceptionOrNull(), Throwable?)
2021-03-12 01:45:36,057 [main:50] - replacing exceptionOrNull() Throwable?
2021-03-12 01:45:36,057 [main:54] - Getting value of type Throwable?
2021-03-12 01:45:36,180 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 01:45:36,185 [main:58] - GENERATED VALUE OF TYPE Throwable? = IndexOutOfBoundsException()
2021-03-12 01:45:36,185 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:36,193 [main:67] - randomType = Kla4
2021-03-12 01:45:36,330 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 01:45:36,332 [main:112] - generating klass Kla4 text = class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}
2021-03-12 01:45:36,339 [main:106] - GETTING Throwable? from String
2021-03-12 01:45:36,366 [main:106] - GETTING Throwable? from KClass<MyClass>
2021-03-12 01:45:36,377 [main:106] - GETTING Throwable? from KClass<Ann>
2021-03-12 01:45:36,388 [main:114] - replacement of exceptionOrNull() of type Throwable? is IndexOutOfBoundsException()
2021-03-12 01:45:36,504 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:36,506 [main:107] - replacing (prope2, Result<Any?>)
2021-03-12 01:45:36,506 [main:50] - replacing prope2 Result<Any?>
2021-03-12 01:45:36,506 [main:54] - Getting value of type Result<Any?>
2021-03-12 01:45:36,619 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 01:45:36,738 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 01:45:36,741 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 01:45:36,989 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 01:45:36,991 [main:302] - generating value of type = Any false depth = 4
2021-03-12 01:45:36,991 [main:95] - GENERATED = runCatching<Any?>({ "azlod"})
2021-03-12 01:45:36,991 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "azlod"})
2021-03-12 01:45:36,991 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:37,121 [main:67] - randomType = MyClass
2021-03-12 01:45:37,235 [main:302] - generating value of type = MyClass false depth = 0
2021-03-12 01:45:37,237 [main:112] - generating klass MyClass text = @Ann(O::class, K::class) class MyClass
2021-03-12 01:45:37,242 [main:106] - GETTING Result<Any?> from KClass<Ann>
2021-03-12 01:45:37,250 [main:106] - GETTING Result<Any?> from String
2021-03-12 01:45:37,270 [main:106] - GETTING Result<Any?> from KClass<MyClass>
2021-03-12 01:45:37,277 [main:114] - replacement of prope2 of type Result<Any?> is runCatching<Any?>({ "azlod"})
2021-03-12 01:45:37,391 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:37,391 [main:66] - Compilation checking started
2021-03-12 01:45:37,739 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
runCatching<Any?>({ "azlod"}).exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:37,741 [main:107] - replacing (getOrThrow(), Any?)
2021-03-12 01:45:37,742 [main:50] - replacing getOrThrow() Any?
2021-03-12 01:45:37,742 [main:54] - Getting value of type Any?
2021-03-12 01:45:37,859 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:37,859 [main:58] - GENERATED VALUE OF TYPE Any? = "mbnyn"
2021-03-12 01:45:37,859 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:37,989 [main:67] - randomType = UByte
2021-03-12 01:45:38,127 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 01:45:38,157 [main:106] - GETTING Any? from KClass<Ann>
2021-03-12 01:45:38,165 [main:106] - GETTING Any? from String
2021-03-12 01:45:38,184 [main:106] - GETTING Any? from KClass<MyClass>
2021-03-12 01:45:38,190 [main:114] - replacement of getOrThrow() of type Any? is "mbnyn"
2021-03-12 01:45:38,308 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 01:45:38,308 [main:66] - Compilation checking started
2021-03-12 01:45:38,645 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2."mbnyn"
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:38,647 [main:107] - replacing (true, Boolean)
2021-03-12 01:45:38,647 [main:50] - replacing true Boolean
2021-03-12 01:45:38,647 [main:54] - Getting value of type Boolean
2021-03-12 01:45:38,762 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:38,764 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:45:38,764 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:39,284 [main:67] - randomType = HashSet<UInt?>?
2021-03-12 01:45:39,400 [main:302] - generating value of type = HashSet<UInt?> false depth = 0
2021-03-12 01:45:39,520 [main:43] - GENERATING CALL OF fun <T> hashSetOf(): HashSet<UInt?> = TODO()
2021-03-12 01:45:39,523 [main:61] - WITHOUT TYPE PARAMS = fun <T> hashSetOf(): HashSet<UInt?> = TODO()
2021-03-12 01:45:39,644 [main:95] - GENERATED = hashSetOf<UInt?>()
2021-03-12 01:45:39,747 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.HashSet[DeserializedSimpleFunctionDescriptor@48b7ba7a]
2021-03-12 01:45:39,747 [main:149] - GENERATING call of type @kotlin.Deprecated @kotlin.SinceKotlin @kotlin.DeprecatedSinceKotlin public infix fun <T> kotlin.Array<out T>.contentEquals(other: kotlin.Array<out T>): kotlin.Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@74c26b9a]
2021-03-12 01:45:39,862 [main:302] - generating value of type = Array<out T> false depth = 0
2021-03-12 01:45:40,006 [main:43] - GENERATING CALL OF fun <T> arrayOfNulls(size: kotlin.Int): Array<T> = TODO()
2021-03-12 01:45:40,009 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayOfNulls(size: kotlin.Int): Array<T> = TODO()
2021-03-12 01:45:40,267 [main:302] - generating value of type = Int true depth = 3
2021-03-12 01:45:40,269 [main:95] - GENERATED = arrayOfNulls<T>(-2089095471)
2021-03-12 01:45:40,269 [main:78] - Generated call from random type = (hashSetOf<UInt?>())?.toArray().contentEquals(arrayOfNulls<T>(-2089095471))
2021-03-12 01:45:40,270 [main:106] - GETTING Boolean from String
2021-03-12 01:45:40,291 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.none(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8f8b18e]]
2021-03-12 01:45:40,292 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:40,408 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:40,525 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:40,527 [main:149] - GENERATING call of type public fun kotlin.CharSequence.none(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8f8b18e]
2021-03-12 01:45:40,527 [main:117] - GENERATED CALL = (argName1).subSequence(1932467632, -2123797649).none()
2021-03-12 01:45:40,528 [main:113] - Case = [public fun kotlin.String.endsWith(suffix: kotlin.String, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bf60561]]
2021-03-12 01:45:40,528 [main:149] - GENERATING call of type public fun kotlin.String.endsWith(suffix: kotlin.String, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bf60561]
2021-03-12 01:45:40,643 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:40,761 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:40,763 [main:117] - GENERATED CALL = (argName1).endsWith("xssbz", true)
2021-03-12 01:45:40,763 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@c8b54d3]]
2021-03-12 01:45:40,763 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:45:40,879 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:40,881 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@c8b54d3]
2021-03-12 01:45:40,881 [main:117] - GENERATED CALL = (argName1).get(-2043290381).isISOControl()
2021-03-12 01:45:40,881 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@dbf1def]]
2021-03-12 01:45:40,881 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:45:40,996 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:40,998 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@dbf1def]
2021-03-12 01:45:40,998 [main:117] - GENERATED CALL = (argName1).get(601038349).isLowSurrogate()
2021-03-12 01:45:40,998 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]]
2021-03-12 01:45:40,998 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809]
2021-03-12 01:45:41,114 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:41,114 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:45:41,230 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:41,232 [main:117] - GENERATED CALL = (argName1).equals("dmfiy").and(true)
2021-03-12 01:45:41,232 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@136e4907]]
2021-03-12 01:45:41,232 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:45:41,349 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:41,351 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@136e4907]
2021-03-12 01:45:41,351 [main:117] - GENERATED CALL = (argName1).get(-1429546142).isSurrogate()
2021-03-12 01:45:41,351 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.startsWith(char: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@639a38d0]]
2021-03-12 01:45:41,351 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:41,466 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:41,613 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:41,616 [main:149] - GENERATING call of type public fun kotlin.CharSequence.startsWith(char: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@639a38d0]
2021-03-12 01:45:41,749 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:41,869 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:41,872 [main:117] - GENERATED CALL = (argName1).subSequence(1576022826, 1467935914).startsWith('허', true)
2021-03-12 01:45:41,872 [main:113] - Case = [public inline fun kotlin.CharSequence.all(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1ac2dc77]]
2021-03-12 01:45:41,872 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.all(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1ac2dc77]
2021-03-12 01:45:41,987 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:45:41,989 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:45:41,991 [main:117] - GENERATED CALL = (argName1).all({a: Char -> true})
2021-03-12 01:45:41,991 [main:113] - Case = [public fun kotlin.CharSequence.regionMatches(thisOffset: kotlin.Int, other: kotlin.CharSequence, otherOffset: kotlin.Int, length: kotlin.Int, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7c3d71f2]]
2021-03-12 01:45:41,991 [main:149] - GENERATING call of type public fun kotlin.CharSequence.regionMatches(thisOffset: kotlin.Int, other: kotlin.CharSequence, otherOffset: kotlin.Int, length: kotlin.Int, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7c3d71f2]
2021-03-12 01:45:42,109 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:42,233 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:45:42,353 [main:43] - GENERATING CALL OF fun StringBuilder(content: kotlin.String): CharSequence = TODO()
2021-03-12 01:45:42,356 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(content: kotlin.String): CharSequence = TODO()
2021-03-12 01:45:42,603 [main:302] - generating value of type = String true depth = 3
2021-03-12 01:45:42,605 [main:95] - GENERATED = StringBuilder("objlp")
2021-03-12 01:45:42,719 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:42,836 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:42,953 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:42,955 [main:117] - GENERATED CALL = (argName1).regionMatches(-1057931435, StringBuilder("objlp"), -1092415101, 1535016213, false)
2021-03-12 01:45:42,956 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.hasSurrogatePairAt(index: kotlin.Int): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68b4ba41]]
2021-03-12 01:45:42,956 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:45:43,072 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:43,218 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:43,221 [main:149] - GENERATING call of type public fun kotlin.CharSequence.hasSurrogatePairAt(index: kotlin.Int): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@68b4ba41]
2021-03-12 01:45:43,353 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:43,355 [main:117] - GENERATED CALL = (argName1).subSequence(-976193414, -600188504).hasSurrogatePairAt(36565436)
2021-03-12 01:45:43,355 [main:114] - replacement of true of type Boolean is (argName1).subSequence(1932467632, -2123797649).none()
2021-03-12 01:45:43,474 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:45:43,474 [main:66] - Compilation checking started
2021-03-12 01:45:43,825 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == (argName1).subSequence(1932467632, -2123797649).none() }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:43,826 [main:107] - replacing (c !is CoroutineStackFrame, Boolean)
2021-03-12 01:45:43,827 [main:50] - replacing c !is CoroutineStackFrame Boolean
2021-03-12 01:45:43,827 [main:54] - Getting value of type Boolean
2021-03-12 01:45:43,941 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:43,943 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:45:43,943 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:43,951 [main:67] - randomType = Kla2
2021-03-12 01:45:44,067 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 01:45:44,069 [main:112] - generating klass Kla2 text = class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}
2021-03-12 01:45:44,087 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla2[DeserializedSimpleFunctionDescriptor@4a059b25]
2021-03-12 01:45:44,208 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:44,209 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:45:44,324 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:44,326 [main:78] - Generated call from random type = (Kla2()).equals("tcjmt").and(true)
2021-03-12 01:45:44,327 [main:106] - GETTING Boolean from KClass<Ann>
2021-03-12 01:45:44,334 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]]
2021-03-12 01:45:44,334 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:44,449 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:44,449 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:45:44,563 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:44,565 [main:117] - GENERATED CALL = (Ann::class).equals("rpljj").xor(false)
2021-03-12 01:45:44,566 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]]
2021-03-12 01:45:44,566 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:44,681 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:44,681 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:45:44,796 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:44,797 [main:117] - GENERATED CALL = (Ann::class).equals("ndaux").equals("pzqgy")
2021-03-12 01:45:44,797 [main:113] - Case = [@kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]]
2021-03-12 01:45:44,797 [main:149] - GENERATING call of type @kotlin.SinceKotlin public abstract fun isInstance(value: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@203f8e29]
2021-03-12 01:45:44,911 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:44,912 [main:117] - GENERATED CALL = (Ann::class).isInstance("sqeka")
2021-03-12 01:45:44,912 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]]
2021-03-12 01:45:44,912 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String?.toBoolean(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44d5c34f]
2021-03-12 01:45:44,912 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.toBoolean()
2021-03-12 01:45:44,912 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]]
2021-03-12 01:45:44,912 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:45,055 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:45,055 [main:117] - GENERATED CALL = (Ann::class).equals("ytzzc")
2021-03-12 01:45:45,059 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]]
2021-03-12 01:45:45,059 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:45,175 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:45,176 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]
2021-03-12 01:45:45,299 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:45,301 [main:117] - GENERATED CALL = (Ann::class).equals("heqnr").or(false)
2021-03-12 01:45:45,301 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]]
2021-03-12 01:45:45,301 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:45,415 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:45,416 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1de1311e]
2021-03-12 01:45:45,416 [main:117] - GENERATED CALL = (Ann::class).equals("smmue").not()
2021-03-12 01:45:45,416 [main:113] - Case = [public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]]
2021-03-12 01:45:45,416 [main:149] - GENERATING call of type public abstract fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.reflect.KClass[DeserializedSimpleFunctionDescriptor@6ca67c28]
2021-03-12 01:45:45,530 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:45,530 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@1bfd2bc6]
2021-03-12 01:45:45,644 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:45,646 [main:117] - GENERATED CALL = (Ann::class).equals("hynsu").and(true)
2021-03-12 01:45:45,647 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]]
2021-03-12 01:45:45,647 [main:149] - GENERATING call of type public fun kotlin.String?.equals(other: kotlin.String?, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fd470ec]
2021-03-12 01:45:45,761 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:45,878 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:45,880 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.equals("djzub", true)
2021-03-12 01:45:45,880 [main:114] - replacement of c !is CoroutineStackFrame of type Boolean is (Ann::class).qualifiedName?.toBoolean()
2021-03-12 01:45:45,995 [main:33] - Trying to replace Element(IS_EXPRESSION) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:45:45,995 [main:66] - Compilation checking started
2021-03-12 01:45:46,344 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if ((Ann::class).qualifiedName?.toBoolean()) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:46,346 [main:107] - replacing ("OK", String)
2021-03-12 01:45:46,347 [main:50] - replacing "OK" String
2021-03-12 01:45:46,347 [main:54] - Getting value of type String
2021-03-12 01:45:46,463 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:46,465 [main:58] - GENERATED VALUE OF TYPE String = "rwrob"
2021-03-12 01:45:46,465 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:46,597 [main:67] - randomType = O
2021-03-12 01:45:46,712 [main:302] - generating value of type = O false depth = 0
2021-03-12 01:45:46,714 [main:112] - generating klass O text = class O
2021-03-12 01:45:46,719 [main:106] - GETTING String from KClass<MyClass>
2021-03-12 01:45:46,726 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7]]
2021-03-12 01:45:46,727 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName
2021-03-12 01:45:46,727 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:45:46,727 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:45:46,850 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:46,850 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.plus("coqgh")
2021-03-12 01:45:46,850 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@20dad990]]
2021-03-12 01:45:46,851 [main:117] - GENERATED CALL = (MyClass::class).simpleName
2021-03-12 01:45:46,851 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:45:46,851 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:45:46,851 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.orEmpty()
2021-03-12 01:45:46,851 [main:114] - replacement of "OK" of type String is (MyClass::class).qualifiedName?.plus("coqgh")
2021-03-12 01:45:46,988 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:45:46,988 [main:66] - Compilation checking started
2021-03-12 01:45:47,328 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return (MyClass::class).qualifiedName?.plus("coqgh")
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:47,330 [main:107] - replacing (prope2.getOrThrow(), Ty0)
2021-03-12 01:45:47,331 [main:50] - replacing prope2.getOrThrow() Ty0
2021-03-12 01:45:47,331 [main:54] - Getting value of type Ty0
2021-03-12 01:45:47,447 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 01:45:47,452 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 01:45:47,984 [main:67] - randomType = HashMap<UByte?, Kla6>
2021-03-12 01:45:48,101 [main:302] - generating value of type = HashMap<UByte?, Kla6> false depth = 0
2021-03-12 01:45:48,224 [main:43] - GENERATING CALL OF fun <K, V> LinkedHashMap(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): HashMap<UByte?, Kla6> = TODO()
2021-03-12 01:45:48,227 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> LinkedHashMap(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): HashMap<UByte?, Kla6> = TODO()
2021-03-12 01:45:48,617 [main:302] - generating value of type = Int true depth = 3
2021-03-12 01:45:48,620 [main:302] - generating value of type = Float true depth = 3
2021-03-12 01:45:48,622 [main:95] - GENERATED = LinkedHashMap<UByte?, Kla6>(1378625972, 0.48179084f)
2021-03-12 01:45:48,716 [main:106] - GETTING Ty0 from String
2021-03-12 01:45:48,735 [main:106] - GETTING Ty0 from KClass<Ann>
2021-03-12 01:45:48,742 [main:106] - GETTING Ty0 from KClass<MyClass>
2021-03-12 01:45:48,749 [main:111] - Cant find and generate replacement for prope2.getOrThrow() type Ty0
2021-03-12 01:45:48,749 [main:107] - replacing ("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got ", String)
2021-03-12 01:45:48,749 [main:50] - replacing "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " String
2021-03-12 01:45:48,749 [main:54] - Getting value of type String
2021-03-12 01:45:48,865 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:48,867 [main:58] - GENERATED VALUE OF TYPE String = "tzjej"
2021-03-12 01:45:48,867 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:49,289 [main:67] - randomType = Function1<UShort, Kla6>
2021-03-12 01:45:49,290 [main:106] - GETTING String from String
2021-03-12 01:45:49,308 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2be1aa4e]]
2021-03-12 01:45:49,309 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:45:49,425 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:49,427 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@2be1aa4e]
2021-03-12 01:45:49,544 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:49,546 [main:117] - GENERATED CALL = (argName1).get(-1147942602).plus("usner")
2021-03-12 01:45:49,547 [main:113] - Case = [public inline fun kotlin.String.filter(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1a3dc5eb]]
2021-03-12 01:45:49,547 [main:149] - GENERATING call of type public inline fun kotlin.String.filter(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1a3dc5eb]
2021-03-12 01:45:49,663 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:45:49,665 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:45:49,667 [main:117] - GENERATED CALL = (argName1).filter({a: Char -> true})
2021-03-12 01:45:49,667 [main:113] - Case = [public fun kotlin.String.take(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@45ed6e0a]]
2021-03-12 01:45:49,667 [main:149] - GENERATING call of type public fun kotlin.String.take(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@45ed6e0a]
2021-03-12 01:45:49,784 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:49,786 [main:117] - GENERATED CALL = (argName1).take(1338150944)
2021-03-12 01:45:49,786 [main:113] - Case = [public fun kotlin.String.dropLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@459c7191]]
2021-03-12 01:45:49,786 [main:149] - GENERATING call of type public fun kotlin.String.dropLast(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@459c7191]
2021-03-12 01:45:49,903 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:49,905 [main:117] - GENERATED CALL = (argName1).dropLast(-1172004882)
2021-03-12 01:45:49,905 [main:113] - Case = [public fun kotlin.String.padStart(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@283e9d49]]
2021-03-12 01:45:49,905 [main:149] - GENERATING call of type public fun kotlin.String.padStart(length: kotlin.Int, padChar: kotlin.Char = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@283e9d49]
2021-03-12 01:45:50,021 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:50,139 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:50,141 [main:117] - GENERATED CALL = (argName1).padStart(55430275, '')
2021-03-12 01:45:50,300 [main:113] - Case = [public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@158ccbe]]
2021-03-12 01:45:50,300 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonPrefixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@158ccbe]
2021-03-12 01:45:50,418 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:45:50,540 [main:43] - GENERATING CALL OF fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-12 01:45:50,542 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(content: kotlin.CharSequence): CharSequence = TODO()
2021-03-12 01:45:50,796 [main:302] - generating value of type = CharSequence false depth = 3
2021-03-12 01:45:50,801 [main:95] - GENERATED = StringBuilder("fzufw")
2021-03-12 01:45:50,917 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:45:50,919 [main:117] - GENERATED CALL = (argName1).commonPrefixWith(StringBuilder("fzufw"), true)
2021-03-12 01:45:50,919 [main:113] - Case = [public fun kotlin.String.replaceAfterLast(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bdc0fd]]
2021-03-12 01:45:50,919 [main:149] - GENERATING call of type public fun kotlin.String.replaceAfterLast(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@8bdc0fd]
2021-03-12 01:45:51,083 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:51,231 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:51,233 [main:117] - GENERATED CALL = (argName1).replaceAfterLast('읜', val argName2 = args[1].simpleName ?: "fail 2"
2021-03-12 01:45:51,233 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.trim(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6e5bf43d]]
2021-03-12 01:45:51,233 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.trim(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6e5bf43d]
2021-03-12 01:45:51,233 [main:117] - GENERATED CALL = (argName1).trim()
2021-03-12 01:45:51,233 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.toUpperCase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44cab771]]
2021-03-12 01:45:51,233 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.toUpperCase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44cab771]
2021-03-12 01:45:51,233 [main:117] - GENERATED CALL = (argName1).toUpperCase()
2021-03-12 01:45:51,233 [main:113] - Case = [public inline fun kotlin.String.takeLastWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1d547efb]]
2021-03-12 01:45:51,234 [main:149] - GENERATING call of type public inline fun kotlin.String.takeLastWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1d547efb]
2021-03-12 01:45:51,357 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:45:51,359 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:45:51,362 [main:117] - GENERATED CALL = (argName1).takeLastWhile({a: Char -> true})
2021-03-12 01:45:51,362 [main:114] - replacement of "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " of type String is "tzjej"
2021-03-12 01:45:51,478 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 01:45:51,478 [main:66] - Compilation checking started
2021-03-12 01:45:51,814 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("tzjej" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:51,816 [main:107] - replacing (prope2, Result<Any?>)
2021-03-12 01:45:51,816 [main:50] - replacing prope2 Result<Any?>
2021-03-12 01:45:51,816 [main:54] - Getting value of type Result<Any?>
2021-03-12 01:45:51,932 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 01:45:52,053 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 01:45:52,056 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 01:45:52,311 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 01:45:52,313 [main:302] - generating value of type = Any false depth = 4
2021-03-12 01:45:52,313 [main:95] - GENERATED = runCatching<Any?>({ "iuqgb"})
2021-03-12 01:45:52,313 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "iuqgb"})
2021-03-12 01:45:52,313 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:52,576 [main:67] - randomType = K?
2021-03-12 01:45:52,693 [main:302] - generating value of type = K false depth = 0
2021-03-12 01:45:52,695 [main:112] - generating klass K text = class K
2021-03-12 01:45:52,700 [main:106] - GETTING Result<Any?> from String
2021-03-12 01:45:52,720 [main:106] - GETTING Result<Any?> from KClass<Ann>
2021-03-12 01:45:52,728 [main:106] - GETTING Result<Any?> from KClass<MyClass>
2021-03-12 01:45:52,738 [main:114] - replacement of prope2 of type Result<Any?> is runCatching<Any?>({ "iuqgb"})
2021-03-12 01:45:52,880 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:52,880 [main:66] - Compilation checking started
2021-03-12 01:45:53,222 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = runCatching<Any?>({ "iuqgb"}).getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:53,224 [main:107] - replacing ("\n", String)
2021-03-12 01:45:53,224 [main:50] - replacing "\n" String
2021-03-12 01:45:53,225 [main:54] - Getting value of type String
2021-03-12 01:45:53,341 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:45:53,343 [main:58] - GENERATED VALUE OF TYPE String = "fnzlc"
2021-03-12 01:45:53,343 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:53,881 [main:67] - randomType = HashMap<Kla2, Long?>?
2021-03-12 01:45:53,997 [main:302] - generating value of type = HashMap<Kla2, Long?> false depth = 0
2021-03-12 01:45:54,120 [main:43] - GENERATING CALL OF fun <K, V> hashMapOf(): HashMap<Kla2, Long?> = TODO()
2021-03-12 01:45:54,123 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> hashMapOf(): HashMap<Kla2, Long?> = TODO()
2021-03-12 01:45:54,244 [main:95] - GENERATED = hashMapOf<Kla2, Long?>()
2021-03-12 01:45:54,340 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@b810d92]
2021-03-12 01:45:54,457 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:45:54,459 [main:78] - Generated call from random type = (hashMapOf<Kla2, Long?>())?.size.toString(326536678)
2021-03-12 01:45:54,461 [main:106] - GETTING String from KClass<MyClass>
2021-03-12 01:45:54,468 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:45:54,468 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:45:54,584 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:45:54,585 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.plus("ldcin")
2021-03-12 01:45:54,585 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@20dad990]]
2021-03-12 01:45:54,585 [main:117] - GENERATED CALL = (MyClass::class).simpleName
2021-03-12 01:45:54,585 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7]]
2021-03-12 01:45:54,585 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName
2021-03-12 01:45:54,585 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:45:54,585 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:45:54,585 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.orEmpty()
2021-03-12 01:45:54,585 [main:114] - replacement of "\n" of type String is (MyClass::class).qualifiedName?.orEmpty()
2021-03-12 01:45:54,701 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 01:45:54,702 [main:66] - Compilation checking started
2021-03-12 01:45:55,077 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = (MyClass::class).qualifiedName?.orEmpty())) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:55,079 [main:107] - replacing ({}, Function0<Unit>)
2021-03-12 01:45:55,079 [main:50] - replacing {} Function0<Unit>
2021-03-12 01:45:55,079 [main:54] - Getting value of type Function0<Unit>
2021-03-12 01:45:55,199 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 01:45:55,201 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:45:55,325 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:45:55,328 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:45:55,580 [main:302] - generating value of type = Any false depth = 4
2021-03-12 01:45:55,580 [main:95] - GENERATED = println("emhfv")
2021-03-12 01:45:55,580 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println("emhfv")}
2021-03-12 01:45:55,580 [main:61] - GENERATED IS CALL =false
2021-03-12 01:45:55,972 [main:67] - randomType = HashSet<Float?>
2021-03-12 01:45:56,089 [main:302] - generating value of type = HashSet<Float?> false depth = 0
2021-03-12 01:45:56,211 [main:43] - GENERATING CALL OF fun <T> hashSetOf(elements: Float?): HashSet<Float?> = TODO()
2021-03-12 01:45:56,214 [main:61] - WITHOUT TYPE PARAMS = fun <T> hashSetOf(elements: Float?): HashSet<Float?> = TODO()
2021-03-12 01:45:56,336 [main:302] - generating value of type = Float true depth = 3
2021-03-12 01:45:56,338 [main:95] - GENERATED = hashSetOf<Float?>(0.6682069f)
2021-03-12 01:45:56,456 [main:106] - GETTING Function0<Unit> from KClass<Ann>
2021-03-12 01:45:56,464 [main:106] - GETTING Function0<Unit> from KClass<MyClass>
2021-03-12 01:45:56,472 [main:106] - GETTING Function0<Unit> from String
2021-03-12 01:45:56,490 [main:114] - replacement of {} of type Function0<Unit> is { println("emhfv")}
2021-03-12 01:45:56,606 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 01:45:56,606 [main:66] - Compilation checking started
2021-03-12 01:45:56,979 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = { println("emhfv")}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:56,981 [main:107] - replacing (prope1, Kla5)
2021-03-12 01:45:56,982 [main:50] - replacing prope1 Kla5
2021-03-12 01:45:56,982 [main:54] - Getting value of type Kla5
2021-03-12 01:45:57,101 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 01:45:57,103 [main:112] - generating klass Kla5 text = class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 01:45:57,103 [main:58] - GENERATED VALUE OF TYPE Kla5 = Kla5()
2021-03-12 01:45:57,103 [main:61] - GENERATED IS CALL =true
2021-03-12 01:45:57,233 [main:67] - randomType = Char
2021-03-12 01:45:57,349 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:45:57,370 [main:106] - GETTING Kla5 from KClass<Ann>
2021-03-12 01:45:57,379 [main:106] - GETTING Kla5 from KClass<MyClass>
2021-03-12 01:45:57,387 [main:106] - GETTING Kla5 from String
2021-03-12 01:45:57,404 [main:114] - replacement of prope1 of type Kla5 is Kla5()
2021-03-12 01:45:57,528 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 01:45:57,528 [main:66] - Compilation checking started
2021-03-12 01:45:57,875 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
Kla5().prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:45:57,876 [main:107] - replacing (c, Continuation<*>)
2021-03-12 01:45:57,877 [main:50] - replacing c Continuation<*>
2021-03-12 01:45:57,877 [main:54] - Getting value of type Continuation<*>
2021-03-12 01:45:57,993 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 01:45:58,115 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:45:58,118 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:45:58,508 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 01:45:58,629 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:45:58,632 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:45:58,891 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 01:45:59,052 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:45:59,055 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:45:59,456 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:45:59,456 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:45:59,456 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:45:59,456 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 01:45:59,587 [main:67] - randomType = Short
2021-03-12 01:45:59,704 [main:302] - generating value of type = Short true depth = 0
2021-03-12 01:45:59,737 [main:106] - GETTING Continuation<*> from KClass<MyClass>
2021-03-12 01:45:59,745 [main:106] - GETTING Continuation<*> from String
2021-03-12 01:45:59,764 [main:106] - GETTING Continuation<*> from KClass<Ann>
2021-03-12 01:45:59,771 [main:111] - Cant find and generate replacement for c type Continuation<*>
2021-03-12 01:45:59,771 [main:107] - replacing (c, SuspendFunction0<Unit>)
2021-03-12 01:45:59,772 [main:50] - replacing c SuspendFunction0<Unit>
2021-03-12 01:45:59,772 [main:54] - Getting value of type SuspendFunction0<Unit>
2021-03-12 01:45:59,889 [main:302] - generating value of type = SuspendFunction0<Unit> false depth = 0
2021-03-12 01:45:59,891 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 01:46:00,014 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:46:00,017 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 01:46:00,274 [main:302] - generating value of type = Any false depth = 4
2021-03-12 01:46:00,274 [main:95] - GENERATED = print("pnjym")
2021-03-12 01:46:00,276 [main:58] - GENERATED VALUE OF TYPE SuspendFunction0<Unit> = { print("pnjym")}
2021-03-12 01:46:00,276 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:00,407 [main:67] - randomType = Double
2021-03-12 01:46:00,524 [main:302] - generating value of type = Double true depth = 0
2021-03-12 01:46:00,556 [main:106] - GETTING SuspendFunction0<Unit> from KClass<Ann>
2021-03-12 01:46:00,564 [main:106] - GETTING SuspendFunction0<Unit> from KClass<MyClass>
2021-03-12 01:46:00,572 [main:106] - GETTING SuspendFunction0<Unit> from String
2021-03-12 01:46:00,590 [main:114] - replacement of c of type SuspendFunction0<Unit> is { print("pnjym")}
2021-03-12 01:46:00,708 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 01:46:00,708 [main:66] - Compilation checking started
2021-03-12 01:46:01,053 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
{ print("pnjym")}.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:01,055 [main:107] - replacing ("tail-call optimization miss: method at " + it + " has state-machine ", String)
2021-03-12 01:46:01,055 [main:50] - replacing "tail-call optimization miss: method at " + it + " has state-machine " String
2021-03-12 01:46:01,055 [main:54] - Getting value of type String
2021-03-12 01:46:01,195 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:46:01,198 [main:58] - GENERATED VALUE OF TYPE String = "vuapt"
2021-03-12 01:46:01,198 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:02,282 [main:67] - randomType = Function1<MutableMap<Char, Collection<Byte?>>?, Boolean?>
2021-03-12 01:46:02,283 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:46:02,294 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:46:02,295 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:46:02,295 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:46:02,295 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:46:02,295 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:46:02,295 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:46:02,295 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:46:02,295 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:46:02,295 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:46:02,414 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:02,414 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("awrfa")
2021-03-12 01:46:02,414 [main:114] - replacement of "tail-call optimization miss: method at " + it + " has state-machine " of type String is (Ann::class).simpleName
2021-03-12 01:46:02,531 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:46:02,531 [main:66] - Compilation checking started
2021-03-12 01:46:02,880 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error((Ann::class).simpleName +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:02,882 [main:107] - replacing (prope6, Boolean)
2021-03-12 01:46:02,882 [main:50] - replacing prope6 Boolean
2021-03-12 01:46:02,882 [main:54] - Getting value of type Boolean
2021-03-12 01:46:03,000 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:03,002 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:46:03,002 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:03,138 [main:67] - randomType = O
2021-03-12 01:46:03,260 [main:302] - generating value of type = O false depth = 0
2021-03-12 01:46:03,262 [main:112] - generating klass O text = class O
2021-03-12 01:46:03,266 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in O[DeserializedSimpleFunctionDescriptor@12b80dfa]
2021-03-12 01:46:03,410 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:03,410 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:46:03,526 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:03,526 [main:78] - Generated call from random type = (O()).equals("nhamp").equals("vomxw")
2021-03-12 01:46:03,526 [main:114] - replacement of prope6 of type Boolean is (O()).equals("nhamp").equals("vomxw")
2021-03-12 01:46:03,651 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:46:03,652 [main:66] - Compilation checking started
2021-03-12 01:46:03,994 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        (O()).equals("nhamp").equals("vomxw") = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:03,996 [main:107] - replacing (it?.methodName?.startsWith(method) == true, Boolean)
2021-03-12 01:46:03,996 [main:50] - replacing it?.methodName?.startsWith(method) == true Boolean
2021-03-12 01:46:03,996 [main:54] - Getting value of type Boolean
2021-03-12 01:46:04,114 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:04,116 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:46:04,116 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:04,247 [main:67] - randomType = Float
2021-03-12 01:46:04,364 [main:302] - generating value of type = Float true depth = 0
2021-03-12 01:46:04,395 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@4a9fdee6]
2021-03-12 01:46:04,396 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@dbf1def]
2021-03-12 01:46:04,396 [main:78] - Generated call from random type = (0.27782333f).toChar().isLowSurrogate()
2021-03-12 01:46:04,397 [main:106] - GETTING Boolean from String
2021-03-12 01:46:04,415 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3fdc03d3]]
2021-03-12 01:46:04,415 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:46:04,533 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:04,535 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3fdc03d3]
2021-03-12 01:46:04,535 [main:117] - GENERATED CALL = (argName1).get(1468418068).isLetter()
2021-03-12 01:46:04,535 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@722d49bb]]
2021-03-12 01:46:04,535 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:46:04,654 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:04,656 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@722d49bb]
2021-03-12 01:46:04,656 [main:117] - GENERATED CALL = (argName1).get(1536894616).isTitleCase()
2021-03-12 01:46:04,657 [main:113] - Case = [public operator fun kotlin.CharSequence.contains(char: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40de5fcd]]
2021-03-12 01:46:04,657 [main:149] - GENERATING call of type public operator fun kotlin.CharSequence.contains(char: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@40de5fcd]
2021-03-12 01:46:04,773 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:46:04,892 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:04,894 [main:117] - GENERATED CALL = (argName1).contains('₮', false)
2021-03-12 01:46:04,894 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.isBlank(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4f16bac1]]
2021-03-12 01:46:04,894 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:46:05,012 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:05,139 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:05,141 [main:149] - GENERATING call of type public fun kotlin.CharSequence.isBlank(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4f16bac1]
2021-03-12 01:46:05,141 [main:117] - GENERATED CALL = (argName1).subSequence(1415518690, -1714294981).isBlank()
2021-03-12 01:46:05,141 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]]
2021-03-12 01:46:05,141 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809]
2021-03-12 01:46:05,258 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:05,258 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@f45db3e]
2021-03-12 01:46:05,375 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:05,377 [main:117] - GENERATED CALL = (argName1).equals("tsshk").or(false)
2021-03-12 01:46:05,379 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]]
2021-03-12 01:46:05,379 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809]
2021-03-12 01:46:05,498 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:05,499 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@52355090]
2021-03-12 01:46:05,638 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:05,641 [main:117] - GENERATED CALL = (argName1).equals("gcknt").xor(true)
2021-03-12 01:46:05,641 [main:113] - Case = [public fun kotlin.CharSequence.regionMatches(thisOffset: kotlin.Int, other: kotlin.CharSequence, otherOffset: kotlin.Int, length: kotlin.Int, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7c3d71f2]]
2021-03-12 01:46:05,641 [main:149] - GENERATING call of type public fun kotlin.CharSequence.regionMatches(thisOffset: kotlin.Int, other: kotlin.CharSequence, otherOffset: kotlin.Int, length: kotlin.Int, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7c3d71f2]
2021-03-12 01:46:05,757 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:05,876 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:46:05,997 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:06,116 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:06,234 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:06,236 [main:117] - GENERATED CALL = (argName1).regionMatches(1266370634, "vkmft", -465261926, 598097385, false)
2021-03-12 01:46:06,236 [main:113] - Case = [public fun kotlin.CharSequence.isBlank(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4f16bac1]]
2021-03-12 01:46:06,236 [main:149] - GENERATING call of type public fun kotlin.CharSequence.isBlank(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4f16bac1]
2021-03-12 01:46:06,236 [main:117] - GENERATED CALL = (argName1).isBlank()
2021-03-12 01:46:06,236 [main:113] - Case = [public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@26fa70ec]]
2021-03-12 01:46:06,236 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@3bf327e3]
2021-03-12 01:46:06,353 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:06,355 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@26fa70ec]
2021-03-12 01:46:06,355 [main:117] - GENERATED CALL = (argName1).get(1071502352).isWhitespace()
2021-03-12 01:46:06,355 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]]
2021-03-12 01:46:06,355 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor@5047a809]
2021-03-12 01:46:06,473 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:46:06,590 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:06,591 [main:117] - GENERATED CALL = (argName1).equals(null).equals("uoimc")
2021-03-12 01:46:06,591 [main:114] - replacement of it?.methodName?.startsWith(method) == true of type Boolean is (argName1).get(1468418068).isLetter()
2021-03-12 01:46:06,707 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:46:06,707 [main:66] - Compilation checking started
2021-03-12 01:46:07,057 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { (argName1).get(1468418068).isLetter() }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:07,060 [main:107] - replacing ("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"), String)
2021-03-12 01:46:07,060 [main:50] - replacing "tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n") String
2021-03-12 01:46:07,060 [main:54] - Getting value of type String
2021-03-12 01:46:07,178 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:46:07,180 [main:58] - GENERATED VALUE OF TYPE String = "xjcei"
2021-03-12 01:46:07,180 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:07,315 [main:67] - randomType = MyClass
2021-03-12 01:46:07,432 [main:302] - generating value of type = MyClass false depth = 0
2021-03-12 01:46:07,434 [main:112] - generating klass MyClass text = @Ann(O::class, K::class) class MyClass
2021-03-12 01:46:07,438 [main:106] - GETTING String from KClass<Ann>
2021-03-12 01:46:07,445 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@3dd509ec]]
2021-03-12 01:46:07,445 [main:117] - GENERATED CALL = (Ann::class).simpleName
2021-03-12 01:46:07,445 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:46:07,445 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:46:07,575 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:07,576 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.plus("yligx")
2021-03-12 01:46:07,576 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:46:07,576 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:46:07,576 [main:117] - GENERATED CALL = (Ann::class).qualifiedName?.orEmpty()
2021-03-12 01:46:07,576 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@51a63f7b]]
2021-03-12 01:46:07,576 [main:117] - GENERATED CALL = (Ann::class).qualifiedName
2021-03-12 01:46:07,576 [main:114] - replacement of "tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n") of type String is "xjcei"
2021-03-12 01:46:07,692 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 01:46:07,693 [main:66] - Compilation checking started
2021-03-12 01:46:08,059 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("xjcei")
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:08,062 [main:107] - replacing (0, Int)
2021-03-12 01:46:08,062 [main:50] - replacing 0 Int
2021-03-12 01:46:08,062 [main:54] - Getting value of type Int
2021-03-12 01:46:08,191 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:08,193 [main:58] - GENERATED VALUE OF TYPE Int = 1822967593
2021-03-12 01:46:08,193 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:08,462 [main:67] - randomType = O?
2021-03-12 01:46:08,578 [main:302] - generating value of type = O false depth = 0
2021-03-12 01:46:08,580 [main:112] - generating klass O text = class O
2021-03-12 01:46:08,584 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in O[DeserializedSimpleFunctionDescriptor@517b9026]
2021-03-12 01:46:08,701 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:08,701 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@5408d7d3]
2021-03-12 01:46:08,817 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:08,820 [main:78] - Generated call from random type = (O())?.equals("ijoii").compareTo(false)
2021-03-12 01:46:08,820 [main:114] - replacement of 0 of type Int is (O())?.equals("ijoii").compareTo(false)
2021-03-12 01:46:08,936 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:46:08,936 [main:66] - Compilation checking started
2021-03-12 01:46:09,303 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = (O())?.equals("ijoii").compareTo(false)

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:09,305 [main:107] - replacing (method, String)
2021-03-12 01:46:09,305 [main:50] - replacing method String
2021-03-12 01:46:09,305 [main:54] - Getting value of type String
2021-03-12 01:46:09,422 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:46:09,424 [main:58] - GENERATED VALUE OF TYPE String = "pwyfk"
2021-03-12 01:46:09,424 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:10,525 [main:67] - randomType = Triple<ArrayList<UInt>, Pair<ULong, UShort?>, O>
2021-03-12 01:46:10,642 [main:302] - generating value of type = Triple<ArrayList<UInt>, Pair<ULong, UShort?>, O> false depth = 0
2021-03-12 01:46:10,767 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: ArrayList<UInt>, second: Pair<ULong, UShort?>, third: O): Triple<ArrayList<UInt>, Pair<ULong, UShort?>, O> = TODO()
2021-03-12 01:46:10,770 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: ArrayList<UInt>, second: Pair<ULong, UShort?>, third: O): Triple<ArrayList<UInt>, Pair<ULong, UShort?>, O> = TODO()
2021-03-12 01:46:10,893 [main:302] - generating value of type = ArrayList<UInt> false depth = 3
2021-03-12 01:46:11,015 [main:43] - GENERATING CALL OF fun <T> arrayListOf(elements: UInt): ArrayList<UInt> = TODO()
2021-03-12 01:46:11,018 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(elements: UInt): ArrayList<UInt> = TODO()
2021-03-12 01:46:11,140 [main:302] - generating value of type = UInt true depth = 6
2021-03-12 01:46:11,143 [main:95] - GENERATED = arrayListOf<UInt>(403114779.toUInt())
2021-03-12 01:46:11,143 [main:302] - generating value of type = Pair<ULong, UShort?> false depth = 3
2021-03-12 01:46:11,265 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: ULong, second: UShort?): Pair<ULong, UShort?> = TODO()
2021-03-12 01:46:11,268 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: ULong, second: UShort?): Pair<ULong, UShort?> = TODO()
2021-03-12 01:46:11,390 [main:302] - generating value of type = ULong true depth = 6
2021-03-12 01:46:11,393 [main:302] - generating value of type = UShort true depth = 6
2021-03-12 01:46:11,395 [main:95] - GENERATED = Pair<ULong, UShort?>(2981181425585402721.toULong(), 21821.toUShort())
2021-03-12 01:46:11,395 [main:302] - generating value of type = O false depth = 3
2021-03-12 01:46:11,397 [main:112] - generating klass O text = class O
2021-03-12 01:46:11,397 [main:95] - GENERATED = Triple<ArrayList<UInt>, Pair<ULong, UShort?>, O>(arrayListOf<UInt>(403114779.toUInt()), Pair<ULong, UShort?>(2981181425585402721.toULong(), 21821.toUShort()), O())
2021-03-12 01:46:11,421 [main:106] - GETTING String from KClass<MyClass>
2021-03-12 01:46:11,428 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]]
2021-03-12 01:46:11,428 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String?.orEmpty(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4afa0022]
2021-03-12 01:46:11,428 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.orEmpty()
2021-03-12 01:46:11,428 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7]]
2021-03-12 01:46:11,428 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName
2021-03-12 01:46:11,428 [main:113] - Case = [public abstract val simpleName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@20dad990]]
2021-03-12 01:46:11,428 [main:117] - GENERATED CALL = (MyClass::class).simpleName
2021-03-12 01:46:11,428 [main:113] - Case = [public abstract val qualifiedName: kotlin.String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor@1b690ec7], public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]]
2021-03-12 01:46:11,428 [main:149] - GENERATING call of type public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@357c3c8f]
2021-03-12 01:46:11,545 [main:117] - GENERATED CALL = (MyClass::class).qualifiedName?.plus(null)
2021-03-12 01:46:11,545 [main:114] - replacement of method of type String is (MyClass::class).simpleName
2021-03-12 01:46:11,662 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:46:11,662 [main:66] - Compilation checking started
2021-03-12 01:46:12,005 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith((MyClass::class).simpleName) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:12,007 [main:107] - replacing (prope2, Result<Ty0>)
2021-03-12 01:46:12,007 [main:50] - replacing prope2 Result<Ty0>
2021-03-12 01:46:12,007 [main:54] - Getting value of type Result<Ty0>
2021-03-12 01:46:12,125 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 01:46:12,247 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 01:46:12,250 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 01:46:12,506 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 01:46:12,506 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 01:46:12,780 [main:67] - randomType = Map<UInt, Kla4>
2021-03-12 01:46:12,781 [main:106] - GETTING Result<Ty0> from KClass<Ann>
2021-03-12 01:46:12,790 [main:106] - GETTING Result<Ty0> from KClass<MyClass>
2021-03-12 01:46:12,798 [main:106] - GETTING Result<Ty0> from String
2021-03-12 01:46:12,845 [main:111] - Cant find and generate replacement for prope2 type Result<Ty0>
2021-03-12 01:46:12,845 [main:107] - replacing (prope2, Int)
2021-03-12 01:46:12,845 [main:50] - replacing prope2 Int
2021-03-12 01:46:12,845 [main:54] - Getting value of type Int
2021-03-12 01:46:12,963 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:12,965 [main:58] - GENERATED VALUE OF TYPE Int = 1068720096
2021-03-12 01:46:12,965 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:13,232 [main:67] - randomType = List<Byte>
2021-03-12 01:46:13,233 [main:106] - GETTING Int from String
2021-03-12 01:46:13,252 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.lastIndexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@864e36e]]
2021-03-12 01:46:13,252 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:46:13,369 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:13,489 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:13,491 [main:149] - GENERATING call of type public fun kotlin.CharSequence.lastIndexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@864e36e]
2021-03-12 01:46:13,609 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:46:13,729 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:13,847 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:13,850 [main:117] - GENERATED CALL = (argName1).subSequence(1431721015, 618486266).lastIndexOf('᭲', -326434764, false)
2021-03-12 01:46:13,850 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public fun kotlin.CharSequence.indexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@f5b882b]]
2021-03-12 01:46:13,850 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:46:13,967 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:14,087 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:14,090 [main:149] - GENERATING call of type public fun kotlin.CharSequence.indexOf(char: kotlin.Char, startIndex: kotlin.Int = ..., ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@f5b882b]
2021-03-12 01:46:14,214 [main:302] - generating value of type = Char true depth = 0
2021-03-12 01:46:14,334 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:14,454 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:14,456 [main:117] - GENERATED CALL = (argName1).subSequence(-440352187, -344674405).indexOf('༮', -1112333164, true)
2021-03-12 01:46:14,457 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@35c7c5e]]
2021-03-12 01:46:14,457 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@35c7c5e]
2021-03-12 01:46:14,573 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:14,575 [main:117] - GENERATED CALL = (argName1).length.rotateRight(-1280302895)
2021-03-12 01:46:14,575 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public inline fun kotlin.CharSequence.indexOfFirst(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4d8ea86d]]
2021-03-12 01:46:14,576 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:46:14,693 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:14,812 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:14,814 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.indexOfFirst(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4d8ea86d]
2021-03-12 01:46:14,931 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:46:14,933 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:46:14,936 [main:117] - GENERATED CALL = (argName1).subSequence(-1056179729, 1979349963).indexOfFirst({a: Char -> true})
2021-03-12 01:46:14,936 [main:113] - Case = [public open val length: kotlin.Int defined in kotlin.String[DeserializedPropertyDescriptor@40184688], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Int.absoluteValue: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@15d4cc5]]
2021-03-12 01:46:14,936 [main:117] - GENERATED CALL = (argName1).length.absoluteValue
2021-03-12 01:46:14,936 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2b4d25cd]]
2021-03-12 01:46:14,936 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:46:14,936 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2b4d25cd]
2021-03-12 01:46:14,936 [main:117] - GENERATED CALL = (argName1).compareTo(val argName2 = args[1].simpleName ?: "fail 2".inc()
2021-03-12 01:46:14,936 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6540b81e]]
2021-03-12 01:46:14,936 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:46:15,054 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:46:15,056 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6540b81e]
2021-03-12 01:46:15,211 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 01:46:15,213 [main:117] - GENERATED CALL = (argName1).compareTo("mbnjv").minus(3)
2021-03-12 01:46:15,213 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], public inline fun kotlin.CharSequence.indexOfLast(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@306cd945]]
2021-03-12 01:46:15,213 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:46:15,371 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:15,495 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:15,498 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.indexOfLast(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@306cd945]
2021-03-12 01:46:15,617 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:46:15,619 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:46:15,623 [main:117] - GENERATED CALL = (argName1).subSequence(1338478651, -678613040).indexOfLast({a: Char -> true})
2021-03-12 01:46:15,623 [main:113] - Case = [public inline fun kotlin.CharSequence.indexOfFirst(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4d8ea86d]]
2021-03-12 01:46:15,623 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.indexOfFirst(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4d8ea86d]
2021-03-12 01:46:15,741 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:46:15,743 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:46:15,746 [main:117] - GENERATED CALL = (argName1).indexOfFirst({a: Char -> false})
2021-03-12 01:46:15,746 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@42ee2c95]]
2021-03-12 01:46:15,746 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.String): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5fb135ff]
2021-03-12 01:46:15,746 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@42ee2c95]
2021-03-12 01:46:15,746 [main:117] - GENERATED CALL = (argName1).compareTo(argName1).takeHighestOneBit()
2021-03-12 01:46:15,746 [main:114] - replacement of prope2 of type Int is (argName1).length.rotateRight(-1280302895)
2021-03-12 01:46:15,864 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:46:15,864 [main:66] - Compilation checking started
2021-03-12 01:46:16,220 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if ((argName1).length.rotateRight(-1280302895) != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:16,222 [main:107] - replacing (true, Boolean)
2021-03-12 01:46:16,222 [main:50] - replacing true Boolean
2021-03-12 01:46:16,222 [main:54] - Getting value of type Boolean
2021-03-12 01:46:16,341 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:16,343 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 01:46:16,343 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:16,351 [main:67] - randomType = Kla5
2021-03-12 01:46:16,469 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 01:46:16,472 [main:112] - generating klass Kla5 text = class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 01:46:16,479 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@68dbccfa]
2021-03-12 01:46:16,597 [main:302] - generating value of type = Any false depth = 0
2021-03-12 01:46:16,597 [main:78] - Generated call from random type = (Kla5()).prope6.equals("vrwla")
2021-03-12 01:46:16,597 [main:114] - replacement of true of type Boolean is (Kla5()).prope6.equals("vrwla")
2021-03-12 01:46:16,714 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 01:46:16,714 [main:66] - Compilation checking started
2021-03-12 01:46:17,065 [main:49] - Result = false
Text:
import kotlin.reflect.KClass
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame


@Retention(AnnotationRetention.RUNTIME)
annotation class Ann(vararg val args: KClass<*>)

class O
class K

@Ann(O::class, K::class) class MyClass

fun box(): String {
    val args = MyClass::class.java.getAnnotation(Ann::class.java).args
    val argName1 = args[0].simpleName ?: "fail 1"
    val argName2 = args[1].simpleName ?: "fail 2"
    return argName1 + argName2
}

class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}

fun fu0(c: suspend () -> Unit) {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
c.startCoroutine(Kla1)
}

fun box136(): String {
    val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
var prope2 = 0

    var prope3: Kla0? = null

    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 42) return "fail 1: $prope2"

    prope3 = Kla0()
    fu0 {
        prope2 = 42 + (prope3?.fu3() ?: 0)
    }

    if (prope2 != 56) return "fail 2: $prope2"

    return "OK"
}

fun <Ty0> fu1(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
x(prope2.getOrThrow())
    }
}

fun fu2(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.exceptionOrNull()?.let(x)
    }
}

open class Kla1(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla7 : Kla1()
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope2.getOrThrow()
    }
}

class Kla2 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Any?>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
this.prope2 = prope2.getOrThrow()
    }

    var prope2: Any? = null
}

abstract class Kla3<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope2: Result<Ty0>) {
        if (prope2.isSuccess) {
            resume(prope2.getOrThrow())
        } else {
            fu4(prope2.exceptionOrNull()!!)
        }
    }

    abstract fun fu4(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == (Kla5()).prope6.equals("vrwla") }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope0 = Kla4()

class Kla5 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu9() {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu10() = suspendCoroutine<Unit> { c ->
        prope5++
        prope7 = { c.resume(Unit) }
    }

    fun fu11(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope1 = Kla5()

object Kla6: Kla3<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope1.prope7 = {
            prope1.prope6 = true
        }
    }

    override fun fu4(exception: Throwable) {
        throw exception
    }
}


2021-03-12 01:46:17,068 [main:107] - replacing (c, Continuation<*>)
2021-03-12 01:46:17,068 [main:50] - replacing c Continuation<*>
2021-03-12 01:46:17,068 [main:54] - Getting value of type Continuation<*>
2021-03-12 01:46:17,188 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 01:46:17,339 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:46:17,342 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:46:17,734 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 01:46:17,855 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:46:17,858 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:46:18,119 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 01:46:18,245 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:46:18,248 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:46:18,644 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 01:46:18,644 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 01:46:18,644 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 01:46:18,644 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 01:46:18,656 [main:67] - randomType = Kla0?
2021-03-12 01:46:18,774 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 01:46:18,776 [main:112] - generating klass Kla0 text = class Kla0 {
    suspend fun fu3(): Int = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(14)
        COROUTINE_SUSPENDED
    }
}
2021-03-12 01:46:18,783 [main:106] - GETTING Continuation<*> from KClass<MyClass>
2021-03-12 01:46:18,793 [main:106] - GETTING Continuation<*> from KClass<Ann>
2021-03-12 01:46:18,805 [main:106] - GETTING Continuation<*> from String
2021-03-12 01:46:18,830 [main:111] - Cant find and generate replacement for c type Continuation<*>
2021-03-12 01:46:18,831 [main:107] - replacing ("Wrong state-machine generated: it is not finished yet", String)
2021-03-12 01:46:18,831 [main:50] - replacing "Wrong state-machine generated: it is not finished yet" String
2021-03-12 01:46:18,831 [main:54] - Getting value of type String
2021-03-12 01:46:18,947 [main:302] - generating value of type = String true depth = 0
2021-03-12 01:46:18,949 [main:58] - GENERATED VALUE OF TYPE String = "mskqa"
2021-03-12 01:46:18,949 [main:61] - GENERATED IS CALL =false
2021-03-12 01:46:19,097 [main:67] - randomType = Pair<Kla4, Boolean>
2021-03-12 01:46:19,215 [main:302] - generating value of type = Pair<Kla4, Boolean> false depth = 0
2021-03-12 01:46:19,375 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla4, second: Boolean): Pair<Kla4, Boolean> = TODO()
2021-03-12 01:46:19,378 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla4, second: Boolean): Pair<Kla4, Boolean> = TODO()
2021-03-12 01:46:19,524 [main:302] - generating value of type = Kla4 false depth = 3
2021-03-12 01:46:19,526 [main:112] - generating klass Kla4 text = class Kla4 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu6() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu6(it)
    }

    fun fu6(c: Continuation<*>) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
if (c !is CoroutineStackFrame) error("Continuation " + c + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = c
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu7(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu8(method: String) {
        val argName1 = args[0].simpleName ?: "fail 1"
val argName2 = args[1].simpleName ?: "fail 2"
prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}
2021-03-12 01:46:19,526 [main:302] - generating value of type = Boolean true depth = 3
2021-03-12 01:46:19,528 [main:95] - GENERATED = Pair<Kla4, Boolean>(Kla4(), true)
2021-03-12 01:46:19,540 [main:106] - GETTING String from String
2021-03-12 01:46:19,570 [main:113] - Case = [public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b4bbc69]]
2021-03-12 01:46:19,570 [main:149] - GENERATING call of type public fun kotlin.CharSequence.commonSuffixWith(other: kotlin.CharSequence, ignoreCase: kotlin.Boolean = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5b4bbc69]
2021-03-12 01:46:19,691 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 01:46:19,813 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 01:46:19,815 [main:117] - GENERATED CALL = (argName1).commonSuffixWith("hislc", true)
2021-03-12 01:46:19,815 [main:113] - Case = [public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b], @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.substring(startIndex: kotlin.Int, endIndex: kotlin.Int = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1ceb9bdb]]
2021-03-12 01:46:19,815 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@468e590b]
2021-03-12 01:46:19,932 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:20,051 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:20,054 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.CharSequence.substring(startIndex: kotlin.Int, endIndex: kotlin.Int = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1ceb9bdb]
2021-03-12 01:46:20,172 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:20,291 [main:302] - generating value of type = Int true depth = 0
2021-03-12 01:46:20,293 [main:117] - GENERATED CALL = (argName1).subSequence(-1908050630, -1521029395).substring(1058103650, -1812648833)
2021-03-12 01:46:20,294 [main:113] - Case = [public inline fun kotlin.String.dropWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1eee24d5]]
2021-03-12 01:46:20,294 [main:149] - GENERATING call of type public inline fun kotlin.String.dropWhile(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1eee24d5]
2021-03-12 01:46:20,412 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 01:46:20,414 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 01:46:20,416 [main:117] - GENERATED CALL = (argName1).dropWhile({a: Char -> true})
2021-03-12 01:46:20,417 [main:113] - Case = [@kotlin.internal.InlineOnly public inline fun kotlin.String.toUpperCase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44cab771]]
2021-03-12 01:46:20,417 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.toUpperCase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@44cab771]
2021-03-12 01:46:20,417 [main:117] - GENERATED CALL = (argName1).toUpperCase()
2021-03-12 01:46:20,417 [main:113] - Case = [public fun kotlin.String.replaceAfter(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@52f4fcf8]]
2021-03-12 01:46:20,417 [main:149] - GENERATING call of type public fun kotlin.String.replaceAfter(delimiter: kotlin.Char, replacement: kotlin.String, missingDelimiterValue: kotlin.String = ...): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@52f4fcf8]
2021-03-12 01:46:20,535 [main:302] - generating value of type = Char true depth = 0
