2021-03-12 08:13:14,848 [main:66] - Compilation checking started
2021-03-12 08:13:15,780 [main:302] - generating value of type = Pair<Int, Int> false depth = 0
2021-03-12 08:13:16,343 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:16,359 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:16,504 [main:302] - generating value of type = Int true depth = 3
2021-03-12 08:13:16,505 [main:302] - generating value of type = Int true depth = 3
2021-03-12 08:13:16,506 [main:95] - GENERATED = Pair<Int, Int>(633192642, -1197326750)
2021-03-12 08:13:16,507 [main:33] - Trying to replace Element(VALUE_PARAMETER) on Element(VALUE_PARAMETER)
2021-03-12 08:13:16,508 [main:66] - Compilation checking started
2021-03-12 08:13:16,510 [main:71] - Wrong syntax or breaks conditions
2021-03-12 08:13:16,511 [main:49] - Result = false
Text:
fun test(p: Pair<Int, Int> = Pair<Int, Int>(633192642, -1197326750)) {
    val (x, y) = p
}


2021-03-12 08:13:16,938 [main:43] - GENERATING CALL OF fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}
2021-03-12 08:13:16,938 [main:61] - WITHOUT TYPE PARAMS = fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}
2021-03-12 08:13:17,050 [main:302] - generating value of type = Pair<Int, Int> false depth = 1
2021-03-12 08:13:17,183 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:17,187 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:17,318 [main:302] - generating value of type = Int true depth = 4
2021-03-12 08:13:17,319 [main:302] - generating value of type = Int true depth = 4
2021-03-12 08:13:17,320 [main:95] - GENERATED = Pair<Int, Int>(-2091946849, 989636326)
2021-03-12 08:13:17,321 [main:95] - GENERATED = test(Pair<Int, Int>(-2091946849, 989636326))
2021-03-12 08:13:17,455 [main:45] - Trying to change 1 nodes
2021-03-12 08:13:17,606 [main:41] - AFTER TRY 0 res = fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}
2021-03-12 08:13:17,982 [main:43] - GENERATING CALL OF fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}
2021-03-12 08:13:17,983 [main:61] - WITHOUT TYPE PARAMS = fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}
2021-03-12 08:13:18,067 [main:302] - generating value of type = Pair<Int, Int> false depth = 1
2021-03-12 08:13:18,149 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:18,152 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:18,238 [main:302] - generating value of type = Int true depth = 4
2021-03-12 08:13:18,239 [main:302] - generating value of type = Int true depth = 4
2021-03-12 08:13:18,239 [main:95] - GENERATED = Pair<Int, Int>(-646011260, 806269067)
2021-03-12 08:13:18,240 [main:95] - GENERATED = test(Pair<Int, Int>(-646011260, 806269067))
2021-03-12 08:13:18,365 [main:43] - Try №0
2021-03-12 08:13:18,624 [main:41] - AFTER TRY 1 res = fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}


2021-03-12 08:13:18,923 [main:43] - GENERATING CALL OF fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}


2021-03-12 08:13:18,923 [main:61] - WITHOUT TYPE PARAMS = fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}


2021-03-12 08:13:18,997 [main:302] - generating value of type = Pair<Int, Int> false depth = 1
2021-03-12 08:13:19,075 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:19,078 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Int, second: Int): Pair<Int, Int> = TODO()
2021-03-12 08:13:19,188 [main:302] - generating value of type = Int true depth = 4
2021-03-12 08:13:19,189 [main:302] - generating value of type = Int true depth = 4
2021-03-12 08:13:19,190 [main:95] - GENERATED = Pair<Int, Int>(557577822, 1149306259)
2021-03-12 08:13:19,191 [main:95] - GENERATED = test(Pair<Int, Int>(557577822, 1149306259))
2021-03-12 08:13:19,295 [main:43] - Try №1
2021-03-12 08:13:35,309 [main:48] - Already checked
2021-03-12 08:13:35,530 [main:48] - Already checked
2021-03-12 08:13:39,783 [main:69] - Trying to insert abstract fun resume(value: Ty0)
2021-03-12 08:13:39,902 [main:66] - Compilation checking started
2021-03-12 08:13:40,974 [main:103] - Trying to change 178 nodes
2021-03-12 08:13:40,974 [main:107] - replacing (prope0.exceptionOrNull()!!, Throwable)
2021-03-12 08:13:40,974 [main:50] - replacing prope0.exceptionOrNull()!! Throwable
2021-03-12 08:13:40,974 [main:54] - Getting value of type Throwable
2021-03-12 08:13:41,144 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 08:13:41,318 [main:43] - GENERATING CALL OF fun RuntimeException(message: kotlin.String?): Throwable = TODO()
2021-03-12 08:13:41,322 [main:61] - WITHOUT TYPE PARAMS = fun RuntimeException(message: kotlin.String?): Throwable = TODO()
2021-03-12 08:13:41,700 [main:302] - generating value of type = String true depth = 3
2021-03-12 08:13:41,706 [main:95] - GENERATED = RuntimeException("qeylh")
2021-03-12 08:13:41,706 [main:58] - GENERATED VALUE OF TYPE Throwable = RuntimeException("qeylh")
2021-03-12 08:13:41,707 [main:61] - GENERATED IS CALL =true
2021-03-12 08:13:42,125 [main:67] - randomType = Kla4<Short>
2021-03-12 08:13:42,273 [main:302] - generating value of type = Kla4<Short> false depth = 0
2021-03-12 08:13:42,277 [main:112] - generating klass Kla4 text = abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 08:13:43,014 [main:302] - generating value of type = Kla7 false depth = 2
2021-03-12 08:13:43,016 [main:112] - generating klass Kla7 text = object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}
2021-03-12 08:13:43,064 [main:114] - replacement of prope0.exceptionOrNull()!! of type Throwable is RuntimeException("qeylh")
2021-03-12 08:13:43,215 [main:33] - Trying to replace Element(POSTFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:13:43,217 [main:107] - replacing ("UNCHECKED_CAST", String)
2021-03-12 08:13:43,217 [main:50] - replacing "UNCHECKED_CAST" String
2021-03-12 08:13:43,218 [main:54] - Getting value of type String
2021-03-12 08:13:43,347 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:13:43,350 [main:58] - GENERATED VALUE OF TYPE String = "bptra"
2021-03-12 08:13:43,350 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:43,358 [main:67] - randomType = Kla3
2021-03-12 08:13:43,503 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:13:43,506 [main:112] - generating klass Kla3 text = class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = prope0.getOrThrow()
    }

    var prope0: Any? = null
}
2021-03-12 08:13:43,551 [main:149] - GENERATING call of type public fun kotlin.Any?.toString(): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@6a5754f5]
2021-03-12 08:13:43,552 [main:78] - Generated call from random type = (Kla3()).prope0?.toString()!!
2021-03-12 08:13:43,552 [main:114] - replacement of "UNCHECKED_CAST" of type String is "bptra"
2021-03-12 08:13:43,753 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 08:13:43,754 [main:66] - Compilation checking started
2021-03-12 08:13:44,361 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = prope0.getOrThrow()
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:44,365 [main:107] - replacing (prope0.getOrThrow(), Any?)
2021-03-12 08:13:44,365 [main:50] - replacing prope0.getOrThrow() Any?
2021-03-12 08:13:44,365 [main:54] - Getting value of type Any?
2021-03-12 08:13:44,511 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:13:44,511 [main:58] - GENERATED VALUE OF TYPE Any? = "nztxf"
2021-03-12 08:13:44,512 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:44,678 [main:67] - randomType = Kla4<Kla5>
2021-03-12 08:13:44,819 [main:302] - generating value of type = Kla4<Kla5> false depth = 0
2021-03-12 08:13:44,822 [main:112] - generating klass Kla4 text = abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 08:13:45,386 [main:302] - generating value of type = Kla7 false depth = 2
2021-03-12 08:13:45,389 [main:112] - generating klass Kla7 text = object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}
2021-03-12 08:13:45,415 [main:114] - replacement of prope0.getOrThrow() of type Any? is "nztxf"
2021-03-12 08:13:45,551 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:13:45,551 [main:66] - Compilation checking started
2021-03-12 08:13:46,236 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:46,238 [main:107] - replacing ("tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n"), String)
2021-03-12 08:13:46,238 [main:50] - replacing "tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n") String
2021-03-12 08:13:46,238 [main:54] - Getting value of type String
2021-03-12 08:13:46,391 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:13:46,394 [main:58] - GENERATED VALUE OF TYPE String = "ybhhd"
2021-03-12 08:13:46,394 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:47,189 [main:67] - randomType = Pair<ULong?, UInt>?
2021-03-12 08:13:47,315 [main:302] - generating value of type = Pair<ULong?, UInt> false depth = 0
2021-03-12 08:13:47,446 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: ULong?, second: UInt): Pair<ULong?, UInt> = TODO()
2021-03-12 08:13:47,449 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: ULong?, second: UInt): Pair<ULong?, UInt> = TODO()
2021-03-12 08:13:47,593 [main:302] - generating value of type = ULong true depth = 3
2021-03-12 08:13:47,595 [main:302] - generating value of type = UInt true depth = 3
2021-03-12 08:13:47,598 [main:95] - GENERATED = Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt())
2021-03-12 08:13:47,629 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UInt.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@42c38c9b]
2021-03-12 08:13:47,795 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:13:47,799 [main:78] - Generated call from random type = (Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051)
2021-03-12 08:13:47,800 [main:114] - replacement of "tail-call optimization hit: method " + method + " has no state-machine " +
                prope4.joinToString(separator = "\n") of type String is (Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051)
2021-03-12 08:13:47,965 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:13:47,965 [main:66] - Compilation checking started
2021-03-12 08:13:48,642 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:48,644 [main:107] - replacing (prope0, Result<Ty0>)
2021-03-12 08:13:48,645 [main:50] - replacing prope0 Result<Ty0>
2021-03-12 08:13:48,645 [main:54] - Getting value of type Result<Ty0>
2021-03-12 08:13:48,798 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 08:13:48,961 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 08:13:48,965 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 08:13:49,284 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 08:13:49,286 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 08:13:49,291 [main:67] - randomType = UInt
2021-03-12 08:13:49,428 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 08:13:49,476 [main:111] - Cant find and generate replacement for prope0 type Result<Ty0>
2021-03-12 08:13:49,477 [main:107] - replacing (this.prope0, Any?)
2021-03-12 08:13:49,477 [main:50] - replacing this.prope0 Any?
2021-03-12 08:13:49,477 [main:54] - Getting value of type Any?
2021-03-12 08:13:49,601 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:13:49,601 [main:58] - GENERATED VALUE OF TYPE Any? = "wgapx"
2021-03-12 08:13:49,601 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:49,921 [main:67] - randomType = Short?
2021-03-12 08:13:50,059 [main:302] - generating value of type = Short true depth = 0
2021-03-12 08:13:50,130 [main:114] - replacement of this.prope0 of type Any? is "wgapx"
2021-03-12 08:13:50,273 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:13:50,273 [main:66] - Compilation checking started
2021-03-12 08:13:50,660 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        "wgapx" = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:50,662 [main:107] - replacing (" has state-machine ", String)
2021-03-12 08:13:50,662 [main:50] - replacing " has state-machine " String
2021-03-12 08:13:50,662 [main:54] - Getting value of type String
2021-03-12 08:13:50,790 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:13:50,792 [main:58] - GENERATED VALUE OF TYPE String = "kuboc"
2021-03-12 08:13:50,793 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:50,938 [main:67] - randomType = Kla7
2021-03-12 08:13:51,069 [main:302] - generating value of type = Kla7 false depth = 0
2021-03-12 08:13:51,071 [main:112] - generating klass Kla7 text = object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}
2021-03-12 08:13:51,098 [main:114] - replacement of " has state-machine " of type String is "kuboc"
2021-03-12 08:13:51,229 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 08:13:51,229 [main:66] - Compilation checking started
2021-03-12 08:13:51,841 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:51,843 [main:107] - replacing (prope6, Boolean)
2021-03-12 08:13:51,843 [main:50] - replacing prope6 Boolean
2021-03-12 08:13:51,843 [main:54] - Getting value of type Boolean
2021-03-12 08:13:51,971 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:13:51,973 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:13:51,973 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:51,978 [main:67] - randomType = UInt
2021-03-12 08:13:52,101 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 08:13:52,144 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun rangeTo(other: kotlin.UInt): kotlin.ranges.UIntRange defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@780e11d2]
2021-03-12 08:13:52,267 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 08:13:52,269 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public operator fun kotlin.ranges.UIntRange.contains(value: kotlin.UByte): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@4ae48059]
2021-03-12 08:13:52,389 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 08:13:52,391 [main:78] - Generated call from random type = (1571276796.toUInt()).rangeTo(2033800781.toUInt()).contains(45.toUByte())
2021-03-12 08:13:52,391 [main:114] - replacement of prope6 of type Boolean is false
2021-03-12 08:13:52,511 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 08:13:52,511 [main:66] - Compilation checking started
2021-03-12 08:13:52,949 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.false = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:52,952 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 08:13:52,953 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 08:13:52,953 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 08:13:53,106 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 08:13:53,115 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 08:13:53,128 [main:67] - randomType = Kla1
2021-03-12 08:13:53,271 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 08:13:53,273 [main:112] - generating klass Kla1 text = class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}
2021-03-12 08:13:53,403 [main:194] - Type params = []
2021-03-12 08:13:53,538 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 08:13:53,539 [main:107] - replacing (prope1, Continuation<Unit>)
2021-03-12 08:13:53,539 [main:50] - replacing prope1 Continuation<Unit>
2021-03-12 08:13:53,539 [main:54] - Getting value of type Continuation<Unit>
2021-03-12 08:13:53,668 [main:302] - generating value of type = Continuation<Unit> false depth = 0
2021-03-12 08:13:53,837 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Unit>)->kotlin.Unit): Contuation<Unit> = TODO()
2021-03-12 08:13:53,842 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Unit>)->kotlin.Unit): Contuation<Unit> = TODO()
2021-03-12 08:13:54,288 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 08:13:54,411 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:13:54,414 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:13:54,773 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 08:13:54,902 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:13:54,905 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:13:55,352 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:13:55,352 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:13:55,352 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Unit>)->kotlin.Unit): Contuation<Unit> = TODO()
2021-03-12 08:13:55,352 [main:58] - GENERATED VALUE OF TYPE Continuation<Unit> = 
2021-03-12 08:13:55,356 [main:67] - randomType = String
2021-03-12 08:13:55,476 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:13:55,507 [main:111] - Cant find and generate replacement for prope1 type Continuation<Unit>
2021-03-12 08:13:55,507 [main:107] - replacing (", got ", String)
2021-03-12 08:13:55,508 [main:50] - replacing ", got " String
2021-03-12 08:13:55,508 [main:54] - Getting value of type String
2021-03-12 08:13:55,628 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:13:55,630 [main:58] - GENERATED VALUE OF TYPE String = "olcna"
2021-03-12 08:13:55,630 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:55,770 [main:67] - randomType = Int?
2021-03-12 08:13:55,897 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:13:55,954 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5a006cda]
2021-03-12 08:13:56,116 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:13:56,120 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6bc2f344]
2021-03-12 08:13:56,251 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:13:56,253 [main:78] - Generated call from random type = (-790298936)?.compareTo(1747287255).toString(1121924993)
2021-03-12 08:13:56,253 [main:114] - replacement of ", got " of type String is "olcna"
2021-03-12 08:13:56,373 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 08:13:56,374 [main:66] - Compilation checking started
2021-03-12 08:13:57,045 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:57,048 [main:107] - replacing (prope7, Function0<Unit>)
2021-03-12 08:13:57,048 [main:50] - replacing prope7 Function0<Unit>
2021-03-12 08:13:57,048 [main:54] - Getting value of type Function0<Unit>
2021-03-12 08:13:57,182 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 08:13:57,185 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 08:13:57,351 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 08:13:57,354 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 08:13:57,750 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 08:13:57,752 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 08:13:57,754 [main:302] - generating value of type = Any false depth = 5
2021-03-12 08:13:57,754 [main:95] - GENERATED = require(true, { "rbqya"})
2021-03-12 08:13:57,754 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true, { "rbqya"})}
2021-03-12 08:13:57,755 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:58,367 [main:67] - randomType = Kla4<Long>
2021-03-12 08:13:58,484 [main:302] - generating value of type = Kla4<Long> false depth = 0
2021-03-12 08:13:58,486 [main:112] - generating klass Kla4 text = abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 08:13:58,920 [main:302] - generating value of type = Kla7 false depth = 2
2021-03-12 08:13:58,922 [main:112] - generating klass Kla7 text = object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}
2021-03-12 08:13:58,943 [main:114] - replacement of prope7 of type Function0<Unit> is { require(true, { "rbqya"})}
2021-03-12 08:13:59,066 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 08:13:59,067 [main:66] - Compilation checking started
2021-03-12 08:13:59,456 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("Continuation " + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.{ require(true, { "rbqya"})} = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:13:59,458 [main:107] - replacing ("Continuation ", String)
2021-03-12 08:13:59,458 [main:50] - replacing "Continuation " String
2021-03-12 08:13:59,458 [main:54] - Getting value of type String
2021-03-12 08:13:59,579 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:13:59,582 [main:58] - GENERATED VALUE OF TYPE String = "baodj"
2021-03-12 08:13:59,582 [main:61] - GENERATED IS CALL =false
2021-03-12 08:13:59,731 [main:67] - randomType = Byte
2021-03-12 08:13:59,850 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 08:13:59,908 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@27214675]
2021-03-12 08:13:59,908 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3613e3]
2021-03-12 08:13:59,909 [main:78] - Generated call from random type = (-67).toChar().uppercase()
2021-03-12 08:13:59,909 [main:114] - replacement of "Continuation " of type String is (-67).toChar().uppercase()
2021-03-12 08:14:00,028 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:14:00,029 [main:66] - Compilation checking started
2021-03-12 08:14:00,651 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = false

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:00,653 [main:107] - replacing (false, Boolean)
2021-03-12 08:14:00,654 [main:50] - replacing false Boolean
2021-03-12 08:14:00,654 [main:54] - Getting value of type Boolean
2021-03-12 08:14:00,787 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:00,790 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 08:14:00,791 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:00,930 [main:67] - randomType = UByte
2021-03-12 08:14:01,057 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 08:14:01,105 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@4b286a71]
2021-03-12 08:14:01,106 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@4c594b73]
2021-03-12 08:14:01,224 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:14:01,224 [main:78] - Generated call from random type = (21.toUByte()).toFloat().equals("zqkcr")
2021-03-12 08:14:01,225 [main:114] - replacement of false of type Boolean is true
2021-03-12 08:14:01,342 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(BOOLEAN_CONSTANT)
2021-03-12 08:14:01,342 [main:66] - Compilation checking started
2021-03-12 08:14:01,940 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:01,942 [main:107] - replacing (prope5, Int)
2021-03-12 08:14:01,943 [main:50] - replacing prope5 Int
2021-03-12 08:14:01,943 [main:54] - Getting value of type Int
2021-03-12 08:14:02,092 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:02,094 [main:58] - GENERATED VALUE OF TYPE Int = 1793649915
2021-03-12 08:14:02,095 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:02,365 [main:67] - randomType = Float?
2021-03-12 08:14:02,481 [main:302] - generating value of type = Float true depth = 0
2021-03-12 08:14:02,536 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@341fbaf1]
2021-03-12 08:14:02,537 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@6f319f62]
2021-03-12 08:14:02,654 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:02,656 [main:78] - Generated call from random type = (0.09009093f)?.toInt().coerceAtLeast(1449343196)
2021-03-12 08:14:02,656 [main:114] - replacement of prope5 of type Int is (0.09009093f)?.toInt().coerceAtLeast(1449343196)
2021-03-12 08:14:02,789 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:14:02,790 [main:66] - Compilation checking started
2021-03-12 08:14:03,172 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu12(it)
    }

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        (0.09009093f)?.toInt().coerceAtLeast(1449343196)++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:03,174 [main:107] - replacing ({
        fu12(it)
    }, Function1<Continuation<Unit>, Unit>)
2021-03-12 08:14:03,174 [main:50] - replacing {
        fu12(it)
    } Function1<Continuation<Unit>, Unit>
2021-03-12 08:14:03,174 [main:54] - Getting value of type Function1<Continuation<Unit>, Unit>
2021-03-12 08:14:03,296 [main:302] - generating value of type = Function1<Continuation<Unit>, Unit> false depth = 0
2021-03-12 08:14:03,298 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 08:14:03,426 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:14:03,429 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:14:03,686 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:14:03,686 [main:95] - GENERATED = print("gaeft")
2021-03-12 08:14:03,686 [main:58] - GENERATED VALUE OF TYPE Function1<Continuation<Unit>, Unit> = {a: Continuation<Unit> -> print("gaeft")}
2021-03-12 08:14:03,686 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:03,843 [main:67] - randomType = LinkedHashMap<Kla6, Int>
2021-03-12 08:14:03,960 [main:302] - generating value of type = LinkedHashMap<Kla6, Int> false depth = 0
2021-03-12 08:14:04,088 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(pairs: Pair<Kla6, Int>): LkedHashMap<Kla6, Int> = TODO()
2021-03-12 08:14:04,091 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(pairs: Pair<Kla6, Int>): LkedHashMap<Kla6, Int> = TODO()
2021-03-12 08:14:04,215 [main:302] - generating value of type = Pair<Kla6, Int> false depth = 3
2021-03-12 08:14:04,345 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla6, second: Int): Pair<Kla6, Int> = TODO()
2021-03-12 08:14:04,348 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla6, second: Int): Pair<Kla6, Int> = TODO()
2021-03-12 08:14:04,471 [main:302] - generating value of type = Kla6 false depth = 6
2021-03-12 08:14:04,473 [main:112] - generating klass Kla6 text = class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:14:04,473 [main:302] - generating value of type = Int true depth = 6
2021-03-12 08:14:04,475 [main:95] - GENERATED = Pair<Kla6, Int>(Kla6(), -207567482)
2021-03-12 08:14:04,476 [main:95] - GENERATED = linkedMapOf<Kla6, Int>(Pair<Kla6, Int>(Kla6(), -207567482))
2021-03-12 08:14:04,677 [main:114] - replacement of {
        fu12(it)
    } of type Function1<Continuation<Unit>, Unit> is {a: Continuation<Unit> -> print("gaeft")}
2021-03-12 08:14:04,816 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 08:14:04,817 [main:66] - Compilation checking started
2021-03-12 08:14:05,472 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(fu7(fu1()))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:05,475 [main:107] - replacing (fu7(fu1()), Kla0)
2021-03-12 08:14:05,475 [main:50] - replacing fu7(fu1()) Kla0
2021-03-12 08:14:05,476 [main:54] - Getting value of type Kla0
2021-03-12 08:14:05,617 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 08:14:05,620 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:14:05,736 [main:194] - Type params = []
2021-03-12 08:14:05,854 [main:302] - generating value of type = String true depth = 2
2021-03-12 08:14:05,856 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla0("wjpsx")
2021-03-12 08:14:05,857 [main:61] - GENERATED IS CALL =true
2021-03-12 08:14:06,014 [main:67] - randomType = HashSet<Kla5>
2021-03-12 08:14:06,136 [main:302] - generating value of type = HashSet<Kla5> false depth = 0
2021-03-12 08:14:06,272 [main:43] - GENERATING CALL OF fun <T> hashSetOf(elements: Kla5): HashSet<Kla5> = TODO()
2021-03-12 08:14:06,275 [main:61] - WITHOUT TYPE PARAMS = fun <T> hashSetOf(elements: Kla5): HashSet<Kla5> = TODO()
2021-03-12 08:14:06,409 [main:302] - generating value of type = Kla5 false depth = 3
2021-03-12 08:14:06,411 [main:112] - generating klass Kla5 text = class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}
2021-03-12 08:14:06,412 [main:95] - GENERATED = hashSetOf<Kla5>(Kla5())
2021-03-12 08:14:06,562 [main:114] - replacement of fu7(fu1()) of type Kla0 is Kla0("wjpsx")
2021-03-12 08:14:06,680 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:14:06,680 [main:66] - Compilation checking started
2021-03-12 08:14:07,300 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if (prope0 != "OK") return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:07,302 [main:107] - replacing (prope0 != "OK", Boolean)
2021-03-12 08:14:07,302 [main:50] - replacing prope0 != "OK" Boolean
2021-03-12 08:14:07,302 [main:54] - Getting value of type Boolean
2021-03-12 08:14:07,423 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:07,425 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 08:14:07,425 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:07,434 [main:67] - randomType = Kla3
2021-03-12 08:14:07,552 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:14:07,554 [main:112] - generating klass Kla3 text = class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}
2021-03-12 08:14:07,577 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla3[DeserializedSimpleFunctionDescriptor@59fbb168]
2021-03-12 08:14:07,710 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:14:07,710 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@78753f6f]
2021-03-12 08:14:07,711 [main:78] - Generated call from random type = (Kla3()).equals("ndooe").not()
2021-03-12 08:14:07,711 [main:114] - replacement of prope0 != "OK" of type Boolean is (Kla3()).equals("ndooe").not()
2021-03-12 08:14:07,855 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:14:07,856 [main:66] - Compilation checking started
2021-03-12 08:14:08,530 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = it.message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:08,532 [main:107] - replacing (it, Throwable)
2021-03-12 08:14:08,533 [main:50] - replacing it Throwable
2021-03-12 08:14:08,533 [main:54] - Getting value of type Throwable
2021-03-12 08:14:08,677 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 08:14:08,795 [main:43] - GENERATING CALL OF fun ArithmeticException(message: kotlin.String?): Throwable = TODO()
2021-03-12 08:14:08,798 [main:61] - WITHOUT TYPE PARAMS = fun ArithmeticException(message: kotlin.String?): Throwable = TODO()
2021-03-12 08:14:09,048 [main:302] - generating value of type = String true depth = 3
2021-03-12 08:14:09,050 [main:95] - GENERATED = ArithmeticException("tpkms")
2021-03-12 08:14:09,050 [main:58] - GENERATED VALUE OF TYPE Throwable = ArithmeticException("tpkms")
2021-03-12 08:14:09,050 [main:61] - GENERATED IS CALL =true
2021-03-12 08:14:09,466 [main:67] - randomType = Function2<Boolean, Char, Double?>
2021-03-12 08:14:09,466 [main:114] - replacement of it of type Throwable is ArithmeticException("tpkms")
2021-03-12 08:14:09,585 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:14:09,586 [main:66] - Compilation checking started
2021-03-12 08:14:10,162 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:10,165 [main:107] - replacing (prope5, Int)
2021-03-12 08:14:10,165 [main:50] - replacing prope5 Int
2021-03-12 08:14:10,165 [main:54] - Getting value of type Int
2021-03-12 08:14:10,287 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:10,289 [main:58] - GENERATED VALUE OF TYPE Int = -2053445506
2021-03-12 08:14:10,290 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:10,571 [main:67] - randomType = Collection<Boolean?>
2021-03-12 08:14:10,571 [main:114] - replacement of prope5 of type Int is -2053445506
2021-03-12 08:14:10,697 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 08:14:10,698 [main:66] - Compilation checking started
2021-03-12 08:14:11,043 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -2053445506++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:11,047 [main:107] - replacing ({
            prope3.prope6 = true
        }, Function0<Unit>)
2021-03-12 08:14:11,047 [main:50] - replacing {
            prope3.prope6 = true
        } Function0<Unit>
2021-03-12 08:14:11,047 [main:54] - Getting value of type Function0<Unit>
2021-03-12 08:14:11,159 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 08:14:11,161 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 08:14:11,279 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 08:14:11,282 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 08:14:11,552 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 4
2021-03-12 08:14:11,555 [main:302] - generating value of type = Unit false depth = 5
2021-03-12 08:14:11,678 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 08:14:11,681 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 08:14:11,950 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 8
2021-03-12 08:14:11,953 [main:302] - generating value of type = Unit false depth = 9
2021-03-12 08:14:12,084 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 08:14:12,087 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 08:14:12,351 [main:302] - generating value of type = Boolean true depth = 12
2021-03-12 08:14:12,353 [main:95] - GENERATED = check(true)
2021-03-12 08:14:12,353 [main:95] - GENERATED = contract({ check(true)})
2021-03-12 08:14:12,354 [main:95] - GENERATED = contract({ contract({ check(true)})})
2021-03-12 08:14:12,354 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { contract({ contract({ check(true)})})}
2021-03-12 08:14:12,354 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:12,670 [main:67] - randomType = Sequence<Kla5>
2021-03-12 08:14:12,670 [main:114] - replacement of {
            prope3.prope6 = true
        } of type Function0<Unit> is { contract({ contract({ check(true)})})}
2021-03-12 08:14:12,786 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 08:14:12,786 [main:66] - Compilation checking started
2021-03-12 08:14:13,134 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n")) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = { contract({ contract({ check(true)})})}
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:13,137 [main:107] - replacing ("tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n"), String)
2021-03-12 08:14:13,137 [main:50] - replacing "tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n") String
2021-03-12 08:14:13,137 [main:54] - Getting value of type String
2021-03-12 08:14:13,264 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:13,266 [main:58] - GENERATED VALUE OF TYPE String = "bmuof"
2021-03-12 08:14:13,266 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:13,518 [main:67] - randomType = UShort?
2021-03-12 08:14:13,648 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 08:14:13,691 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@1908aea3]
2021-03-12 08:14:13,806 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 08:14:13,808 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6bc2f344]
2021-03-12 08:14:13,923 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:13,926 [main:78] - Generated call from random type = (9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)
2021-03-12 08:14:13,926 [main:114] - replacement of "tail-call optimization miss: method at " + it + "kuboc" +
                prope4.joinToString(separator = "\n") of type String is (9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)
2021-03-12 08:14:14,040 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:14:14,041 [main:66] - Compilation checking started
2021-03-12 08:14:14,630 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:14,632 [main:107] - replacing (prope1, Continuation<Any>?)
2021-03-12 08:14:14,633 [main:50] - replacing prope1 Continuation<Any>?
2021-03-12 08:14:14,633 [main:54] - Getting value of type Continuation<Any>?
2021-03-12 08:14:14,765 [main:302] - generating value of type = Continuation<Any> false depth = 0
2021-03-12 08:14:14,894 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 08:14:14,897 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 08:14:15,288 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 08:14:15,418 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:15,422 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:15,683 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 08:14:15,834 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:15,837 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:16,222 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 9
2021-03-12 08:14:16,343 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:16,346 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:16,800 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 12
2021-03-12 08:14:16,956 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:16,959 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:17,356 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 15
2021-03-12 08:14:17,476 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:17,479 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:17,953 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:17,953 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:17,953 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:17,953 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:17,953 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:17,953 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 08:14:17,953 [main:58] - GENERATED VALUE OF TYPE Continuation<Any>? = 
2021-03-12 08:14:17,958 [main:67] - randomType = UByte
2021-03-12 08:14:18,076 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 08:14:18,119 [main:111] - Cant find and generate replacement for prope1 type Continuation<Any>?
2021-03-12 08:14:18,119 [main:107] - replacing (it?.methodName?.startsWith(method) == true, Boolean)
2021-03-12 08:14:18,120 [main:50] - replacing it?.methodName?.startsWith(method) == true Boolean
2021-03-12 08:14:18,120 [main:54] - Getting value of type Boolean
2021-03-12 08:14:18,234 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:18,236 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:14:18,236 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:18,244 [main:67] - randomType = Kla6
2021-03-12 08:14:18,355 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 08:14:18,357 [main:112] - generating klass Kla6 text = class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:14:18,368 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function0[DeserializedSimpleFunctionDescriptor@6df3f38f]
2021-03-12 08:14:18,482 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:14:18,482 [main:78] - Generated call from random type = (Kla6()).prope7.equals("hysxl")
2021-03-12 08:14:18,483 [main:114] - replacement of it?.methodName?.startsWith(method) == true of type Boolean is (Kla6()).prope7.equals("hysxl")
2021-03-12 08:14:18,594 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:14:18,595 [main:66] - Compilation checking started
2021-03-12 08:14:19,238 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:19,241 [main:107] - replacing (prope6, Boolean)
2021-03-12 08:14:19,242 [main:50] - replacing prope6 Boolean
2021-03-12 08:14:19,242 [main:54] - Getting value of type Boolean
2021-03-12 08:14:19,392 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:19,394 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:14:19,394 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:19,403 [main:67] - randomType = Kla2
2021-03-12 08:14:19,513 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 08:14:19,515 [main:112] - generating klass Kla2 text = open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}
2021-03-12 08:14:19,626 [main:194] - Type params = []
2021-03-12 08:14:19,737 [main:302] - generating value of type = CoroutineContext false depth = 2
2021-03-12 08:14:19,853 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:19,856 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:20,141 [main:302] - generating value of type = Key<*> false depth = 5
2021-03-12 08:14:20,284 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:20,287 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:20,671 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 8
2021-03-12 08:14:20,793 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:20,796 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:21,231 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 08:14:21,231 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:21,232 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:21,249 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla2[DeserializedSimpleFunctionDescriptor@29ee600e]
2021-03-12 08:14:21,364 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:14:21,365 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@19296ecc]
2021-03-12 08:14:21,477 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:14:21,477 [main:78] - Generated call from random type = (Kla2()).equals("mfnsj").equals("jirlh")
2021-03-12 08:14:21,477 [main:114] - replacement of prope6 of type Boolean is false
2021-03-12 08:14:21,587 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 08:14:21,587 [main:66] - Compilation checking started
2021-03-12 08:14:21,935 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.false = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:21,937 [main:107] - replacing (prope0, Result<Any?>)
2021-03-12 08:14:21,937 [main:50] - replacing prope0 Result<Any?>
2021-03-12 08:14:21,937 [main:54] - Getting value of type Result<Any?>
2021-03-12 08:14:22,058 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 08:14:22,177 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:14:22,180 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:14:22,442 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 08:14:22,444 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:14:22,444 [main:95] - GENERATED = runCatching<Any?>({ "kpeyb"})
2021-03-12 08:14:22,444 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "kpeyb"})
2021-03-12 08:14:22,445 [main:61] - GENERATED IS CALL =true
2021-03-12 08:14:22,449 [main:67] - randomType = Long
2021-03-12 08:14:22,561 [main:302] - generating value of type = Long true depth = 0
2021-03-12 08:14:22,596 [main:114] - replacement of prope0 of type Result<Any?> is runCatching<Any?>({ "kpeyb"})
2021-03-12 08:14:22,706 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:14:22,706 [main:66] - Compilation checking started
2021-03-12 08:14:23,320 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        prope5++
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:23,322 [main:107] - replacing (prope5++, Int)
2021-03-12 08:14:23,322 [main:50] - replacing prope5++ Int
2021-03-12 08:14:23,322 [main:54] - Getting value of type Int
2021-03-12 08:14:23,451 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:23,453 [main:58] - GENERATED VALUE OF TYPE Int = -1733689611
2021-03-12 08:14:23,453 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:23,458 [main:67] - randomType = Int
2021-03-12 08:14:23,581 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:23,637 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@18f845e7]
2021-03-12 08:14:23,754 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 08:14:23,756 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.ranges.IntRange.random(): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2e2d04d7]
2021-03-12 08:14:23,756 [main:78] - Generated call from random type = (-749708829).rangeTo(66).random()
2021-03-12 08:14:23,756 [main:114] - replacement of prope5++ of type Int is -1733689611
2021-03-12 08:14:23,871 [main:33] - Trying to replace Element(POSTFIX_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 08:14:23,871 [main:66] - Compilation checking started
2021-03-12 08:14:24,458 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:24,461 [main:107] - replacing (prope0, String)
2021-03-12 08:14:24,461 [main:50] - replacing prope0 String
2021-03-12 08:14:24,462 [main:54] - Getting value of type String
2021-03-12 08:14:24,593 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:24,595 [main:58] - GENERATED VALUE OF TYPE String = "liliz"
2021-03-12 08:14:24,596 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:24,604 [main:67] - randomType = Kla6
2021-03-12 08:14:24,719 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 08:14:24,721 [main:112] - generating klass Kla6 text = class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:14:24,733 [main:114] - replacement of prope0 of type String is "liliz"
2021-03-12 08:14:24,849 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:14:24,849 [main:66] - Compilation checking started
2021-03-12 08:14:25,181 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        "liliz" = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    prope1?.resumeWithException(IllegalStateException("OK"))

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:25,184 [main:107] - replacing (prope1?.resumeWithException(IllegalStateException("OK")), Unit?)
2021-03-12 08:14:25,184 [main:50] - replacing prope1?.resumeWithException(IllegalStateException("OK")) Unit?
2021-03-12 08:14:25,184 [main:54] - Getting value of type Unit?
2021-03-12 08:14:25,306 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 08:14:25,425 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 08:14:25,428 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 08:14:25,803 [main:302] - generating value of type = Boolean true depth = 3
2021-03-12 08:14:25,805 [main:302] - generating value of type = Function0<Any> false depth = 3
2021-03-12 08:14:25,808 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:14:25,808 [main:95] - GENERATED = check(false, { "pyziu"})
2021-03-12 08:14:25,808 [main:58] - GENERATED VALUE OF TYPE Unit? = check(false, { "pyziu"})
2021-03-12 08:14:25,808 [main:61] - GENERATED IS CALL =true
2021-03-12 08:14:26,087 [main:67] - randomType = Double?
2021-03-12 08:14:26,198 [main:302] - generating value of type = Double true depth = 0
2021-03-12 08:14:26,244 [main:114] - replacement of prope1?.resumeWithException(IllegalStateException("OK")) of type Unit? is check(false, { "pyziu"})
2021-03-12 08:14:26,358 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:14:26,358 [main:66] - Compilation checking started
2021-03-12 08:14:26,896 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = ArithmeticException("tpkms").message!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:26,898 [main:107] - replacing (ArithmeticException("tpkms").message, String?)
2021-03-12 08:14:26,898 [main:50] - replacing ArithmeticException("tpkms").message String?
2021-03-12 08:14:26,898 [main:54] - Getting value of type String?
2021-03-12 08:14:27,011 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:27,013 [main:58] - GENERATED VALUE OF TYPE String? = "nlccy"
2021-03-12 08:14:27,013 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:27,411 [main:67] - randomType = LinkedHashMap<Kla5?, Short>
2021-03-12 08:14:27,521 [main:302] - generating value of type = LinkedHashMap<Kla5?, Short> false depth = 0
2021-03-12 08:14:27,637 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(pairs: Pair<Kla5?, Short>): LkedHashMap<Kla5?, Short> = TODO()
2021-03-12 08:14:27,640 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(pairs: Pair<Kla5?, Short>): LkedHashMap<Kla5?, Short> = TODO()
2021-03-12 08:14:27,756 [main:302] - generating value of type = Pair<Kla5?, Short> false depth = 3
2021-03-12 08:14:27,872 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla5?, second: Short): Pair<Kla5?, Short> = TODO()
2021-03-12 08:14:27,875 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla5?, second: Short): Pair<Kla5?, Short> = TODO()
2021-03-12 08:14:27,990 [main:302] - generating value of type = Kla5 false depth = 6
2021-03-12 08:14:27,992 [main:112] - generating klass Kla5 text = class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}
2021-03-12 08:14:27,992 [main:302] - generating value of type = Short true depth = 6
2021-03-12 08:14:27,994 [main:95] - GENERATED = Pair<Kla5?, Short>(Kla5(), -4826)
2021-03-12 08:14:27,995 [main:95] - GENERATED = linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))
2021-03-12 08:14:28,139 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6bc2f344]
2021-03-12 08:14:28,298 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:28,301 [main:78] - Generated call from random type = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)
2021-03-12 08:14:28,301 [main:114] - replacement of ArithmeticException("tpkms").message of type String? is (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)
2021-03-12 08:14:28,437 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:14:28,437 [main:66] - Compilation checking started
2021-03-12 08:14:29,106 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:29,109 [main:107] - replacing (getOrThrow(), Any?)
2021-03-12 08:14:29,109 [main:50] - replacing getOrThrow() Any?
2021-03-12 08:14:29,109 [main:54] - Getting value of type Any?
2021-03-12 08:14:29,252 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:14:29,252 [main:58] - GENERATED VALUE OF TYPE Any? = "yszng"
2021-03-12 08:14:29,252 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:29,258 [main:67] - randomType = UByte
2021-03-12 08:14:29,383 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 08:14:29,417 [main:114] - replacement of getOrThrow() of type Any? is "yszng"
2021-03-12 08:14:29,536 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:14:29,536 [main:66] - Compilation checking started
2021-03-12 08:14:29,918 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"})."yszng"
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope5 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:29,921 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 08:14:29,921 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 08:14:29,921 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 08:14:30,041 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 08:14:30,047 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 08:14:31,102 [main:67] - randomType = Triple<ULong?, Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5>, Boolean>
2021-03-12 08:14:31,214 [main:302] - generating value of type = Triple<ULong?, Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5>, Boolean> false depth = 0
2021-03-12 08:14:31,337 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: ULong?, second: Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5>, third: Boolean): Triple<ULong?, Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5>, Boolean> = TODO()
2021-03-12 08:14:31,341 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: ULong?, second: Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5>, third: Boolean): Triple<ULong?, Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5>, Boolean> = TODO()
2021-03-12 08:14:31,461 [main:302] - generating value of type = ULong true depth = 3
2021-03-12 08:14:31,464 [main:302] - generating value of type = Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5> false depth = 3
2021-03-12 08:14:31,466 [main:302] - generating value of type = Kla5 false depth = 4
2021-03-12 08:14:31,469 [main:112] - generating klass Kla5 text = class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}
2021-03-12 08:14:31,469 [main:302] - generating value of type = Boolean true depth = 3
2021-03-12 08:14:31,472 [main:95] - GENERATED = Triple<ULong?, Function2<Double, Pair<HashMap<Kla3, Double>, Map<Long, Boolean>>, Kla5>, Boolean>(4929958309233572049.toULong(), {a: Double, b: Pair<HashMap<Kla3, Double>, Map<Long, Boolean>> -> Kla5()}, true)
2021-03-12 08:14:31,502 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 08:14:31,502 [main:107] - replacing (prope1, Continuation<*>)
2021-03-12 08:14:31,503 [main:50] - replacing prope1 Continuation<*>
2021-03-12 08:14:31,503 [main:54] - Getting value of type Continuation<*>
2021-03-12 08:14:31,619 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 08:14:31,740 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 08:14:31,743 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 08:14:32,181 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 08:14:32,305 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:32,309 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:32,577 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 08:14:32,706 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:32,710 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:33,167 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:33,167 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:33,167 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 08:14:33,167 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 08:14:33,425 [main:67] - randomType = Double?
2021-03-12 08:14:33,538 [main:302] - generating value of type = Double true depth = 0
2021-03-12 08:14:33,575 [main:111] - Cant find and generate replacement for prope1 type Continuation<*>
2021-03-12 08:14:33,575 [main:107] - replacing (prope5, Int)
2021-03-12 08:14:33,575 [main:50] - replacing prope5 Int
2021-03-12 08:14:33,575 [main:54] - Getting value of type Int
2021-03-12 08:14:33,688 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:33,690 [main:58] - GENERATED VALUE OF TYPE Int = -613885904
2021-03-12 08:14:33,690 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:34,603 [main:67] - randomType = Function1<Triple<Kla6, Boolean, UInt>, Triple<Long, UShort, Kla7?>?>
2021-03-12 08:14:34,603 [main:114] - replacement of prope5 of type Int is -613885904
2021-03-12 08:14:34,718 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 08:14:34,718 [main:66] - Compilation checking started
2021-03-12 08:14:35,342 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = fu8().s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (-613885904 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:35,345 [main:107] - replacing (t, Ty0)
2021-03-12 08:14:35,345 [main:50] - replacing t Ty0
2021-03-12 08:14:35,345 [main:54] - Getting value of type Ty0
2021-03-12 08:14:35,482 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:14:35,488 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:14:35,632 [main:67] - randomType = UInt?
2021-03-12 08:14:35,747 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 08:14:35,788 [main:111] - Cant find and generate replacement for t type Ty0
2021-03-12 08:14:35,788 [main:107] - replacing (fu8(), Kla0)
2021-03-12 08:14:35,788 [main:50] - replacing fu8() Kla0
2021-03-12 08:14:35,788 [main:54] - Getting value of type Kla0
2021-03-12 08:14:35,905 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 08:14:35,908 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:14:36,022 [main:194] - Type params = []
2021-03-12 08:14:36,134 [main:302] - generating value of type = String true depth = 2
2021-03-12 08:14:36,137 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla0("thveu")
2021-03-12 08:14:36,137 [main:61] - GENERATED IS CALL =true
2021-03-12 08:14:36,143 [main:67] - randomType = Short
2021-03-12 08:14:36,257 [main:302] - generating value of type = Short true depth = 0
2021-03-12 08:14:36,297 [main:114] - replacement of fu8() of type Kla0 is Kla0("thveu")
2021-03-12 08:14:36,440 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:14:36,440 [main:66] - Compilation checking started
2021-03-12 08:14:37,042 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (-613885904 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:37,045 [main:107] - replacing (s, String)
2021-03-12 08:14:37,046 [main:50] - replacing s String
2021-03-12 08:14:37,046 [main:54] - Getting value of type String
2021-03-12 08:14:37,187 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:37,190 [main:58] - GENERATED VALUE OF TYPE String = "yfeec"
2021-03-12 08:14:37,190 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:37,609 [main:67] - randomType = Map<Kla1?, Kla2?>
2021-03-12 08:14:37,609 [main:114] - replacement of s of type String is "yfeec"
2021-03-12 08:14:37,732 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:14:37,733 [main:66] - Compilation checking started
2021-03-12 08:14:38,088 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "FAIL"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu")."yfeec"
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (-613885904 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:38,090 [main:107] - replacing ("FAIL", String)
2021-03-12 08:14:38,090 [main:50] - replacing "FAIL" String
2021-03-12 08:14:38,090 [main:54] - Getting value of type String
2021-03-12 08:14:38,202 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:38,204 [main:58] - GENERATED VALUE OF TYPE String = "yavzs"
2021-03-12 08:14:38,204 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:38,480 [main:67] - randomType = ArrayDeque<Boolean>
2021-03-12 08:14:38,590 [main:302] - generating value of type = ArrayDeque<Boolean> false depth = 0
2021-03-12 08:14:38,705 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<Boolean> = TODO()
2021-03-12 08:14:38,708 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<Boolean> = TODO()
2021-03-12 08:14:38,971 [main:302] - generating value of type = Int true depth = 3
2021-03-12 08:14:38,974 [main:95] - GENERATED = ArrayDeque<Boolean>(755286709)
2021-03-12 08:14:39,123 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.ArrayDeque[DeserializedSimpleFunctionDescriptor@355c7147]
2021-03-12 08:14:39,124 [main:149] - GENERATING call of type @kotlin.Deprecated @kotlin.SinceKotlin @kotlin.DeprecatedSinceKotlin public fun <T> kotlin.Array<out T>.contentToString(): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@3872845b]
2021-03-12 08:14:39,124 [main:78] - Generated call from random type = (ArrayDeque<Boolean>(755286709)).toArray().contentToString()
2021-03-12 08:14:39,124 [main:114] - replacement of "FAIL" of type String is "yavzs"
2021-03-12 08:14:39,237 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 08:14:39,237 [main:66] - Compilation checking started
2021-03-12 08:14:39,794 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (-613885904 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:39,796 [main:107] - replacing (getOrThrow(), Ty0)
2021-03-12 08:14:39,796 [main:50] - replacing getOrThrow() Ty0
2021-03-12 08:14:39,796 [main:54] - Getting value of type Ty0
2021-03-12 08:14:39,907 [main:58] - GENERATED VALUE OF TYPE Ty0 = null
2021-03-12 08:14:39,907 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:39,917 [main:67] - randomType = Kla3
2021-03-12 08:14:40,029 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:14:40,031 [main:112] - generating klass Kla3 text = class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}
2021-03-12 08:14:40,048 [main:114] - replacement of getOrThrow() of type Ty0 is null
2021-03-12 08:14:40,165 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(NULL)
2021-03-12 08:14:40,165 [main:66] - Compilation checking started
2021-03-12 08:14:40,503 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.null)
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (-613885904 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:40,506 [main:107] - replacing (getOrThrow(), Ty0)
2021-03-12 08:14:40,506 [main:50] - replacing getOrThrow() Ty0
2021-03-12 08:14:40,506 [main:54] - Getting value of type Ty0
2021-03-12 08:14:40,634 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:14:40,640 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:14:40,767 [main:67] - randomType = Float
2021-03-12 08:14:40,883 [main:302] - generating value of type = Float true depth = 0
2021-03-12 08:14:40,928 [main:111] - Cant find and generate replacement for getOrThrow() type Ty0
2021-03-12 08:14:40,929 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-12 08:14:40,929 [main:50] - replacing numberOfSuspensions Int
2021-03-12 08:14:40,929 [main:54] - Getting value of type Int
2021-03-12 08:14:41,040 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:41,043 [main:58] - GENERATED VALUE OF TYPE Int = -563095526
2021-03-12 08:14:41,043 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:41,053 [main:67] - randomType = Kla0
2021-03-12 08:14:41,164 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 08:14:41,166 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:14:41,276 [main:194] - Type params = []
2021-03-12 08:14:41,404 [main:302] - generating value of type = String true depth = 2
2021-03-12 08:14:41,411 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla0[SimpleFunctionDescriptorImpl@37c88aa6]
2021-03-12 08:14:41,521 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:14:41,521 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4ef5b9e]
2021-03-12 08:14:41,630 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:41,633 [main:78] - Generated call from random type = (Kla0("mszwh")).equals("getpn").compareTo(true)
2021-03-12 08:14:41,633 [main:114] - replacement of numberOfSuspensions of type Int is -563095526
2021-03-12 08:14:41,742 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 08:14:41,742 [main:66] - Compilation checking started
2021-03-12 08:14:42,279 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:42,281 [main:107] - replacing ({ error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }, Function0<Nothing>)
2021-03-12 08:14:42,281 [main:50] - replacing { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) } Function0<Nothing>
2021-03-12 08:14:42,281 [main:54] - Getting value of type Function0<Nothing>
2021-03-12 08:14:42,395 [main:302] - generating value of type = Function0<Nothing> false depth = 0
2021-03-12 08:14:42,398 [main:302] - generating value of type = Nothing false depth = 1
2021-03-12 08:14:42,513 [main:43] - GENERATING CALL OF fun TODO(reason: kotlin.String): Nothg = TODO()
2021-03-12 08:14:42,517 [main:61] - WITHOUT TYPE PARAMS = fun TODO(reason: kotlin.String): Nothg = TODO()
2021-03-12 08:14:42,777 [main:302] - generating value of type = String true depth = 4
2021-03-12 08:14:42,780 [main:95] - GENERATED = TODO("izlfq")
2021-03-12 08:14:42,780 [main:58] - GENERATED VALUE OF TYPE Function0<Nothing> = { TODO("izlfq")}
2021-03-12 08:14:42,780 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:42,790 [main:67] - randomType = Kla5
2021-03-12 08:14:42,903 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 08:14:42,906 [main:112] - generating klass Kla5 text = class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) }
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}
2021-03-12 08:14:42,913 [main:114] - replacement of { error((9209.toUShort())?.compareTo(32.toUByte()).toString(167773777)) } of type Function0<Nothing> is { TODO("izlfq")}
2021-03-12 08:14:43,028 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 08:14:43,029 [main:66] - Compilation checking started
2021-03-12 08:14:43,557 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:43,559 [main:107] - replacing ("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i, String)
2021-03-12 08:14:43,560 [main:50] - replacing "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i String
2021-03-12 08:14:43,560 [main:54] - Getting value of type String
2021-03-12 08:14:43,683 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:43,686 [main:58] - GENERATED VALUE OF TYPE String = "foodl"
2021-03-12 08:14:43,686 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:43,691 [main:67] - randomType = String
2021-03-12 08:14:43,800 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:43,826 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.String.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@236a3f45]
2021-03-12 08:14:43,826 [main:78] - Generated call from random type = ("sroou").uppercase()
2021-03-12 08:14:43,826 [main:114] - replacement of "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i of type String is ("sroou").uppercase()
2021-03-12 08:14:43,935 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:14:43,935 [main:66] - Compilation checking started
2021-03-12 08:14:44,464 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:44,465 [main:107] - replacing (Kla5(), Kla5)
2021-03-12 08:14:44,465 [main:50] - replacing Kla5() Kla5
2021-03-12 08:14:44,465 [main:54] - Getting value of type Kla5
2021-03-12 08:14:44,574 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 08:14:44,576 [main:112] - generating klass Kla5 text = class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}
2021-03-12 08:14:44,577 [main:58] - GENERATED VALUE OF TYPE Kla5 = Kla5()
2021-03-12 08:14:44,577 [main:61] - GENERATED IS CALL =true
2021-03-12 08:14:44,582 [main:67] - randomType = Int
2021-03-12 08:14:44,690 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:44,730 [main:114] - replacement of Kla5() of type Kla5 is Kla5()
2021-03-12 08:14:44,840 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:14:44,842 [main:107] - replacing (prope6, Boolean)
2021-03-12 08:14:44,842 [main:50] - replacing prope6 Boolean
2021-03-12 08:14:44,842 [main:54] - Getting value of type Boolean
2021-03-12 08:14:44,952 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:44,955 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 08:14:44,955 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:45,761 [main:67] - randomType = LinkedHashMap<LinkedHashMap<Boolean, Byte?>, UShort>?
2021-03-12 08:14:45,869 [main:302] - generating value of type = LinkedHashMap<LinkedHashMap<Boolean, Byte?>, UShort> false depth = 0
2021-03-12 08:14:45,987 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): LkedHashMap<LkedHashMap<Boolean, Byte?>, UShort> = TODO()
2021-03-12 08:14:45,991 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): LkedHashMap<LkedHashMap<Boolean, Byte?>, UShort> = TODO()
2021-03-12 08:14:46,108 [main:95] - GENERATED = linkedMapOf<LinkedHashMap<Boolean, Byte?>, UShort>()
2021-03-12 08:14:46,261 [main:149] - GENERATING call of type public open fun containsKey(key: kotlin.collections.LinkedHashMap<kotlin.Boolean, kotlin.Byte?>): kotlin.Boolean defined in kotlin.collections.LinkedHashMap[DeserializedSimpleFunctionDescriptor@538fe164]
2021-03-12 08:14:46,371 [main:302] - generating value of type = LinkedHashMap<Boolean, Byte?> false depth = 0
2021-03-12 08:14:46,488 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): LkedHashMap<Boolean, Byte?> = TODO()
2021-03-12 08:14:46,492 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): LkedHashMap<Boolean, Byte?> = TODO()
2021-03-12 08:14:46,624 [main:95] - GENERATED = linkedMapOf<Boolean, Byte?>()
2021-03-12 08:14:46,624 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@78753f6f]
2021-03-12 08:14:46,624 [main:78] - Generated call from random type = (linkedMapOf<LinkedHashMap<Boolean, Byte?>, UShort>())?.containsKey(linkedMapOf<Boolean, Byte?>()).not()
2021-03-12 08:14:46,624 [main:114] - replacement of prope6 of type Boolean is true
2021-03-12 08:14:46,733 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 08:14:46,734 [main:66] - Compilation checking started
2021-03-12 08:14:47,122 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        true = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:47,125 [main:107] - replacing (prope3.prope6, Boolean)
2021-03-12 08:14:47,125 [main:50] - replacing prope3.prope6 Boolean
2021-03-12 08:14:47,125 [main:54] - Getting value of type Boolean
2021-03-12 08:14:47,256 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:47,259 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 08:14:47,259 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:47,269 [main:67] - randomType = Kla1
2021-03-12 08:14:47,380 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 08:14:47,382 [main:112] - generating klass Kla1 text = class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}
2021-03-12 08:14:47,491 [main:194] - Type params = []
2021-03-12 08:14:47,614 [main:149] - GENERATING call of type public final suspend fun fu9(): kotlin.String defined in Kla1[SimpleFunctionDescriptorImpl@1c87e15d]
2021-03-12 08:14:47,614 [main:149] - GENERATING call of type public fun kotlin.String.startsWith(prefix: kotlin.String, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@21dd7699]
2021-03-12 08:14:47,724 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:47,836 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:14:47,838 [main:78] - Generated call from random type = (Kla1()).fu9().startsWith("idnnh", true)
2021-03-12 08:14:47,839 [main:114] - replacement of prope3.prope6 of type Boolean is true
2021-03-12 08:14:47,970 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 08:14:47,970 [main:66] - Compilation checking started
2021-03-12 08:14:48,284 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            true = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:48,286 [main:107] - replacing (suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}, Ty0)
2021-03-12 08:14:48,286 [main:50] - replacing suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
} Ty0
2021-03-12 08:14:48,286 [main:54] - Getting value of type Ty0
2021-03-12 08:14:48,397 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:14:48,403 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:14:48,787 [main:67] - randomType = Set<Sequence<Long>>?
2021-03-12 08:14:48,788 [main:111] - Cant find and generate replacement for suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
} type Ty0
2021-03-12 08:14:48,788 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-12 08:14:48,788 [main:50] - replacing numberOfSuspensions Int
2021-03-12 08:14:48,788 [main:54] - Getting value of type Int
2021-03-12 08:14:48,897 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:48,899 [main:58] - GENERATED VALUE OF TYPE Int = -664607414
2021-03-12 08:14:48,899 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:48,904 [main:67] - randomType = Int
2021-03-12 08:14:49,015 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:49,063 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d1ac60]
2021-03-12 08:14:49,063 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@707917f2]
2021-03-12 08:14:49,063 [main:78] - Generated call from random type = (-1883134130).toShort().toInt()
2021-03-12 08:14:49,063 [main:114] - replacement of numberOfSuspensions of type Int is -664607414
2021-03-12 08:14:49,172 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 08:14:49,172 [main:66] - Compilation checking started
2021-03-12 08:14:49,716 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = block

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:49,718 [main:107] - replacing (block, SuspendFunction0<Kla0>)
2021-03-12 08:14:49,718 [main:50] - replacing block SuspendFunction0<Kla0>
2021-03-12 08:14:49,718 [main:54] - Getting value of type SuspendFunction0<Kla0>
2021-03-12 08:14:49,826 [main:302] - generating value of type = SuspendFunction0<Kla0> false depth = 0
2021-03-12 08:14:49,829 [main:302] - generating value of type = Kla0 false depth = 1
2021-03-12 08:14:49,831 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:14:49,942 [main:194] - Type params = []
2021-03-12 08:14:50,054 [main:302] - generating value of type = String true depth = 3
2021-03-12 08:14:50,057 [main:58] - GENERATED VALUE OF TYPE SuspendFunction0<Kla0> = { Kla0("alxuu")}
2021-03-12 08:14:50,057 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:50,067 [main:67] - randomType = Kla3
2021-03-12 08:14:50,180 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:14:50,183 [main:112] - generating klass Kla3 text = class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}
2021-03-12 08:14:50,203 [main:114] - replacement of block of type SuspendFunction0<Kla0> is { Kla0("alxuu")}
2021-03-12 08:14:50,314 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 08:14:50,314 [main:66] - Compilation checking started
2021-03-12 08:14:50,846 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:50,849 [main:107] - replacing ("Wrong state-machine generated: wrong number of overall suspensions. Expected ", String)
2021-03-12 08:14:50,850 [main:50] - replacing "Wrong state-machine generated: wrong number of overall suspensions. Expected " String
2021-03-12 08:14:50,850 [main:54] - Getting value of type String
2021-03-12 08:14:50,972 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:50,975 [main:58] - GENERATED VALUE OF TYPE String = "vtfyw"
2021-03-12 08:14:50,975 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:50,985 [main:67] - randomType = Kla1
2021-03-12 08:14:51,096 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 08:14:51,099 [main:112] - generating klass Kla1 text = class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}
2021-03-12 08:14:51,208 [main:194] - Type params = []
2021-03-12 08:14:51,324 [main:149] - GENERATING call of type public final suspend fun fu9(): kotlin.String defined in Kla1[SimpleFunctionDescriptorImpl@5a2866fb]
2021-03-12 08:14:51,324 [main:149] - GENERATING call of type public fun kotlin.String.decapitalize(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@407a2809]
2021-03-12 08:14:51,324 [main:78] - Generated call from random type = (Kla1()).fu9().decapitalize()
2021-03-12 08:14:51,324 [main:114] - replacement of "Wrong state-machine generated: wrong number of overall suspensions. Expected " of type String is "vtfyw"
2021-03-12 08:14:51,431 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 08:14:51,431 [main:66] - Compilation checking started
2021-03-12 08:14:51,930 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:51,931 [main:107] - replacing ((-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame", String)
2021-03-12 08:14:51,932 [main:50] - replacing (-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame" String
2021-03-12 08:14:51,932 [main:54] - Getting value of type String
2021-03-12 08:14:52,040 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:52,042 [main:58] - GENERATED VALUE OF TYPE String = "gsnfk"
2021-03-12 08:14:52,042 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:52,175 [main:67] - randomType = Kla6?
2021-03-12 08:14:52,301 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 08:14:52,304 [main:112] - generating klass Kla6 text = class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:14:52,311 [main:114] - replacement of (-67).toChar().uppercase() + prope1 + " is not subtype of CoroutineStackFrame" of type String is "gsnfk"
2021-03-12 08:14:52,419 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:14:52,419 [main:66] - Compilation checking started
2021-03-12 08:14:52,959 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return prope0
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:52,961 [main:107] - replacing (prope1, Continuation<*>)
2021-03-12 08:14:52,961 [main:50] - replacing prope1 Continuation<*>
2021-03-12 08:14:52,961 [main:54] - Getting value of type Continuation<*>
2021-03-12 08:14:53,075 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 08:14:53,188 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 08:14:53,191 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 08:14:53,567 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 08:14:53,681 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:53,684 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:53,961 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 08:14:54,079 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:54,083 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:54,462 [main:302] - generating value of type = Key<AbstractCoroutineContextElement> false depth = 9
2021-03-12 08:14:54,580 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 08:14:54,584 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 08:14:54,958 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 08:14:54,958 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:14:54,958 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:14:54,958 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 08:14:54,958 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 08:14:55,090 [main:67] - randomType = Kla7
2021-03-12 08:14:55,240 [main:302] - generating value of type = Kla7 false depth = 0
2021-03-12 08:14:55,243 [main:112] - generating klass Kla7 text = object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}
2021-03-12 08:14:55,264 [main:111] - Cant find and generate replacement for prope1 type Continuation<*>
2021-03-12 08:14:55,264 [main:107] - replacing (getOrThrow(), Ty0)
2021-03-12 08:14:55,264 [main:50] - replacing getOrThrow() Ty0
2021-03-12 08:14:55,264 [main:54] - Getting value of type Ty0
2021-03-12 08:14:55,372 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:14:55,377 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:14:55,787 [main:67] - randomType = LinkedHashMap<UInt, MutableMap<Byte, UInt>>
2021-03-12 08:14:55,897 [main:302] - generating value of type = LinkedHashMap<UInt, MutableMap<Byte, UInt>> false depth = 0
2021-03-12 08:14:56,016 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): LkedHashMap<UInt, MutableMap<Byte, UInt>> = TODO()
2021-03-12 08:14:56,019 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): LkedHashMap<UInt, MutableMap<Byte, UInt>> = TODO()
2021-03-12 08:14:56,135 [main:95] - GENERATED = linkedMapOf<UInt, MutableMap<Byte, UInt>>()
2021-03-12 08:14:56,292 [main:111] - Cant find and generate replacement for getOrThrow() type Ty0
2021-03-12 08:14:56,292 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 08:14:56,292 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 08:14:56,293 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 08:14:56,400 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 08:14:56,405 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 08:14:56,672 [main:67] - randomType = ArrayDeque<Int?>
2021-03-12 08:14:56,789 [main:302] - generating value of type = ArrayDeque<Int?> false depth = 0
2021-03-12 08:14:56,903 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(elements: kotlin.collections.Collection<Int?>): ArrayDeque<Int?> = TODO()
2021-03-12 08:14:56,906 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(elements: kotlin.collections.Collection<Int?>): ArrayDeque<Int?> = TODO()
2021-03-12 08:14:57,153 [main:302] - generating value of type = Collection<Int?> false depth = 3
2021-03-12 08:14:57,273 [main:43] - GENERATING CALL OF fun <T> mutableListOf(elements: Int?): Collection<Int?> = TODO()
2021-03-12 08:14:57,276 [main:61] - WITHOUT TYPE PARAMS = fun <T> mutableListOf(elements: Int?): Collection<Int?> = TODO()
2021-03-12 08:14:57,390 [main:302] - generating value of type = Int true depth = 6
2021-03-12 08:14:57,392 [main:95] - GENERATED = mutableListOf<Int?>(-782173653)
2021-03-12 08:14:57,393 [main:95] - GENERATED = ArrayDeque<Int?>(mutableListOf<Int?>(-782173653))
2021-03-12 08:14:57,517 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 08:14:57,517 [main:107] - replacing (prope0, String)
2021-03-12 08:14:57,517 [main:50] - replacing prope0 String
2021-03-12 08:14:57,517 [main:54] - Getting value of type String
2021-03-12 08:14:57,627 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:14:57,630 [main:58] - GENERATED VALUE OF TYPE String = "gxooo"
2021-03-12 08:14:57,630 [main:61] - GENERATED IS CALL =false
2021-03-12 08:14:58,018 [main:67] - randomType = HashMap<Char, Double>
2021-03-12 08:14:58,126 [main:302] - generating value of type = HashMap<Char, Double> false depth = 0
2021-03-12 08:14:58,254 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): HashMap<Char, Double> = TODO()
2021-03-12 08:14:58,257 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): HashMap<Char, Double> = TODO()
2021-03-12 08:14:58,369 [main:95] - GENERATED = linkedMapOf<Char, Double>()
2021-03-12 08:14:58,458 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@6bc2f344]
2021-03-12 08:14:58,566 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:14:58,568 [main:78] - Generated call from random type = (linkedMapOf<Char, Double>()).size.toString(-1509974439)
2021-03-12 08:14:58,568 [main:114] - replacement of prope0 of type String is "gxooo"
2021-03-12 08:14:58,677 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:14:58,677 [main:66] - Compilation checking started
2021-03-12 08:14:59,201 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0(ss.s)

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:14:59,203 [main:107] - replacing (Kla0(ss.s), Kla0)
2021-03-12 08:14:59,203 [main:50] - replacing Kla0(ss.s) Kla0
2021-03-12 08:14:59,203 [main:54] - Getting value of type Kla0
2021-03-12 08:14:59,310 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 08:14:59,313 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:14:59,420 [main:194] - Type params = []
2021-03-12 08:14:59,529 [main:302] - generating value of type = String true depth = 2
2021-03-12 08:14:59,532 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla0("dljmd")
2021-03-12 08:14:59,532 [main:61] - GENERATED IS CALL =true
2021-03-12 08:14:59,663 [main:67] - randomType = Kla0?
2021-03-12 08:14:59,770 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 08:14:59,772 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:14:59,894 [main:194] - Type params = []
2021-03-12 08:15:00,001 [main:302] - generating value of type = String true depth = 2
2021-03-12 08:15:00,011 [main:114] - replacement of Kla0(ss.s) of type Kla0 is Kla0("dljmd")
2021-03-12 08:15:00,117 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:15:00,117 [main:66] - Compilation checking started
2021-03-12 08:15:00,633 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = 0
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:00,635 [main:107] - replacing (0, Int)
2021-03-12 08:15:00,635 [main:50] - replacing 0 Int
2021-03-12 08:15:00,635 [main:54] - Getting value of type Int
2021-03-12 08:15:00,752 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:15:00,754 [main:58] - GENERATED VALUE OF TYPE Int = -1946948192
2021-03-12 08:15:00,754 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:00,764 [main:67] - randomType = Kla0
2021-03-12 08:15:00,871 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 08:15:00,874 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:15:00,979 [main:194] - Type params = []
2021-03-12 08:15:01,086 [main:302] - generating value of type = String true depth = 2
2021-03-12 08:15:01,094 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.String.compareTo(other: kotlin.String, ignoreCase: kotlin.Boolean = ...): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4fadee6e]
2021-03-12 08:15:01,200 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:15:01,310 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:15:01,313 [main:78] - Generated call from random type = (Kla0("lcipo")).s.compareTo("uqryj", false)
2021-03-12 08:15:01,313 [main:114] - replacement of 0 of type Int is -1946948192
2021-03-12 08:15:01,420 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-12 08:15:01,420 [main:66] - Compilation checking started
2021-03-12 08:15:01,939 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 {
        Kla1().fu9()
    }
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:01,942 [main:107] - replacing ({
        Kla1().fu9()
    }, SuspendFunction0<Unit>)
2021-03-12 08:15:01,942 [main:50] - replacing {
        Kla1().fu9()
    } SuspendFunction0<Unit>
2021-03-12 08:15:01,942 [main:54] - Getting value of type SuspendFunction0<Unit>
2021-03-12 08:15:02,057 [main:302] - generating value of type = SuspendFunction0<Unit> false depth = 0
2021-03-12 08:15:02,060 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 08:15:02,066 [main:58] - GENERATED VALUE OF TYPE SuspendFunction0<Unit> = { println()}
2021-03-12 08:15:02,066 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:02,071 [main:67] - randomType = String
2021-03-12 08:15:02,187 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:15:02,211 [main:114] - replacement of {
        Kla1().fu9()
    } of type SuspendFunction0<Unit> is { println()}
2021-03-12 08:15:02,317 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 08:15:02,317 [main:66] - Compilation checking started
2021-03-12 08:15:02,803 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:02,805 [main:107] - replacing (prope6, Boolean)
2021-03-12 08:15:02,805 [main:50] - replacing prope6 Boolean
2021-03-12 08:15:02,805 [main:54] - Getting value of type Boolean
2021-03-12 08:15:02,918 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:15:02,921 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:15:02,921 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:03,053 [main:67] - randomType = ArrayList<ULong>
2021-03-12 08:15:03,169 [main:302] - generating value of type = ArrayList<ULong> false depth = 0
2021-03-12 08:15:03,287 [main:43] - GENERATING CALL OF fun <T> arrayListOf(): ArrayList<ULong> = TODO()
2021-03-12 08:15:03,290 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(): ArrayList<ULong> = TODO()
2021-03-12 08:15:03,408 [main:95] - GENERATED = arrayListOf<ULong>()
2021-03-12 08:15:03,548 [main:149] - GENERATING call of type protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.ArrayList[DeserializedSimpleFunctionDescriptor@ac7d0b9]
2021-03-12 08:15:03,549 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun <T> kotlin.Array<out T>.isNotEmpty(): kotlin.Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@7754d629]
2021-03-12 08:15:03,549 [main:78] - Generated call from random type = (arrayListOf<ULong>()).toArray().isNotEmpty()
2021-03-12 08:15:03,549 [main:114] - replacement of prope6 of type Boolean is (arrayListOf<ULong>()).toArray().isNotEmpty()
2021-03-12 08:15:03,655 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:15:03,655 [main:66] - Compilation checking started
2021-03-12 08:15:03,964 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        x(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.(arrayListOf<ULong>()).toArray().isNotEmpty() = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:03,966 [main:107] - replacing (x, Function1<Ty0, Unit>)
2021-03-12 08:15:03,966 [main:50] - replacing x Function1<Ty0, Unit>
2021-03-12 08:15:03,966 [main:54] - Getting value of type Function1<Ty0, Unit>
2021-03-12 08:15:04,078 [main:302] - generating value of type = Function1<Ty0, Unit> false depth = 0
2021-03-12 08:15:04,080 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 08:15:04,198 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:15:04,202 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:15:04,438 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:15:04,438 [main:95] - GENERATED = print("ehhtm")
2021-03-12 08:15:04,438 [main:58] - GENERATED VALUE OF TYPE Function1<Ty0, Unit> = {a: Ty0 -> print("ehhtm")}
2021-03-12 08:15:04,438 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:04,562 [main:67] - randomType = Byte
2021-03-12 08:15:04,679 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 08:15:04,718 [main:114] - replacement of x of type Function1<Ty0, Unit> is {a: Ty0 -> print("ehhtm")}
2021-03-12 08:15:04,834 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 08:15:04,834 [main:66] - Compilation checking started
2021-03-12 08:15:05,320 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:05,322 [main:107] - replacing (prope0.isSuccess, Boolean)
2021-03-12 08:15:05,322 [main:50] - replacing prope0.isSuccess Boolean
2021-03-12 08:15:05,322 [main:54] - Getting value of type Boolean
2021-03-12 08:15:05,430 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:15:05,432 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:15:05,432 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:05,442 [main:67] - randomType = Kla0
2021-03-12 08:15:05,552 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 08:15:05,554 [main:112] - generating klass Kla0 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)
2021-03-12 08:15:05,661 [main:194] - Type params = []
2021-03-12 08:15:05,772 [main:302] - generating value of type = String true depth = 2
2021-03-12 08:15:05,781 [main:149] - GENERATING call of type public fun kotlin.String.endsWith(suffix: kotlin.String, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@5bcc8e9a]
2021-03-12 08:15:05,893 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:15:06,006 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:15:06,009 [main:78] - Generated call from random type = (Kla0("ewgow")).s.endsWith("oshnn", true)
2021-03-12 08:15:06,009 [main:114] - replacement of prope0.isSuccess of type Boolean is (Kla0("ewgow")).s.endsWith("oshnn", true)
2021-03-12 08:15:06,118 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:15:06,120 [main:107] - replacing (Kla6(), Kla6)
2021-03-12 08:15:06,120 [main:50] - replacing Kla6() Kla6
2021-03-12 08:15:06,120 [main:54] - Getting value of type Kla6
2021-03-12 08:15:06,239 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 08:15:06,242 [main:112] - generating klass Kla6 text = class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:15:06,242 [main:58] - GENERATED VALUE OF TYPE Kla6 = Kla6()
2021-03-12 08:15:06,242 [main:61] - GENERATED IS CALL =true
2021-03-12 08:15:06,252 [main:67] - randomType = Kla3
2021-03-12 08:15:06,368 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:15:06,370 [main:112] - generating klass Kla3 text = class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}
2021-03-12 08:15:06,388 [main:114] - replacement of Kla6() of type Kla6 is Kla6()
2021-03-12 08:15:06,494 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:15:06,496 [main:107] - replacing (prope5, Int)
2021-03-12 08:15:06,497 [main:50] - replacing prope5 Int
2021-03-12 08:15:06,497 [main:54] - Getting value of type Int
2021-03-12 08:15:06,603 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:15:06,606 [main:58] - GENERATED VALUE OF TYPE Int = 215625767
2021-03-12 08:15:06,606 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:06,616 [main:67] - randomType = Kla6
2021-03-12 08:15:06,737 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 08:15:06,739 [main:112] - generating klass Kla6 text = class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + prope5)
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:15:06,749 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4ef5b9e]
2021-03-12 08:15:06,856 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:15:06,859 [main:78] - Generated call from random type = (Kla6()).prope6.compareTo(true)
2021-03-12 08:15:06,859 [main:114] - replacement of prope5 of type Int is (Kla6()).prope6.compareTo(true)
2021-03-12 08:15:06,967 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:15:06,967 [main:66] - Compilation checking started
2021-03-12 08:15:07,448 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (prope6) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:07,450 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 08:15:07,450 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 08:15:07,450 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 08:15:07,564 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 08:15:07,569 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 08:15:07,834 [main:67] - randomType = UShort?
2021-03-12 08:15:07,945 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 08:15:07,990 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 08:15:07,990 [main:107] - replacing (prope6, Boolean)
2021-03-12 08:15:07,991 [main:50] - replacing prope6 Boolean
2021-03-12 08:15:07,991 [main:54] - Getting value of type Boolean
2021-03-12 08:15:08,104 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:15:08,107 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:15:08,107 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:08,117 [main:67] - randomType = Kla2
2021-03-12 08:15:08,227 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 08:15:08,230 [main:112] - generating klass Kla2 text = open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}
2021-03-12 08:15:08,337 [main:194] - Type params = []
2021-03-12 08:15:08,444 [main:302] - generating value of type = CoroutineContext false depth = 2
2021-03-12 08:15:08,573 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:15:08,577 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:15:08,820 [main:302] - generating value of type = Key<*> false depth = 5
2021-03-12 08:15:08,935 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:15:08,939 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:15:09,314 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:15:09,314 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:15:09,330 [main:149] - GENERATING call of type public open fun resumeWith(prope0: kotlin.Result<kotlin.Any?>): kotlin.Unit defined in Kla2[SimpleFunctionDescriptorImpl@53ef89f4]
2021-03-12 08:15:09,437 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 08:15:09,548 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:15:09,552 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:15:09,791 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 08:15:09,794 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:15:09,794 [main:95] - GENERATED = runCatching<Any?>({ "pkeeu"})
2021-03-12 08:15:09,794 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Unit[DeserializedSimpleFunctionDescriptor@1fd8b936]
2021-03-12 08:15:09,901 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:15:09,901 [main:78] - Generated call from random type = (Kla2()).resumeWith(runCatching<Any?>({ "pkeeu"})).equals("kwwal")
2021-03-12 08:15:09,901 [main:114] - replacement of prope6 of type Boolean is false
2021-03-12 08:15:10,007 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 08:15:10,008 [main:66] - Compilation checking started
2021-03-12 08:15:10,523 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != i) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:10,525 [main:107] - replacing (i, Int)
2021-03-12 08:15:10,525 [main:50] - replacing i Int
2021-03-12 08:15:10,525 [main:54] - Getting value of type Int
2021-03-12 08:15:10,636 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:15:10,639 [main:58] - GENERATED VALUE OF TYPE Int = -1426466537
2021-03-12 08:15:10,639 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:10,649 [main:67] - randomType = ULong?
2021-03-12 08:15:10,761 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 08:15:10,799 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@6b9c9c7f]
2021-03-12 08:15:10,800 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@2fd87cdc]
2021-03-12 08:15:10,907 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 08:15:10,910 [main:78] - Generated call from random type = (4337723899545606718.toULong())?.toLong().compareTo(19)
2021-03-12 08:15:10,910 [main:114] - replacement of i of type Int is (4337723899545606718.toULong())?.toLong().compareTo(19)
2021-03-12 08:15:11,017 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:15:11,017 [main:66] - Compilation checking started
2021-03-12 08:15:11,516 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:11,518 [main:107] - replacing (prope7, Function0<Unit>)
2021-03-12 08:15:11,518 [main:50] - replacing prope7 Function0<Unit>
2021-03-12 08:15:11,518 [main:54] - Getting value of type Function0<Unit>
2021-03-12 08:15:11,628 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 08:15:11,630 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 08:15:11,748 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:15:11,752 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:15:11,990 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:15:11,990 [main:95] - GENERATED = println("pixug")
2021-03-12 08:15:11,990 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println("pixug")}
2021-03-12 08:15:11,990 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:12,001 [main:67] - randomType = Kla2
2021-03-12 08:15:12,108 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 08:15:12,111 [main:112] - generating klass Kla2 text = open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}
2021-03-12 08:15:12,237 [main:194] - Type params = []
2021-03-12 08:15:12,344 [main:302] - generating value of type = CoroutineContext false depth = 2
2021-03-12 08:15:12,457 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:15:12,461 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:15:12,706 [main:302] - generating value of type = Key<*> false depth = 5
2021-03-12 08:15:12,830 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:15:12,834 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:15:13,208 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 08:15:13,208 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 08:15:13,225 [main:114] - replacement of prope7 of type Function0<Unit> is { println("pixug")}
2021-03-12 08:15:13,333 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 08:15:13,333 [main:66] - Compilation checking started
2021-03-12 08:15:13,669 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        { println("pixug")} = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != numberOfSuspensions)
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:13,671 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-12 08:15:13,671 [main:50] - replacing numberOfSuspensions Int
2021-03-12 08:15:13,671 [main:54] - Getting value of type Int
2021-03-12 08:15:13,781 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:15:13,783 [main:58] - GENERATED VALUE OF TYPE Int = -1114273276
2021-03-12 08:15:13,783 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:13,788 [main:67] - randomType = Int
2021-03-12 08:15:13,897 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:15:13,948 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5a006cda]
2021-03-12 08:15:14,056 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:15:14,059 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5e514d49]
2021-03-12 08:15:14,059 [main:78] - Generated call from random type = (1949069301).compareTo(-1397023221).unaryPlus()
2021-03-12 08:15:14,059 [main:114] - replacement of numberOfSuspensions of type Int is (1949069301).compareTo(-1397023221).unaryPlus()
2021-03-12 08:15:14,167 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:15:14,168 [main:66] - Compilation checking started
2021-03-12 08:15:14,651 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != (1949069301).compareTo(-1397023221).unaryPlus())
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:14,652 [main:107] - replacing (prope7, Function0<Unit>)
2021-03-12 08:15:14,653 [main:50] - replacing prope7 Function0<Unit>
2021-03-12 08:15:14,653 [main:54] - Getting value of type Function0<Unit>
2021-03-12 08:15:14,762 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 08:15:14,765 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 08:15:14,879 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:15:14,882 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 08:15:15,122 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:15:15,122 [main:95] - GENERATED = println("rqdzk")
2021-03-12 08:15:15,123 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println("rqdzk")}
2021-03-12 08:15:15,123 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:15,247 [main:67] - randomType = Double
2021-03-12 08:15:15,356 [main:302] - generating value of type = Double true depth = 0
2021-03-12 08:15:15,394 [main:114] - replacement of prope7 of type Function0<Unit> is { println("rqdzk")}
2021-03-12 08:15:15,505 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 08:15:15,505 [main:66] - Compilation checking started
2021-03-12 08:15:15,905 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + prope5)
            { println("rqdzk")}()
        }
        if (prope5 != (1949069301).compareTo(-1397023221).unaryPlus())
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:15,907 [main:107] - replacing (prope0, Any?)
2021-03-12 08:15:15,908 [main:50] - replacing prope0 Any?
2021-03-12 08:15:15,908 [main:54] - Getting value of type Any?
2021-03-12 08:15:16,025 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:15:16,025 [main:58] - GENERATED VALUE OF TYPE Any? = "sfysi"
2021-03-12 08:15:16,026 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:16,411 [main:67] - randomType = Collection<UByte>
2021-03-12 08:15:16,411 [main:114] - replacement of prope0 of type Any? is "sfysi"
2021-03-12 08:15:16,520 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:15:16,520 [main:66] - Compilation checking started
2021-03-12 08:15:16,836 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        prope0.exceptionOrNull()?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this."sfysi" = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != (1949069301).compareTo(-1397023221).unaryPlus())
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:16,838 [main:107] - replacing (suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}, Ty0)
2021-03-12 08:15:16,838 [main:50] - replacing suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
} Ty0
2021-03-12 08:15:16,838 [main:54] - Getting value of type Ty0
2021-03-12 08:15:16,962 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:15:16,968 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:15:16,983 [main:67] - randomType = Kla5?
2021-03-12 08:15:17,098 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 08:15:17,101 [main:112] - generating klass Kla5 text = class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}
2021-03-12 08:15:17,108 [main:111] - Cant find and generate replacement for suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
} type Ty0
2021-03-12 08:15:17,109 [main:107] - replacing (prope0.exceptionOrNull(), Throwable?)
2021-03-12 08:15:17,109 [main:50] - replacing prope0.exceptionOrNull() Throwable?
2021-03-12 08:15:17,109 [main:54] - Getting value of type Throwable?
2021-03-12 08:15:17,217 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 08:15:17,335 [main:43] - GENERATING CALL OF fun NullPointerException(message: kotlin.String?): Throwable = TODO()
2021-03-12 08:15:17,339 [main:61] - WITHOUT TYPE PARAMS = fun NullPointerException(message: kotlin.String?): Throwable = TODO()
2021-03-12 08:15:17,579 [main:302] - generating value of type = String true depth = 3
2021-03-12 08:15:17,582 [main:95] - GENERATED = NullPointerException("ihmrw")
2021-03-12 08:15:17,582 [main:58] - GENERATED VALUE OF TYPE Throwable? = NullPointerException("ihmrw")
2021-03-12 08:15:17,582 [main:61] - GENERATED IS CALL =true
2021-03-12 08:15:17,592 [main:67] - randomType = Kla6
2021-03-12 08:15:17,702 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 08:15:17,704 [main:112] - generating klass Kla6 text = class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != (1949069301).compareTo(-1397023221).unaryPlus())
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:15:17,714 [main:114] - replacement of prope0.exceptionOrNull() of type Throwable? is NullPointerException("ihmrw")
2021-03-12 08:15:17,844 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:15:17,844 [main:66] - Compilation checking started
2021-03-12 08:15:18,346 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        NullPointerException("ihmrw")?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + prope5)
            prope7()
        }
        if (prope5 != (1949069301).compareTo(-1397023221).unaryPlus())
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:18,348 [main:107] - replacing (prope5, Int)
2021-03-12 08:15:18,348 [main:50] - replacing prope5 Int
2021-03-12 08:15:18,348 [main:54] - Getting value of type Int
2021-03-12 08:15:18,457 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:15:18,459 [main:58] - GENERATED VALUE OF TYPE Int = -1464711845
2021-03-12 08:15:18,459 [main:61] - GENERATED IS CALL =false
2021-03-12 08:15:19,129 [main:67] - randomType = Function1<Map<Float, LinkedHashSet<UByte>>, String>
2021-03-12 08:15:19,129 [main:114] - replacement of prope5 of type Int is -1464711845
2021-03-12 08:15:19,237 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 08:15:19,238 [main:66] - Compilation checking started
2021-03-12 08:15:19,746 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        NullPointerException("ihmrw")?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + -1464711845)
            prope7()
        }
        if (prope5 != (1949069301).compareTo(-1397023221).unaryPlus())
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:19,749 [main:107] - replacing (this, Kla3)
2021-03-12 08:15:19,749 [main:50] - replacing this Kla3
2021-03-12 08:15:19,749 [main:54] - Getting value of type Kla3
2021-03-12 08:15:19,887 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:15:19,891 [main:112] - generating klass Kla3 text = class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        this.prope0 = "nztxf"
    }

    var prope0: Any? = null
}
2021-03-12 08:15:19,891 [main:58] - GENERATED VALUE OF TYPE Kla3 = Kla3()
2021-03-12 08:15:19,891 [main:61] - GENERATED IS CALL =true
2021-03-12 08:15:20,147 [main:67] - randomType = Byte?
2021-03-12 08:15:20,261 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 08:15:20,295 [main:114] - replacement of this of type Kla3 is Kla3()
2021-03-12 08:15:20,404 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:15:20,404 [main:66] - Compilation checking started
2021-03-12 08:15:20,882 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
fun test(p: Pair<Int, Int>) {
    val (x, y) = p
}

var prope0 = "yavzs"

fun fu0(prope1: suspend () -> Unit) {
    prope1.startCoroutine(fu4 {
        prope0 = (linkedMapOf<Kla5?, Short>(Pair<Kla5?, Short>(Kla5(), -4826))).size.toString(-496100835)!!
    })
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla0(val s: String)

var prope1: Continuation<Any>? = null

suspend fun <Ty0> fu1(): Ty0 = suspendCoroutine {
    @Suppress("bptra")
    prope1 = it as Continuation<Any>
}

fun fu2(block: suspend () -> Kla0) = { Kla0("alxuu")}

class Kla1() {

    suspend fun <Ty0> fu5(value: Ty0): Ty0 = value

    suspend fun fu6(ss: Kla0): Kla0 = Kla0("dljmd")

    suspend fun <Ty0> fu7(t: Ty0): Ty0 = t

    suspend fun fu8(): Kla0 {
        return fu2 { fu5(fu6(Kla0("wjpsx"))) }()
    }

    suspend fun fu9() = Kla0("thveu").s
}

fun box907(): String {
    fu0 { println()}
    check(false, { "pyziu"})

    if ((Kla3()).equals("ndooe").not()) return "FAIL 1 $prope0"

    return "gxooo"
}

fun <Ty0> fu3(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        {a: Ty0 -> print("ehhtm")}(prope0.getOrThrow())
    }
}

fun fu4(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        NullPointerException("ihmrw")?.let(x)
    }
}

open class Kla2(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla8 : Kla2()
    override fun resumeWith(prope0: Result<Any?>) {
        runCatching<Any?>({ "kpeyb"}).getOrThrow()
    }
}

class Kla3 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Any?>) {
        Kla3().prope0 = "nztxf"
    }

    var prope0: Any? = null
}

abstract class Kla4<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope0: Result<Ty0>) {
        if (prope0.isSuccess) {
            resume(prope0.getOrThrow())
        } else {
            resumeWithException(prope0.exceptionOrNull()!!)
        }
    }

    abstract fun resumeWithException(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla5 {
    private val prope4 = arrayListOf<StackTraceElement?>()

    suspend fun fu12() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> print("gaeft")}

    fun fu12(prope1: Continuation<*>) {
        if (prope1 !is CoroutineStackFrame) error("gsnfk")
        prope4.clear()
        var prope8: CoroutineStackFrame? = prope1
        while (prope8 != null) {
            prope4.add(prope8.getStackTraceElement())
            prope8 = prope8.callerFrame
        }
    }

    fun fu13(method: String) {
        prope4.find { (Kla6()).prope7.equals("hysxl") }?.let { TODO("izlfq")}
    }

    fun fu14(method: String) {
        prope4.find { it?.methodName?.startsWith(method) == true } ?: error((Pair<ULong?, UInt>(2364655314861301115.toULong(), 1658086921.toUInt()))?.second.toString(-1791217051))
    }
}

val prope2 = Kla5()

class Kla6 {
    private var prope5 = 0
    var prope6 = true

    var prope7: () -> Unit = {}

    fun fu15() {
        prope5 = -1946948192
        prope6 = false
        prope7 = {}
    }

    suspend fun fu16() = suspendCoroutine<Unit> { prope1 ->
        -1733689611
        prope7 = { prope1.resume(Unit) }
    }

    fun fu17(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..-563095526) {
            if (-613885904 != (4337723899545606718.toULong())?.toLong().compareTo(19)) error(("sroou").uppercase() + "olcna" + -1464711845)
            prope7()
        }
        if (prope5 != (1949069301).compareTo(-1397023221).unaryPlus())
            error("vtfyw" + -664607414 + ", got " + (Kla6()).prope6.compareTo(true))
        if (false) error("Wrong state-machine generated: it is finished early")
        prope7()
        if (checkFinished && !prope6) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope3 = Kla6()

object Kla7: Kla4<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope3.prope7 = {
            prope3.prope6 = true
        }
    }

    override fun resumeWithException(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:15:20,884 [main:107] - replacing (prope0.getOrThrow(), Ty0)
2021-03-12 08:15:20,884 [main:50] - replacing prope0.getOrThrow() Ty0
2021-03-12 08:15:20,884 [main:54] - Getting value of type Ty0
