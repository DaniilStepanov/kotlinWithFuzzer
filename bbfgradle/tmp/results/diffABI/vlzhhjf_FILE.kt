// Bug happens on JVM , JVM -Xuse-ir
// TARGET_BACKEND: JVM
// FILE: tmp0.kt


package caoreyb
import kotlin.jvm.*
import kotlin.collections.*
import kotlin.reflect.*
import kotlin.contracts.*
import kotlin.sequences.*
import kotlin.coroutines.*
object X {
    @JvmStatic val x = "OK"

    fun fn(value : String = x): String = TODO()
}

fun box(): String =TODO()

private final class Hiy {

external public fun <T: UByte, S>   ArrayDeque<X>.fklsl(a: T): Pair<HashMap<X, X>, Float>

val ULong.qkxf: X 
get() =  X


val fafg: ArrayDeque<X> = TODO()

var ArrayList<Double>.zudj: Float 
get() =  TODO()
set(value) = TODO()

var veoi: X = TODO()

val wgxu: X = TODO()

val gqxu: X = TODO()

val pqdc: Collection<Float> = TODO()

var mezd: Set<UByte> = HashSet<UByte>(listOf<UByte>())

}










internal interface Yfp <T> : Set<X>, MutableMap<Double, List<X>>, CoroutineContext{

override val size:  kotlin.Int
override fun contains(element: X): kotlin.Boolean = TODO()

override val keys:  kotlin.collections.MutableSet<kotlin.Double>
override val values:  kotlin.collections.MutableCollection<kotlin.collections.List<X>>
override fun containsValue(value: kotlin.collections.List<X>): kotlin.Boolean = TODO()

override fun get(key: kotlin.Double): kotlin.collections.List<X>? = TODO()

override fun isEmpty(): kotlin.Boolean = TODO()

override fun <R> fold(initial: R, operation: (R, kotlin.coroutines.CoroutineContext.Element) -> R): R = TODO()

override fun plus(context: kotlin.coroutines.CoroutineContext): kotlin.coroutines.CoroutineContext = TODO()

var Int.fxkg: UShort 
get() = TODO()
set(value) = TODO()

val zxnx: X 

var bdtc: Boolean 

val Sequence<X>.udun: Sequence<X> 
get() = TODO()


val uhyw: ArrayDeque<T> 

val xeir: UByte 

val lzlv: X 

var jbgu: Double 

}
