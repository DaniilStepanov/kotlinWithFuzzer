// Bug happens on JVM , JVM -Xuse-ir
// IGNORE_BACKEND_FIR: JVM_IR
// FILE: tmp0.kt


import kotlin.collections.*
import kotlin.sequences.*
fun test1():Unit =TODO()

fun <T> Array<out T>.joinToString(): String = TODO()

public inline fun <reified T, R> combine(
    vararg flows: Flow<T>,
    crossinline transform: suspend (Array<T>) -> R
): Flow<R> = TODO()

fun <T> flowOf(value: T): Flow<T> = TODO()
interface Flow<out T>

fun box(): String =TODO()

object Ytt : Flow <Flow<Double>>{


operator  fun <T, S>   Byte.plus(a: Flow<Long>): Flow<Double?>? = TODO()

public fun <T>  rqhok(a: LinkedHashMap<Function1<HashMap<Char, String>, Flow<String>>, Flow<Set<Short?>>>, b: Flow<Float?>): Byte = TODO()

var agtl: Boolean  
get() = TODO()
set(value) = TODO()


val Flow<Pair<Function2<ArrayDeque<Float>, Double, Boolean?>, UByte?>>.dpdd: Flow<UByte>  
get() =  TODO()






}







public fun  ljxeq(a: Boolean): Char? = TODO()







abstract class Byi (var dso: Triple<Float?, Flow<List<Flow<Byte>>?>, Flow<Float?>>, val rsx: LinkedHashMap<HashMap<Long, Byte>, Sequence<Flow<Float>>> = linkedMapOf<HashMap<Long, Byte>, Sequence<Flow<Float>>>()): Flow <Flow<Float?>>{


inline tailrec  fun <T, S>  ulkll(a: S, b: Flow<UInt>?, c: T): Flow<Flow<Short?>> = TODO()

suspend public fun <T>  vljvk(a: T, b: HashSet<Flow<String>>): LinkedHashSet<ULong?>? = TODO()





}




private interface Ysk : Flow<Char?>{


private fun  olzvh(a: LinkedHashMap<Flow<UByte>, Byte>): Flow<String?>? = TODO()

fun <T, S>  zkqde(a: String, b: Flow<Function2<Double?, Function1<Flow<Short>?, Sequence<ULong>>, UByte?>>): LinkedHashMap<Function1<UByte, Map<Flow<Float>?, Int>>, Flow<Flow<Short>?>> = TODO()

var hlmf: UShort  

val wjal: Function2<Function1<Int, Flow<Boolean>>, Long, Boolean>  

var pmsz: Int  







}

internal interface Que <T> {


fun  ylicj(a: Double): Flow<UShort> = TODO()

fun <T, S>  sxmut(a: Flow<Double>, b: Long, c: Array<Boolean>?, d: Float): Set<Flow<ULong>>

var trke: Char  



val mmsa: T  

val xdem: Flow<Int>  







}

public sealed class Jpc <in T> {


fun <T, S>  ayyeu(a: LinkedHashMap<Sequence<Collection<ULong?>>, String>?, b: Flow<MutableMap<Char?, Triple<Char, Int, Byte?>>>?): Char = TODO()

val shjk: Flow<Char>  
get() = TODO()


val mueu: Char  
get() = TODO()






}

public interface Sji <in T, S> {


inline  private fun  npjek(a: String): HashMap<Flow<UShort>, S> = TODO()

private fun   Function1<UInt, String?>.duptp(a: Short): T = TODO()

var kihg: Flow<Float>  







}


